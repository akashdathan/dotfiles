{"id":"a44c682f-2695-4154-bc9e-eefbbcf76ab7","zed":"context","version":"0.4.0","text":"\n\n\nTerminal output:\n{ id: undefined }\n{ id: 3 }\n{ id: undefined }\n{ id: undefined }\n{ id: undefined }\n{ id: 4 }\n{ id: undefined }\n{ id: undefined }\n{ id: undefined }\n{ id: 5 }\n{ id: undefined }\n{ id: undefined }\n{ id: undefined }\n{ id: 6 }\n{ id: undefined }\n{ id: undefined }\n{ id: undefined }\n{ id: undefined }\n{ id: undefined }\n{ id: 7 }\n FAIL   serverSystemTests  src/server/new-structure/application/use-cases/request/documents/request-approval/system.test.ts\n  Request Documents - Request Approval\n    ✕ should reset the review flow when request approval is sent from terminate state (744 ms)\n    Should be allowed when\n      document is unreviewed and the user is\n        ✓ a location admin (326 ms)\n        ✓ an admin (287 ms)\n        ✓ document control (248 ms)\n        ✓ creator of the document (246 ms)\n    Should not be allowed when\n      ✓ any other user (100 ms)\n      ✓ document is in review (330 ms)\n  ● Request Documents - Request Approval › should reset the review flow when request approval is sent from terminate state\n    Unable to request document approval\n      37 |   expectedStatusCode: number\n      38 | ): void => {\n    > 39 |   if (response.status !== expectedStatusCode) throw new UnexpectedResponseError(errorMessage, response);\n         |                                                     ^\n      40 | };\n      41 |\n      42 | export const assertResponseContentTypeIsJson = (response: Response, errorMessage: string): void => {\n      at assertResponseStatusCode (test/system/utils.ts:39:53)\n      at handleFetch (test/system/utils.ts:68:27)\n      at Object.<anonymous> (new-structure/application/use-cases/request/documents/request-approval/system.test.ts:100:5)\nA worker process has failed to exit gracefully and has been force exited. This is likely caused by tests leaking due to improper teardown. Try running with --detectOpenHandles to find leaks. Active timers can also cause this, ensure that .unref() was called on them.\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 6 passed, 7 total\nSnapshots:   0 total\nTime:        7.35 s\nRan all test suites matching /\\/Users\\/adathan\\/Tesla\\/atom-web\\/src\\/server\\/new-structure\\/application\\/use-cases\\/request\\/documents\\/request-approval\\/system.test.ts/i with tests matching \"Request Documents - Request Approval\".\nhwy is teh foreig key vioalteed error there\nLooking at the terminal output and the error pattern, it seems there's a foreign key violation occurring during the test \"should reset the review flow when request approval is sent from terminate state\".\n\nThe pattern of IDs being logged ({ id: undefined } and sequential IDs) suggests that there might be a few potential issues:\n\n1. Race Condition: The test might be trying to create or modify records without proper sequencing or waiting for dependent operations to complete.\n\n2. Missing Dependencies: The test might be attempting to reference records that don't exist in the database.\n\n3. Cleanup Issues: Previous test runs might not be cleaning up properly, leaving the database in an inconsistent state.\n\nTo fix this, I would suggest:\n\n1. Ensure proper test isolation and cleanup:\n```typescript\nbeforeEach(async () => {\n  // Clean up relevant tables\n  await db.transaction(async (trx) => {\n    await trx('dependent_table').del();\n    await trx('main_table').del();\n  });\n});\n```\n\n2. Verify that all required records exist before making the request:\n```typescript\ntest('should reset the review flow when request approval is sent from terminate state', async () => {\n  // Setup prerequisite data\n  const document = await createTestDocument();\n  const user = await createTestUser();\n  \n  // Ensure all foreign key references exist\n  expect(document.id).toBeDefined();\n  expect(user.id).toBeDefined();\n  \n  // Make the request\n  const response = await requestApproval(document.id, user.id);\n});\n```\n\n3. Add proper error handling and logging:\n```typescript\ntry {\n  const response = await requestApproval(document.id, user.id);\n} catch (error) {\n  console.error('Detailed error:', error);\n  throw error;\n}\n```\n\n4. Check the database schema to ensure foreign key constraints are properly defined:\n```typescript\n// Example schema\nexport const documentSchema = {\n  id: 'primary key',\n  userId: 'foreign key references users(id)',\n  // other fields...\n};\n```\n\nCould you share the relevant test code and schema definitions? That would help identify the specific foreign key that's being violated.\n```ts atom-web/src/server/new-structure/application/repositories/document.repo.ts\nimport { accessibleBy } from \"@casl/prisma\";\nimport { Prisma } from \"@prisma/client\";\nimport { inject, injectable } from \"inversify\";\nimport _, { isEmpty } from \"lodash\";\nimport { DBClient } from \"../../../config/database/client\";\nimport { DocumentNumberAlreadyExistsError, EntityNotFoundError } from \"../../../utils/errors\";\nimport { CompanyMap } from \"../../domain/company/company.map\";\nimport { CSIDivisionMap } from \"../../domain/csi-division/csi-division.map\";\nimport { DisciplineMap } from \"../../domain/discipline/discipline.map\";\nimport { DocumentRevisionLinkType } from \"../../domain/document/entities/doc-revision-link.entity\";\nimport { DocRevision } from \"../../domain/document/entities/doc-revision.entity\";\nimport { Document, DocumentProps } from \"../../domain/document/entities/document.entity\";\nimport { File } from \"../../domain/document/entities/file.entity\";\nimport { RevisionStatusType, TRevisionStatusType } from \"../../domain/document/entities/revision-status-type.entity\";\nimport { DocRevisionMap } from \"../../domain/document/mappers/doc-revision.map\";\nimport { DocumentMap } from \"../../domain/document/mappers/document.map\";\nimport { FileMap } from \"../../domain/document/mappers/file.map\";\nimport { IDocumentRepo } from \"../../domain/document/repos/document.repo\";\nimport { ReferencedDocData } from \"../../domain/document/services/document.service\";\nimport { AreaMap } from \"../../domain/location/mappers/area.map\";\nimport { LevelMap } from \"../../domain/location/mappers/level.map\";\nimport { ILocationRepo } from \"../../domain/location/repos/location.repo\";\nimport { PersistedProject, Project } from \"../../domain/project/entities/project.entity\";\nimport {\n  PersistedRequestInstance,\n  RequestInstance,\n} from \"../../domain/request/instance/entities/request-instance.entity\";\nimport { PersistedScope, Scope } from \"../../domain/scope/entities/scope.entity\";\nimport { DocumentPurposeMap } from \"../../domain/settings/document-purpose/map\";\nimport { DocumentTypeMap } from \"../../domain/settings/document-type/map\";\nimport { LocationDocumentPurpose } from \"../../domain/settings/locations/document-purpose/entity\";\nimport { LocationDocumentPurposeMap } from \"../../domain/settings/locations/document-purpose/map\";\nimport { LocationProgramMap } from \"../../domain/settings/locations/program/map\";\nimport { ProgramMap } from \"../../domain/settings/program/map\";\nimport { User } from \"../../domain/user/user.entity\";\nimport { UserMap } from \"../../domain/user/user.map\";\nimport { AuthzService } from \"../../framework/application/authz.service\";\nimport { FilterDTOPrisma } from \"../../framework/application/get-many\";\nimport { PaginatedFilteredDTO, PaginatedFilteredDTOResult } from \"../../framework/application/paginated-filtered-dto\";\nimport { Collection } from \"../../framework/domain/collection\";\nimport { assertPersistency, PersistedEntity } from \"../../framework/domain/entity\";\nimport { BaseRepo } from \"../../framework/infrastructure/base-repo\";\nimport TYPES from \"../../framework/inversify/types\";\nimport { companyQueryInclude } from \"./company.repo\";\nimport { userQueryInclude } from \"./user.repo\";\nimport {\n  DocumentSubmittalCategoryMap,\n  DocumentSubmittalDetailMap,\n  DocumentSubmittalTypeMap,\n} from \"../../domain/settings/locations/document-submittal-metadata/submittal.map\";\nimport { DocumentFieldType, DocumentNumberingScheme } from \"@atom/types\";\n\nexport const getDocumentQueryInclude = (authzService: AuthzService) => {\n  return {\n    document_package_document: true,\n    document_program: true,\n    document_revision: {\n      where: accessibleBy(authzService.getUserAbility(), \"read\").document_revision,\n      include: {\n        project_document_revision: {\n          include: {\n            project: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        scope_document_revision: {\n          include: {\n            scope: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        request_document_revision: {\n          include: {\n            request: {\n              select: {\n                request_form_value: {\n                  select: {\n                    title: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n        document_revision_status: {\n          include: {\n            document_revision_status_type: true,\n          },\n        },\n        file: {\n          select: {\n            extension: true,\n          },\n        },\n        location_document_purpose: {\n          include: {\n            document_purpose: true,\n          },\n        },\n      },\n    },\n    document_additional_area: {\n      select: {\n        area_id: true,\n      },\n    },\n    document_csi_division: true,\n    document_submittal_category: true,\n    document_submittal_type: true,\n    document_submittal_detail: true,\n  } satisfies Prisma.Args<typeof DBClient.document, \"findMany\">[\"include\"];\n};\nconst typeToProperty = {\n  [DocumentFieldType.Type.SITE]: \"siteID\",\n  [DocumentFieldType.Type.BUILDING]: \"buildingID\",\n  [DocumentFieldType.Type.AREA]: \"areaID\",\n  [DocumentFieldType.Type.AREA_DETAIL]: \"areaDetailID\",\n  [DocumentFieldType.Type.LEVEL]: \"levelID\",\n  [DocumentFieldType.Type.PROGRAM]: \"locationProgramIDs\",\n  [DocumentFieldType.Type.TYPE]: \"typeID\",\n  [DocumentFieldType.Type.DISCIPLINE]: \"disciplineID\",\n} as const satisfies Partial<{\n  [key in (typeof DocumentFieldType.Type)[keyof typeof DocumentFieldType.Type]]: string;\n}>;\nconst propertyToColumn = {\n  siteID: \"site_id\",\n  buildingID: \"building_id\",\n  areaID: \"area_id\",\n  areaDetailID: \"area_detail_id\",\n  levelID: \"level_id\",\n  locationProgramIDs: \"document_program\",\n  typeID: \"document_type_id\",\n  disciplineID: \"discipline_id\",\n} as const;\n\nexport type DocumentMetadata = {\n  number: string;\n  buildingID: number;\n  siteID: number | null;\n  areaID: number;\n  areaDetailID: number | null;\n  levelID: number;\n  locationProgramIDs: number[];\n  typeID: number;\n  disciplineID: number;\n  locationDocumentPurposeID: number;\n};\n\n@injectable()\nexport class DocumentRepo extends BaseRepo implements IDocumentRepo {\n  constructor(\n    @inject(TYPES.DBClient) protected readonly db: typeof DBClient,\n    @inject(TYPES.ILocationRepo) protected readonly locationRepo: ILocationRepo,\n    @inject(AuthzService) private readonly authzService: AuthzService,\n    @inject(\"DocumentFilterDTOPrisma\")\n    private readonly filterDTOPrisma: FilterDTOPrisma<DocumentProps>\n  ) {\n    super(db);\n  }\n\n  private readonly baseQuery = { is_deleted: 0 } satisfies Prisma.documentWhereInput;\n\n  async getByID(id: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: id,\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getManyByIDs(ids: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: {\n              in: ids,\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByDocumentNumbers(documentNumbers: string[], locationID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          { location_id: locationID },\n          {\n            document_number: { in: documentNumbers },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByPackageID(packageID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_package_document: {\n              some: {\n                package_id: packageID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByRevisionID(revisionID: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: revisionID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getByRevisionIDs(revisionIDs: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: { in: revisionIDs },\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getMany(paginatedFilteredDTO: PaginatedFilteredDTO<Document>): Promise<PaginatedFilteredDTOResult<Document>> {\n    const { filters, parentEntity, locationID, excludeParentEntity } = paginatedFilteredDTO;\n    const filterQuery = this.filterDTOPrisma.createPrismaQuery(filters.filterDTO);\n    const parentSelect = parentEntity && this.getParentSelect(parentEntity);\n    const excludeParent = excludeParentEntity && this.getParentSelect(excludeParentEntity);\n\n    const query: Prisma.documentWhereInput = {\n      AND: [\n        accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n        this.baseQuery,\n        filterQuery,\n        locationID ? { location_id: locationID } : {},\n        excludeParent\n          ? {\n              document_revision: {\n                some: {\n                  [excludeParent.table_name]: {\n                    none: {\n                      [excludeParent.ref_name]: excludeParent.id,\n                    },\n                  },\n                },\n              },\n            }\n          : {},\n        {\n          OR: [\n            parentSelect\n              ? {\n                  document_revision: {\n                    some: {\n                      [parentSelect.table_name]: {\n                        some: {\n                          [parentSelect.ref_name]: parentSelect.id,\n                        },\n                      },\n                    },\n                  },\n                }\n              : {},\n            filters.scopeIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.scopeIDs,\n                  refName: \"scope_id\",\n                  tableName: \"scope_document_revision\",\n                })\n              : {},\n            filters.requestIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.requestIDs,\n                  refName: \"request_id\",\n                  tableName: \"request_document_revision\",\n                })\n              : {},\n            filters.projectIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.projectIDs,\n                  refName: \"project_id\",\n                  tableName: \"project_document_revision\",\n                })\n              : {},\n          ],\n        },\n      ],\n    };\n\n    let pagination = {};\n\n    if (paginatedFilteredDTO.page && paginatedFilteredDTO.pageSize) {\n      pagination = {\n        take: paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize,\n        skip: (paginatedFilteredDTO.page - 1) * paginatedFilteredDTO.pageSize,\n      };\n    }\n\n    const orderBy = { document_id: \"desc\" } as const;\n    const dbDocumentList = await this.db.document.findMany({\n      where: query,\n      select: { document_id: true },\n      orderBy,\n      take: paginatedFilteredDTO.limit || 1000,\n      skip: \"skip\" in pagination ? (pagination.skip as number) : 0,\n    });\n\n    const count = dbDocumentList.length + (\"skip\" in pagination ? (pagination.skip as number) : 0);\n\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        document_id: {\n          in: dbDocumentList\n            .slice(0, paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize || 10)\n            .map(({ document_id }) => document_id),\n        },\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy,\n    });\n\n    return { result: dbDocuments.map(DocumentMap.toDomain), count };\n  }\n\n  async save(document: Document) {\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation)\n      throw new DocumentNumberAlreadyExistsError(\n        `A document with number ${document.number} already exists in this location.`\n      );\n\n    if (document.id) {\n      await this.db.document.update({\n        where: {\n          document_id: document.id,\n        },\n        data: DocumentMap.toPersistenceUpdate(document),\n      });\n\n      await this.updateDocumentCSIDivisions(document.id, document.csiDivisionIDs);\n    } else {\n      const createdDocument = await this.db.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n\n      document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    await this.saveAdditionalAreas(document);\n    await this.saveRevisions(document);\n    await this.saveLinks(document);\n    await this.savePrograms(document);\n  }\n\n  async saveAdditionalAreas(document: Document) {\n    if (document.id) {\n      await this.db.document_additional_area.deleteMany({\n        where: {\n          document_id: document.id,\n        },\n      });\n    }\n\n    if (document.additionalAreaIDs && document.additionalAreaIDs.length > 0) {\n      await this.db.document_additional_area.createMany({\n        data: document.additionalAreaIDs.map((areaID) => ({\n          area_id: areaID,\n          document_id: document.id!,\n        })),\n      });\n    }\n  }\n\n  async saveRevisions(document: Document) {\n    let dbStatuses: { creation_ts: Date; revision_status_id: number }[];\n\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        if (revision.id) {\n          const updateDetails = await this.db.document_revision.update({\n            where: {\n              document_revision_id: revision.id,\n            },\n            data: DocRevisionMap.toPersistence(revision),\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = updateDetails.document_revision_status;\n        } else {\n          const createdRevision = await this.db.document_revision.create({\n            data: {\n              document_id: document.id!,\n              ...DocRevisionMap.toPersistence(revision),\n            },\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = createdRevision.document_revision_status;\n\n          revision.setId(createdRevision.document_revision_id);\n        }\n\n        revision.statuses.forEach((status) => {\n          const updateStatusDetails = dbStatuses.find(\n            (updateStatusDetails) => updateStatusDetails.creation_ts.getTime() === status.creationTs.getTime()\n          );\n\n          updateStatusDetails && status.setId(updateStatusDetails.revision_status_id);\n        });\n      })\n    );\n\n    await Promise.all([this.saveLastStatus(document.lastRevision), this.saveLastRevision(document)]);\n  }\n\n  async saveLastRevision(document: Document) {\n    return this.db.document.update({\n      where: {\n        document_id: document.id,\n      },\n      data: {\n        latest_revision_id: document.lastRevision.id,\n      },\n    });\n  }\n\n  async saveLastStatus(revision: DocRevision) {\n    const statuses = await this.db.document_revision_status.findMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      orderBy: {\n        creation_ts: \"asc\",\n      },\n    });\n\n    if (statuses.at(-1)!.is_last && statuses.slice(0, statuses.length - 1).every((status) => !status.is_last)) {\n      return;\n    }\n\n    await this.db.document_revision_status.updateMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      data: {\n        is_last: false,\n      },\n    });\n\n    await this.db.document_revision_status.update({\n      where: {\n        revision_status_id: statuses.at(-1)!.revision_status_id,\n      },\n      data: {\n        is_last: true,\n      },\n    });\n  }\n\n  private async addDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const addedPrograms = document.locationProgramIDs.added;\n\n    if (_.isEmpty(addedPrograms)) return;\n\n    await this.db.document_program.createMany({\n      data: addedPrograms.map((removedLocationProgramID) => ({\n        document_id: document.id,\n        location_program_id: removedLocationProgramID,\n      })),\n    });\n  }\n\n  private async removeDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const removedPrograms = document.locationProgramIDs.removed;\n\n    if (_.isEmpty(removedPrograms)) return;\n\n    await this.db.document_program.deleteMany({\n      where: {\n        OR: removedPrograms.map((removedProgramID) => ({\n          document_id: document.id,\n          location_program_id: removedProgramID,\n        })),\n      },\n    });\n  }\n\n  private async savePrograms(document: PersistedEntity<Document>) {\n    await this.removeDocumentPrograms(document);\n    await this.addDocumentPrograms(document);\n  }\n\n  // TODO: Only run this function when entity has csi divisions updated (keep track of entity changes locally)\n  private async updateDocumentCSIDivisions(document_id: number, csi_division_ids: Collection<number>): Promise<void> {\n    if (!isEmpty(csi_division_ids.removed)) {\n      await this.db.document_csi_division.deleteMany({\n        where: {\n          document_id,\n          csi_division_id: {\n            in: csi_division_ids.removed,\n          },\n        },\n      });\n    }\n  }\n\n  private async saveLinks(document: Document) {\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        await this.updateLinks(revision);\n        await this.removeLinks(revision);\n        await this.addLinks(revision);\n      })\n    );\n  }\n\n  private async updateLinks(revision: DocRevision): Promise<void> {\n    const links = revision.links.filter((link) => link.didChange);\n\n    if (_.isEmpty(links)) return;\n\n    const scopeLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const requestLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Request);\n\n    await Promise.all([\n      ...scopeLinks.map((scopeLink) =>\n        this.db.scope_document_revision.update({\n          where: {\n            id: scopeLink.id,\n          },\n          data: {\n            is_released: scopeLink.isReleased,\n          },\n        })\n      ),\n      ...requestLinks.map((requestLink) =>\n        this.db.request_document_revision.update({\n          where: {\n            id: requestLink.id,\n          },\n          data: {\n            is_released: requestLink.isReleased,\n          },\n        })\n      ),\n    ]);\n  }\n\n  private async addLinks(revision: DocRevision): Promise<void> {\n    const addedLinks = revision.links.added;\n\n    if (_.isEmpty(addedLinks)) return;\n\n    const addedScopes = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const addedRequests = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Request);\n    const addedProjects = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Project);\n\n    await this.db.document_revision.update({\n      where: { document_revision_id: revision.id },\n      data: {\n        scope_document_revision: {\n          createMany: {\n            data: addedScopes.map((addedScope) => ({\n              scope_id: addedScope.parentID,\n              is_released: addedScope.isReleased,\n              created_by: addedScope.createdBy,\n            })),\n          },\n        },\n        request_document_revision: {\n          createMany: {\n            data: addedRequests.map((addedRequest) => ({\n              request_id: addedRequest.parentID,\n              is_released: addedRequest.isReleased,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n        project_document_revision: {\n          createMany: {\n            data: addedProjects.map((addedRequest) => ({\n              project_id: addedRequest.parentID,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n      },\n    });\n  }\n\n  private async removeLinks(revision: DocRevision): Promise<void> {\n    const removedLinks = revision.links.removed;\n\n    if (_.isEmpty(removedLinks)) return;\n\n    const removedScopes = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Scope);\n    const removedRequests = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Request);\n    const removedProjects = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Project);\n\n    if (!_.isEmpty(removedScopes))\n      await this.db.scope_document_revision.deleteMany({\n        where: {\n          OR: removedScopes.map((removedScope) => ({\n            scope_id: removedScope.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedRequests))\n      await this.db.request_document_revision.deleteMany({\n        where: {\n          OR: removedRequests.map((removedRequest) => ({\n            request_id: removedRequest.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedProjects))\n      await this.db.project_document_revision.deleteMany({\n        where: {\n          OR: removedProjects.map((removedProject) => ({\n            project_id: removedProject.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n  }\n\n  async isDocumentNumberUniqueInLocation(document: Document) {\n    const count = await this.db.document.count({\n      where: {\n        document_number: document.number,\n        location_id: document.locationID,\n        ...(document.id ? { document_id: { notIn: [document.id] } } : {}), // Exclude itself\n      },\n    });\n\n    return count === 0;\n  }\n\n  async delete(document: Document): Promise<void> {\n    if (!document.id) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n    assertPersistency(document);\n\n    const { count } = await this.db.document.updateMany({\n      where: {\n        AND: [this.baseQuery, { document_id: document.id }],\n      },\n      data: {\n        is_deleted: 1,\n      },\n    });\n\n    document.locationProgramIDs.removeAll();\n    await this.savePrograms(document);\n\n    if (!count) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n  }\n\n  async getRevisionStatusTypes(): Promise<RevisionStatusType[]> {\n    const dbStatusTypes = await this.db.document_revision_status_type.findMany();\n    return dbStatusTypes.map((dbStatusType) => RevisionStatusType.create(dbStatusType.type as TRevisionStatusType));\n  }\n\n  public getParentSelect(parentEntity: PersistedScope | PersistedRequestInstance | PersistedProject) {\n    if (parentEntity instanceof Scope) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"scope_id\",\n        table_name: \"scope_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof RequestInstance) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"request_id\",\n        table_name: \"request_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof Project) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"project_id\",\n        table_name: \"project_document_revision\",\n      };\n    }\n\n    throw new Error(\"Invalid parent entity\");\n  }\n\n  public async getDocumentsRefData(documentIDs: number[]) {\n    const dbRefDataDocuments = await this.db.document.findMany({\n      where: {\n        document_id: { in: documentIDs },\n      },\n      include: {\n        site: true,\n        building: true,\n        area: true,\n        area_detail: true,\n        document_additional_area: {\n          include: {\n            area: true,\n          },\n        },\n        location_level: true,\n        document_type: true,\n        discipline: true,\n        document_program: { include: { location_program: { include: { program: true } } } },\n        created_by_user: { include: userQueryInclude },\n        updated_by_user: { include: userQueryInclude },\n        created_by_company_full: { include: companyQueryInclude },\n        updated_by_company_full: { include: companyQueryInclude },\n        document_csi_division: { include: { csi_division: { select: { title: true } } } },\n        document_submittal_category: true,\n        document_submittal_type: true,\n        document_submittal_detail: { include: { document_submittal_type: true } },\n      },\n    });\n\n    const refData: ReferencedDocData = {};\n\n    if (dbRefDataDocuments.length === 0) return refData;\n\n    const programs: Record<number, (typeof programsList)[0]> = {};\n\n    const programsList = await this.locationRepo.getProgramsInLocation(dbRefDataDocuments[0].location_id);\n\n    programsList.forEach((locationProgram) => {\n      programs[locationProgram.program.id] = locationProgram;\n    });\n\n    dbRefDataDocuments.forEach((dbRefDataDocument) => {\n      refData[dbRefDataDocument.document_id] = {\n        type: DocumentTypeMap.toDomain(dbRefDataDocument.document_type),\n        discipline: DisciplineMap.toDomain(dbRefDataDocument.discipline),\n        createdBy: UserMap.toDomain(dbRefDataDocument.created_by_user),\n        updatedBy: dbRefDataDocument.updated_by_user ? UserMap.toDomain(dbRefDataDocument.updated_by_user) : null,\n        site: dbRefDataDocument.site ? AreaMap.toDomain(dbRefDataDocument.site) : null, // TODO: ATOM-3197 - Remove NULL when site is mandatory\n        building: AreaMap.toDomain(dbRefDataDocument.building),\n        area: AreaMap.toDomain(dbRefDataDocument.area),\n        areaDetail: dbRefDataDocument.area_detail ? AreaMap.toDomain(dbRefDataDocument.area_detail) : null,\n        additionalAreas: dbRefDataDocument.document_additional_area.map((additional_area) =>\n          AreaMap.toDomain(additional_area.area)\n        ),\n        level: LevelMap.toDomain(dbRefDataDocument.location_level),\n        programs: dbRefDataDocument.document_program.map(({ location_program }) =>\n          LocationProgramMap.toDomain(location_program, ProgramMap.toDomain(location_program.program), {\n            enabled: true,\n          })\n        ),\n        createdByCompany: CompanyMap.toDomain(dbRefDataDocument.created_by_company_full),\n        updatedByCompany: dbRefDataDocument.updated_by_company_full\n          ? CompanyMap.toDomain(dbRefDataDocument.updated_by_company_full)\n          : null,\n        csiDivisions: dbRefDataDocument.document_csi_division.map((csiDivision) =>\n          CSIDivisionMap.toDomain({ division_id: csiDivision.csi_division_id, title: csiDivision.csi_division.title })\n        ),\n        submittal: {\n          category: dbRefDataDocument.document_submittal_category\n            ? DocumentSubmittalCategoryMap.toDomain(dbRefDataDocument.document_submittal_category)\n            : null,\n          type: dbRefDataDocument.document_submittal_type\n            ? DocumentSubmittalTypeMap.toDomain(dbRefDataDocument.document_submittal_type)\n            : null,\n          detail: dbRefDataDocument.document_submittal_detail\n            ? DocumentSubmittalDetailMap.toDomain(dbRefDataDocument.document_submittal_detail)\n            : null,\n        },\n      };\n    });\n\n    return refData;\n  }\n\n  public async getRevisionsRefData(revisionIDs: number[]) {\n    const dbRefDataRevisions = await this.db.document_revision.findMany({\n      where: {\n        document_revision_id: { in: revisionIDs },\n      },\n      include: {\n        file: true,\n        user: { include: userQueryInclude },\n        location_document_purpose: { include: { document_purpose: true } },\n      },\n    });\n\n    const refData: Record<\n      number,\n      {\n        file: File;\n        createdByUser: PersistedEntity<User>;\n        purposeType: LocationDocumentPurpose;\n      }\n    > = {};\n\n    dbRefDataRevisions.forEach((dbRefDataRevision) => {\n      refData[dbRefDataRevision.document_revision_id] = {\n        file: FileMap.toDomain(dbRefDataRevision.file),\n        createdByUser: UserMap.toDomain(dbRefDataRevision.user),\n        purposeType: LocationDocumentPurposeMap.toDomain(\n          dbRefDataRevision.location_document_purpose,\n          DocumentPurposeMap.toDomain(dbRefDataRevision.location_document_purpose.document_purpose),\n          { enabled: true }\n        ),\n      };\n    });\n\n    return refData;\n  }\n\n  private getParentSelectFromIDs({\n    ids,\n    refName,\n    tableName,\n  }: {\n    ids: number[];\n    refName: string;\n    tableName: string;\n  }): Prisma.documentWhereInput {\n    return {\n      document_revision: {\n        some: {\n          [tableName]: {\n            some: {\n              [refName]: { in: ids },\n            },\n          },\n        },\n      },\n    };\n  }\n\n  private async getMaximumSequenceNumberDocument(\n    document: DocumentMetadata,\n    locationID: number,\n    numberingFormat: DocumentNumberingScheme.DocumentNumberingSegment[]\n  ): Promise<Document | undefined> {\n    const filter: any = {};\n\n    for (const segment of numberingFormat) {\n      if (\n        segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER ||\n        segment.fieldKey === DocumentFieldType.Type.FREE_TEXT ||\n        segment.fieldKey === DocumentFieldType.Type.ORIGINATING_ORGANIZATION\n      ) {\n        continue;\n      }\n      if (segment.fieldKey === DocumentFieldType.Type.PURPOSE) {\n        filter[\"document_revision\"] = {\n          some: {\n            location_document_purpose_id: document.locationDocumentPurposeID,\n          },\n        };\n        continue;\n      }\n      const property = typeToProperty[segment.fieldKey as keyof typeof typeToProperty];\n      if (!property) {\n        throw new Error(`Unsupported numbering scheme segment: ${segment}`);\n      }\n      const column = propertyToColumn[property as keyof typeof propertyToColumn] as string;\n      if (!column) {\n        throw new Error(`Unsupported property: ${property}`);\n      }\n      filter[column] = document[property];\n    }\n\n    const sequenceNumberIndex = numberingFormat.findIndex(\n      (segment) => segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER\n    );\n    const documentNumber = document.number.split(\"-\");\n\n    if (documentNumber[sequenceNumberIndex] === DocumentFieldType.Type.SEQUENCE_NUMBER) {\n      documentNumber[sequenceNumberIndex] = \"%\";\n    }\n\n    const numberingSchemeMatchCondition = {\n      document_number: {\n        contains: documentNumber.join(\"-\"),\n      },\n    };\n\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          filter,\n          numberingSchemeMatchCondition,\n          { location_id: locationID },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy: {\n        sequence_number: \"desc\",\n      },\n    });\n\n    if (!dbDocument) {\n      return undefined;\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getNextSequenceNumber(\n    document: DocumentMetadata,\n    locationID: number,\n    format: DocumentNumberingScheme.DocumentNumberingSegment[],\n    sequenceNumberStart: number\n  ): Promise<number> {\n    const matchingDocument = await this.getMaximumSequenceNumberDocument(document, locationID, format);\n    if (!matchingDocument) {\n      return sequenceNumberStart;\n    }\n    const maxSequenceNumber = matchingDocument.sequenceNumber ?? 0;\n    return Math.max(maxSequenceNumber + 1, sequenceNumberStart);\n  }\n}\n```\n\nthis is the save rvisions \nLooking at the `saveRevisions` method, I can see where the foreign key violation might be occurring. The issue appears to be in the order of operations and possibly missing associations when creating new revisions.\n\nHere's an improved version of the `saveRevisions` method that should handle the foreign key constraints properly:\n\n```typescript\nasync saveRevisions(document: Document) {\n  // Ensure document has an ID before saving revisions\n  if (!document.id) {\n    throw new Error(\"Document must have an ID before saving revisions\");\n  }\n\n  await Promise.all(\n    document.revisions.map(async (revision) => {\n      let dbStatuses: { creation_ts: Date; revision_status_id: number }[];\n\n      try {\n        if (revision.id) {\n          // Update existing revision\n          const updateDetails = await this.db.document_revision.update({\n            where: {\n              document_revision_id: revision.id,\n            },\n            data: {\n              ...DocRevisionMap.toPersistence(revision),\n              document_id: document.id!, // Ensure document_id is set\n            },\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = updateDetails.document_revision_status;\n        } else {\n          // Create new revision with all required associations\n          const revisionData = DocRevisionMap.toPersistence(revision);\n          const createdRevision = await this.db.document_revision.create({\n            data: {\n              document_id: document.id,\n              ...revisionData,\n              // Ensure all required foreign key relationships are included\n              document_revision_status: {\n                create: revision.statuses.map(status => ({\n                  // Map status data appropriately\n                  creation_ts: status.creationTs,\n                  // Include other required status fields\n                }))\n              }\n            },\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = createdRevision.document_revision_status;\n          revision.setId(createdRevision.document_revision_id);\n        }\n\n        // Update status IDs\n        revision.statuses.forEach((status) => {\n          const matchingStatus = dbStatuses.find(\n            (dbStatus) => dbStatus.creation_ts.getTime() === status.creationTs.getTime()\n          );\n\n          if (matchingStatus) {\n            status.setId(matchingStatus.revision_status_id);\n          }\n        });\n\n      } catch (error) {\n        console.error('Error saving revision:', error);\n        throw error;\n      }\n    })\n  );\n\n  // Update last status and revision after all revisions are saved\n  await Promise.all([\n    this.saveLastStatus(document.lastRevision),\n    this.saveLastRevision(document)\n  ]);\n}\n```\n\nKey improvements:\n\n1. Added document ID validation\n2. Improved error handling with try/catch\n3. Ensure all required foreign key relationships are included when creating new revisions\n4. Made sure document_id is explicitly set for both updates and creates\n5. Handle status creation as part of the revision creation transaction\n\nThe foreign key violation likely occurs because:\n1. Either the document_id is not properly set when creating new revisions\n2. Or required relationships (like status records) aren't being created in the correct order\n\nI would also recommend checking:\n\n1. The DocRevisionMap.toPersistence method to ensure it includes all required fields\n2. The database schema to verify foreign key constraints\n3. The status creation flow to ensure all required fields are populated\n\nCan you share the error stack trace or the specific foreign key constraint that's being violated? That would help pinpoint the exact issue.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":178}}},{"id":{"replica_id":0,"value":21},"start":2369,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":179}}},{"id":{"replica_id":0,"value":22},"start":4459,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":180}}},{"id":{"replica_id":0,"value":95},"start":37480,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":181}}},{"id":{"replica_id":0,"value":96},"start":41260,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":182}}}],"summary":"Document Request Approval Test Failure","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":2324},"icon":"Terminal","label":"Terminal","metadata":null},{"range":{"start":4459,"end":37452},"icon":"File","label":"atom-web/src/server/new-structure/application/repositories/document.repo.ts","metadata":{"path":"atom-web/src/server/new-structure/application/repositories/document.repo.ts"}}],"thought_process_output_sections":[]}