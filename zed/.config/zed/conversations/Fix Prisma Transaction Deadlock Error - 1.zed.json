{"id":"ebad966d-b9d5-4b1e-ac1f-da672498f4f5","zed":"context","version":"0.4.0","text":"\n\n\n```ts atom-web/src/server/new-structure/application/use-cases/tasks/list-groups/system.test.ts\nimport { Document, Review, Stakeholder, User } from \"@atom/types\";\nimport { XOR } from \"ts-essentials\";\n\nimport _ from \"lodash\";\nimport { createTemplate, Template } from \"../../../../../scope/scope.test.utils\";\nimport { DocumentMock } from \"../../../../../test/mocks/types/document\";\nimport { FileMock } from \"../../../../../test/mocks/types/file\";\nimport { ReqCreateProjectMock } from \"../../../../../test/mocks/types/project\";\nimport { ReqCreateScopeMock } from \"../../../../../test/mocks/types/scope\";\nimport { Api } from \"../../../../../test/system/api\";\nimport { setupTestContext, teardownTestContext, TestContext } from \"../../../../../test/system/context/test.context\";\nimport { createReviewFlowTemplate } from \"../../../../../test/utils/document/test.utils\";\nimport { TaskType } from \"../../../../domain/task/task.types\";\nimport { ReqCreateRequestInstanceMock } from \"../../request/instance/test/test.utils\";\nimport { createActiveRequestType, ReqCreateRequestTypeMock } from \"../../request/type/test/test.utils\";\n\ndescribe(\"List Task Groups\", () => {\n  let ctx: TestContext;\n  let scopeID: number;\n  let scopeReviewTemplateID: number;\n  let projectID: number;\n  let requestTypeWithReviewID: number;\n  let requestTypeWithoutReviewID: number;\n  let userIDs: User.ID[] = [];\n  let documentIDs: number[] = [];\n  let fileIDs: string[] = [];\n  let reviewFlowTemplateIDs: number[] = [];\n  const requestIDs: number[] = [];\n\n  const createDocument = async ({\n    parent,\n    disciplineID,\n  }: {\n    parent?: XOR<{ scopeID: number }, { requestID: number }, { projectID: number }>;\n    disciplineID?: number;\n  }) => {\n    const fileID = (await db.file.create(FileMock({ created_by: ctx.admin_id }))).file_id;\n    let documentCreationResult: Document.ResCreateDocuments;\n\n    if (!parent) {\n      documentCreationResult = await ctx.admin.documents.createDocuments(ctx.location_id, {\n        documents: [DocumentMock({ ctx, fileID, disciplineID })],\n      });\n    } else if (\"scopeID\" in parent && parent.scopeID) {\n      documentCreationResult = await ctx.admin.scopeDocument.createDocuments(parent.scopeID, {\n        documents: [DocumentMock({ ctx, fileID, disciplineID })],\n      });\n    } else if (\"requestID\" in parent && parent.requestID) {\n      documentCreationResult = await ctx.admin.requestDocument.createDocuments(ctx.location_id, parent.requestID, {\n        documents: [DocumentMock({ ctx, fileID, disciplineID })],\n      });\n    } else if (\"projectID\" in parent && parent.projectID) {\n      documentCreationResult = await ctx.admin.projectDocument.createDocuments({\n        locationID: ctx.location_id,\n        projectID: parent.projectID,\n        documents: [DocumentMock({ ctx, fileID, disciplineID })],\n      });\n    }\n\n    const documentID = (documentCreationResult!.documents.at(0) as { id: number }).id;\n\n    fileIDs.push(fileID);\n    documentIDs.push(documentID);\n\n    return documentID;\n  };\n\n  const createAndSubmitDocument = async ({\n    reviewFlowTemplateID,\n    parent,\n    disciplineID,\n  }: {\n    reviewFlowTemplateID: number;\n    parent?: XOR<{ scopeID: number }, { requestID: number }, { projectID: number }>;\n    disciplineID?: number;\n  }) => {\n    const documentID = await createDocument({\n      parent,\n      disciplineID,\n    });\n\n    const document = await ctx.admin.documents.getDocument(ctx.location_id, documentID);\n    const revisionID = document.revision.id;\n\n    await ctx.admin.documents.requestApproval(ctx.location_id, {\n      revisionIDs: [revisionID],\n      reviewFlowTemplateID,\n    });\n\n    return documentID;\n  };\n\n  const createRequest = async ({\n    parent,\n    requestTypeID,\n  }: {\n    parent?: XOR<{ scopeID: number }, { projectID: number }>;\n    requestTypeID: number;\n  }) => {\n    const { form } = await ctx.admin.requestInstance.getForm(requestTypeID, {});\n\n    const { scopeID, projectID } = parent || {};\n\n    const request = await ctx.admin.requestInstance.createRequestInstance(\n      ReqCreateRequestInstanceMock(\n        {\n          requestTypeID,\n          form,\n          area_id: ctx.area_id,\n          discipline_id: ctx.discipline_id,\n        },\n        {\n          formValues: {\n            title: \"Project Request\",\n            project: projectID ? [projectID] : undefined,\n            scope: scopeID ? [scopeID] : undefined,\n          },\n        }\n      )\n    );\n\n    requestIDs.push(request.requestID);\n  };\n\n  beforeAll(async () => {\n    ctx = await setupTestContext();\n\n    const project = await ctx.admin.project.create(\n      ReqCreateProjectMock({\n        location_id: ctx.location_id,\n        title: \"Project\",\n        stakeholders: [\n          { user_id: ctx.user_id, stakeholder_type_id: Stakeholder.Type.Buyer },\n          { user_id: ctx.admin_id, stakeholder_type_id: Stakeholder.Type.TeslaResponsiblePerson },\n        ],\n      })\n    );\n\n    projectID = project.project_id;\n\n    const templateInput = Template({ steps: [{ groups: [{ reviewers: [ctx.user_id] }] }] });\n    const template = await createTemplate(ctx, templateInput);\n    scopeReviewTemplateID = template.id;\n    const scope = await ctx.admin.scope.create(\n      ReqCreateScopeMock({\n        title: \"Scope\",\n        location_id: ctx.location_id,\n        area_id: ctx.area_id,\n        discipline_ids: [ctx.discipline_id],\n        review_template_id: template.id,\n        selected_reviewer_ids: template.reviewers_ids,\n        scope_stakeholder: {\n          users: [\n            { user_id: ctx.admin_id, type: \"tesla_responsible_person\" },\n            { user_id: ctx.user_id, type: \"buyer\" },\n          ],\n        },\n        project_id: projectID,\n      })\n    );\n\n    scopeID = scope.scope_id;\n\n    requestTypeWithReviewID = await createActiveRequestType(\n      ctx,\n      ReqCreateRequestTypeMock(ctx, {\n        recipients: {\n          areaManager: true,\n          teslaResponsiblePerson: true,\n          customUsers: [{ id: ctx.admin_id }],\n        },\n        canBeCreatedIn: {\n          scope: true,\n          project: true,\n          document: false,\n          location: true,\n        },\n        review: {\n          isRequired: true,\n          autoReviewSubmit: true,\n          template: {\n            withTeamManagerFallback: false,\n            steps: [\n              {\n                groups: [\n                  {\n                    type: Review.GroupType.USER_LIST,\n                    reviewers: [\n                      {\n                        userID: ctx.admin_id,\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n        },\n      })\n    );\n\n    requestTypeWithoutReviewID = await createActiveRequestType(\n      ctx,\n      ReqCreateRequestTypeMock(ctx, {\n        recipients: {\n          areaManager: true,\n          teslaResponsiblePerson: true,\n          customUsers: [{ id: ctx.admin_id }],\n        },\n        canBeCreatedIn: {\n          scope: true,\n          project: true,\n          document: false,\n          location: true,\n        },\n        review: {\n          isRequired: false,\n        },\n      })\n    );\n  });\n\n  afterAll(async () => {\n    await db.requestInstance.delete(requestIDs);\n    await db.requestType.delete(requestTypeWithReviewID);\n    await db.requestType.delete(requestTypeWithoutReviewID);\n    await db.scope.delete(scopeID);\n    await db.scope_review_template.delete(scopeReviewTemplateID);\n    await db.project.delete(projectID);\n\n    await teardownTestContext(ctx);\n  });\n\n  afterEach(async () => {\n    await db.document.deleteMany(documentIDs);\n    await db.file.delete(fileIDs);\n    await db.review_template.delete(reviewFlowTemplateIDs);\n    await db.user.deleteMany(userIDs);\n\n    documentIDs = [];\n    fileIDs = [];\n    reviewFlowTemplateIDs = [];\n    userIDs = [];\n  });\n\n  it(\"groups the reviews by parent\", async () => {\n    const reviewFlowTemplateID = await createReviewFlowTemplate(ctx);\n    reviewFlowTemplateIDs.push(reviewFlowTemplateID);\n\n    await createAndSubmitDocument({ reviewFlowTemplateID });\n    await createAndSubmitDocument({ reviewFlowTemplateID });\n    await createAndSubmitDocument({ reviewFlowTemplateID });\n    await createAndSubmitDocument({ reviewFlowTemplateID, parent: { scopeID } });\n    await createAndSubmitDocument({ reviewFlowTemplateID, parent: { projectID } });\n    await createAndSubmitDocument({ reviewFlowTemplateID, parent: { projectID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID });\n    await createRequest({ requestTypeID: requestTypeWithReviewID });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { scopeID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { scopeID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { projectID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { projectID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { projectID } });\n\n    const { groups } = await ctx.admin.task.listGroups({ locationID: ctx.location_id });\n\n    expect(groups).toHaveLength(10);\n\n    const locationContainer = groups.find((a) => a.container.type === \"location\");\n    const scopeContainer = groups.find((a) => a.container.type === \"scope\");\n    const projectContainer = groups.find((a) => a.container.type === \"project\");\n    const requestContainers = groups.filter((a) => a.container.type === \"request\");\n\n    expect(locationContainer?.taskCount).toBe(3);\n    expect(scopeContainer?.taskCount).toBe(1);\n    expect(projectContainer?.taskCount).toBe(2);\n    expect(requestContainers.length).toBe(7);\n    expect(_.uniq(requestContainers.map((requestContainer) => requestContainer.taskCount))).toEqual([1]);\n  });\n\n  it(\"shows only the requesting user's tasks\", async () => {\n    const reviewFlowTemplateID = await createReviewFlowTemplate(ctx);\n    reviewFlowTemplateIDs.push(reviewFlowTemplateID);\n\n    await createAndSubmitDocument({ reviewFlowTemplateID });\n    await createAndSubmitDocument({ reviewFlowTemplateID });\n    await createAndSubmitDocument({ reviewFlowTemplateID });\n    await createAndSubmitDocument({ reviewFlowTemplateID, parent: { scopeID } });\n    await createAndSubmitDocument({ reviewFlowTemplateID, parent: { projectID } });\n    await createAndSubmitDocument({ reviewFlowTemplateID, parent: { projectID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID });\n    await createRequest({ requestTypeID: requestTypeWithReviewID });\n\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { scopeID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { scopeID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { projectID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { projectID } });\n    await createRequest({ requestTypeID: requestTypeWithReviewID, parent: { projectID } });\n\n    const { groups } = await ctx.user.task.listGroups({ locationID: ctx.location_id });\n\n    expect(groups).toHaveLength(0);\n  });\n\n  it(\"groups unreviewed documents for a scope stakeholder\", async () => {\n    await createDocument({});\n    await createDocument({});\n    await createDocument({});\n    await createDocument({ parent: { scopeID } });\n    await createDocument({ parent: { projectID } });\n    await createDocument({ parent: { projectID } });\n\n    const { groups } = await ctx.admin.task.listGroups({ locationID: ctx.location_id });\n\n    expect(groups.filter((a) => a.type === TaskType.REQUEST_APPROVAL_DOCUMENT)).toHaveLength(1);\n\n    const locationContainer = groups.find(\n      (a) => a.container.type === \"location\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n    const scopeContainer = groups.find(\n      (a) => a.container.type === \"scope\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n    const projectContainer = groups.find(\n      (a) => a.container.type === \"project\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n    const requestContainers = groups.find(\n      (a) => a.container.type === \"request\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n    expect(scopeContainer?.taskCount).toBe(1);\n\n    // No other groups as the admin user is not doc control for the location\n    expect(locationContainer).toBeUndefined();\n    expect(projectContainer).toBeUndefined();\n    expect(requestContainers).toBeUndefined();\n  });\n\n  it(\"groups unreviewed documents for doc control\", async () => {\n    const docControlID = (\n      await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { roles: [\"Document Control\"], location_id: ctx.location_id }\n      )\n    ).user_id;\n\n    const docControl = new Api(await login(docControlID));\n\n    await createDocument({});\n    await createDocument({});\n    await createDocument({});\n    await createDocument({ parent: { scopeID } });\n    await createDocument({ parent: { projectID } });\n    await createDocument({ parent: { projectID } });\n\n    const { groups } = await docControl.task.listGroups({ locationID: ctx.location_id });\n\n    expect(groups).toHaveLength(2);\n\n    const locationContainer = groups.find(\n      (a) => a.container.type === \"location\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n    const scopeContainer = groups.find(\n      (a) => a.container.type === \"scope\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n    const projectContainer = groups.find(\n      (a) => a.container.type === \"project\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n    const requestContainers = groups.find(\n      (a) => a.container.type === \"request\" && a.type === TaskType.REQUEST_APPROVAL_DOCUMENT\n    );\n\n    // No groups from scope as this user is not a scope stakeholder\n    expect(scopeContainer).toBeUndefined();\n\n    expect(locationContainer?.taskCount).toBe(3);\n    expect(projectContainer?.taskCount).toBe(2);\n    expect(requestContainers).toBeUndefined();\n\n    userIDs.push(docControlID);\n  });\n\n  it(\"groups unresponded request for recipients\", async () => {\n    await createRequest({\n      requestTypeID: requestTypeWithoutReviewID,\n    });\n    await createRequest({\n      requestTypeID: requestTypeWithoutReviewID,\n      parent: { scopeID },\n    });\n    await createRequest({\n      requestTypeID: requestTypeWithoutReviewID,\n      parent: { scopeID },\n    });\n    await createRequest({\n      requestTypeID: requestTypeWithoutReviewID,\n      parent: { projectID },\n    });\n\n    const { groups } = await ctx.admin.task.listGroups({ locationID: ctx.location_id });\n    const unrespondedRequestsGroups = groups.filter((a) => a.type === TaskType.RESPOND_REQUEST);\n\n    expect(unrespondedRequestsGroups).toHaveLength(4);\n    expect(unrespondedRequestsGroups.every((a) => a.container.type === \"request\")).toBeTrue();\n  });\n});\n```\n\ni have this test, when i run it in the cicd, it fails with the error: FAIL src/server/new-structure/application/use-cases/tasks/list-groups/system.test.ts (35.316 s)\n  ● List Task Groups › groups the reviews by parent\n\n    PrismaClientKnownRequestError: \n    Invalid `prisma.document_revision.deleteMany()` invocation:\n\n\n    Transaction failed due to a write conflict or a deadlock. Please retry your transaction\n\n       9 |   }\n      10 |\n    > 11 |   delete = async (documentID: number): Promise<void> => {\n         |             ^\n      12 |     await this.db.document_revision.deleteMany({ where: { document_id: documentID } });\n      13 |     await this.db.document.delete({ where: { document_id: documentID } });\n      14 |   };\n\n      at $n.handleRequestError (../../node_modules/@prisma/client/runtime/library.js:121:7315)\n      at $n.handleAndLogRequestError (../../node_modules/@prisma/client/runtime/library.js:121:6623)\n      at $n.request (../../node_modules/@prisma/client/runtime/library.js:121:6307)\n      at l (../../node_modules/@prisma/client/runtime/library.js:130:9633)\n      at DocumentDatabase.deleteMany (test/system/database/document.ts:11:13)\n      at Object.<anonymous> (new-structure/application/use-cases/tasks/list-groups/system.test.ts:235:5)\nhelp me fix this \nThis error occurs due to a transaction deadlock when trying to delete document records. To fix this, you can try a few approaches:\n\n1. Add retries for the delete operation:\n\n```typescript\n// Create a utility function for retrying operations\nconst retryOperation = async (operation: () => Promise<any>, maxRetries = 3, delay = 1000) => {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return await operation();\n    } catch (error) {\n      if (i === maxRetries - 1) throw error;\n      if (error?.message?.includes('deadlock')) {\n        await new Promise(resolve => setTimeout(resolve, delay));\n        continue;\n      }\n      throw error;\n    }\n  }\n};\n\n// Modify the afterEach block to use retries\nafterEach(async () => {\n  await retryOperation(async () => {\n    await db.document.deleteMany(documentIDs);\n    await db.file.delete(fileIDs);\n    await db.review_template.delete(reviewFlowTemplateIDs);\n    await db.user.deleteMany(userIDs);\n\n    documentIDs = [];\n    fileIDs = [];\n    reviewFlowTemplateIDs = [];\n    userIDs = [];\n  });\n});\n```\n\n2. Sequential deletion instead of bulk deletion:\n\n```typescript\nafterEach(async () => {\n  // Delete documents one by one\n  for (const documentID of documentIDs) {\n    await db.document.delete({ where: { document_id: documentID } });\n  }\n  \n  for (const fileID of fileIDs) {\n    await db.file.delete({ where: { file_id: fileID } });\n  }\n  \n  for (const templateID of reviewFlowTemplateIDs) {\n    await db.review_template.delete({ where: { id: templateID } });\n  }\n  \n  await db.user.deleteMany(userIDs);\n\n  documentIDs = [];\n  fileIDs = [];\n  reviewFlowTemplateIDs = [];\n  userIDs = [];\n});\n```\n\n3. Add proper ordering to avoid deadlocks:\n\n```typescript\nafterEach(async () => {\n  // Delete in specific order to avoid conflicts\n  await db.document_revision.deleteMany({\n    where: { document_id: { in: documentIDs } }\n  });\n  \n  await db.document.deleteMany({\n    where: { document_id: { in: documentIDs } }\n  });\n  \n  await db.file.deleteMany({\n    where: { file_id: { in: fileIDs } }\n  });\n  \n  await db.review_template.deleteMany({\n    where: { id: { in: reviewFlowTemplateIDs } }\n  });\n  \n  await db.user.deleteMany({\n    where: { user_id: { in: userIDs } }\n  });\n\n  documentIDs = [];\n  fileIDs = [];\n  reviewFlowTemplateIDs = [];\n  userIDs = [];\n});\n```\n\nI recommend trying option 1 (retries) first, as it's the most robust solution for handling deadlocks. If that doesn't resolve the issue, you can try option 3 (ordered deletion) or a combination of both approaches.\n\nAlso, make sure that your database configuration has appropriate timeout and deadlock detection settings. You might want to review your database's deadlock_timeout and lock_timeout settings if the issues persist.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":100}}},{"id":{"replica_id":0,"value":35},"start":16193,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":103}}},{"id":{"replica_id":0,"value":36},"start":18934,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":102}}}],"summary":"Fix Prisma Transaction Deadlock Error","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":14896},"icon":"File","label":"atom-web/src/server/new-structure/application/use-cases/tasks/list-groups/system.test.ts","metadata":{"path":"atom-web/src/server/new-structure/application/use-cases/tasks/list-groups/system.test.ts"}}],"thought_process_output_sections":[]}