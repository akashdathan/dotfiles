{"id":"aba09382-2408-470a-a478-1249a188f361","zed":"context","version":"0.4.0","text":"\n\n\n```tsx atom-web/src/browser/providers/AuthProvider.tsx\n/**\n * This provider manages the authentication state of the application\n */\nimport { Session } from \"@atom/types\";\nimport { createPrismaAbility } from \"@casl/prisma\";\nimport { useAbility as caslUseAbility, createContextualCan } from \"@casl/react\";\nimport { useQuery } from \"@tanstack/react-query\";\nimport React, { useEffect } from \"react\";\nimport * as Sentry from \"@sentry/react\";\nimport { PlatformUnauthorized } from \"~/components/shared/Error/component\";\nimport { Loader } from \"~/components/shared/ui/loader\";\nimport { usersAPI } from \"../api\";\n\nexport type Ability = ReturnType<typeof createPrismaAbility>;\n\nexport interface AuthStateContextType {\n  isAuthenticated: boolean;\n  isAuthorized: boolean;\n  user: Session.AuthUserRes[\"user\"] | null;\n  ability: Ability;\n}\n\nconst initialState: AuthStateContextType = {\n  isAuthenticated: false,\n  isAuthorized: false,\n  user: null,\n  ability: createPrismaAbility([]),\n};\n\nconst ENDPOINT_AUTH_LOGIN = \"/auth/login\";\nconst ENDPOINT_AUTH_LOGOUT = \"/auth/logout\";\n\nexport const AuthStateContext = React.createContext<AuthStateContextType>(initialState);\n\nexport const AbilityContext = React.createContext(createPrismaAbility([]));\nexport const Can = createContextualCan(AbilityContext.Consumer);\n\nexport const useAbility = () => {\n  return caslUseAbility(AbilityContext);\n};\n\nlet csrfToken: string = \"\";\n\nexport function getAccessToken() {\n  return localStorage.getItem(\"access_token\") ?? \"\";\n}\n\nexport function getCSRFToken() {\n  return csrfToken;\n}\n\nfunction reducer(state: AuthStateContextType, action: { payload: Partial<AuthStateContextType> }) {\n  return { ...state, ...action.payload };\n}\n\nfunction AuthStateProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = React.useReducer(reducer, initialState);\n  const userAuthQuery = useQuery({\n    queryKey: [\"auth\", \"user\"],\n    queryFn: usersAPI.getUserAuth,\n    keepPreviousData: true,\n  });\n\n  // handle successful login\n  useEffect(() => {\n    const url = new URL(window.location.href);\n    const _accessToken = url.searchParams.get(\"access_token\");\n\n    if (_accessToken) {\n      url.searchParams.delete(\"access_token\");\n      window.history.replaceState(window.history.state, document.title, url.toString());\n      localStorage.setItem(\"access_token\", _accessToken);\n    }\n  }, []);\n\n  useEffect(() => {\n    if (userAuthQuery.data) {\n      checkUserAuth(userAuthQuery.data);\n    }\n  }, [userAuthQuery.data]);\n\n  const checkUserAuth = (response: Session.AuthUserRes) => {\n    if (response.isAuthenticated) {\n      state.ability.update(response.user?.permissionRules ?? []);\n      Sentry.setUser({\n        id: response.user?.userID,\n        username: response.user?.name,\n        type: response.user?.isInternal ? \"internal\" : \"external\",\n      });\n\n      csrfToken = response.csrfToken ?? \"\";\n\n      return dispatch({\n        payload: {\n          isAuthenticated: true,\n          isAuthorized: !!response.user?.isAuthorized,\n          user: response.user,\n        },\n      });\n    } else {\n      redirectToLogin();\n    }\n  };\n\n  return (\n    <AuthStateContext.Provider value={state}>\n      <AbilityContext.Provider value={state.ability}>\n        <>\n          <Loader show={userAuthQuery.isLoading} />\n          {state.isAuthenticated && (state.isAuthorized ? children : <PlatformUnauthorized />)}\n        </>\n      </AbilityContext.Provider>\n    </AuthStateContext.Provider>\n  );\n}\n\nexport function logout() {\n  window.location.href = ENDPOINT_AUTH_LOGOUT;\n}\n\nexport function redirectToLogin() {\n  window.location.replace(`${ENDPOINT_AUTH_LOGIN}?redirect_url=${encodeURIComponent(window.location.href)}`);\n}\n\nfunction useAuthState() {\n  const context = React.useContext(AuthStateContext);\n  if (context === undefined) {\n    throw new Error(\"useAuthState must be used within an AuthProvider\");\n  }\n  return context;\n}\n\nfunction useUserLocale() {\n  const { user } = useAuthState();\n\n  return user?.locale ?? \"en-US\";\n}\n\nfunction useUser() {\n  const { user } = useAuthState();\n\n  return user!;\n}\n\nexport { AuthStateProvider, useAuthState, useUser, useUserLocale };\n```\n\nhere if its unauthorized, the children are not shown, create a list of urls whch can be shown when the user is unauthoruzed\nBased on the provided code, the `AuthStateProvider` is designed to show the `PlatformUnauthorized` component instead of the regular children when the user is authenticated but not authorized (`isAuthenticated && !isAuthorized`). If a user is not even authenticated, they are redirected to the login page.\n\nTo modify this behavior and allow certain URLs to be shown even when the user is unauthorized, I would create a list of public URLs that should bypass this authorization check. Here's how you could implement it:\n\n```typescript\n// List of paths that should be accessible even when the user is unauthorized\nconst PUBLIC_PATHS = [\n  '/help',\n  '/support',\n  '/faq',\n  '/documentation',\n  '/contact',\n  '/terms-of-service',\n  '/privacy-policy',\n  '/about',\n  '/status',\n  '/maintenance',\n  '/public-dashboard',\n  '/legal'\n];\n\n// Function to check if the current path should bypass authorization checks\nfunction isPublicPath(path: string): boolean {\n  return PUBLIC_PATHS.some(publicPath => path === publicPath || path.startsWith(`${publicPath}/`));\n}\n```\n\nThen you would modify the render logic in the `AuthStateProvider` to check if the current path is in the public paths list:\n\n```tsx\nreturn (\n  <AuthStateContext.Provider value={state}>\n    <AbilityContext.Provider value={state.ability}>\n      <>\n        <Loader show={userAuthQuery.isLoading} />\n        {state.isAuthenticated && (\n          state.isAuthorized || isPublicPath(window.location.pathname) ? \n          children : \n          <PlatformUnauthorized />\n        )}\n      </>\n    </AbilityContext.Provider>\n  </AuthStateContext.Provider>\n);\n```\n\nThis implementation allows specific paths to be shown even if the user is unauthorized, while still requiring authentication for all routes.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":70}}},{"id":{"replica_id":0,"value":32},"start":4281,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":71}}},{"id":{"replica_id":0,"value":33},"start":6034,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":72}}}],"summary":"Auth bypass whitelist for URLs","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":4156},"icon":"File","label":"atom-web/src/browser/providers/AuthProvider.tsx","metadata":{"path":"atom-web/src/browser/providers/AuthProvider.tsx"}}]}