{"id":"ed8588ed-9f8a-40f6-97a1-dac0fa371378","zed":"context","version":"0.4.0","text":"\n\n\n```ts atom-web/src/browser/components/capital-cost/queries.ts\nimport { useMutation, useQuery, UseQueryOptions, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"react-hot-toast\";\nimport { produce, Draft } from \"immer\";\nimport isNil from \"lodash/isNil\";\n\nimport { queryClient } from \"../../providers/NetworkProvider\";\nimport * as API from \"../../api\";\n\nimport {\n  CostEstimate,\n  CostProject,\n  CostProjectRefData,\n  CostProjectSubprojects,\n  CostSubproject,\n  CostSubprojectEstimates,\n  CostSubprojectRefData,\n  CSICostElementsRefData,\n  FundingRequest,\n  FundingRequestSubmission,\n  PendingApprovalFundingRequest,\n  ID,\n  CostScope,\n  CostLineItem,\n  CostProjectsFundingRequest,\n} from \"../../api/types\";\nimport { WritableDraft } from \"immer/dist/internal\";\n\ninterface SubprojectInput {\n  projectID: ID;\n  subprojectID: ID;\n}\n\ninterface FundingRequestInput {\n  projectID: ID;\n  fundingRequestID: ID;\n}\n\ninterface EstimateInput extends SubprojectInput {\n  costEstimateID: ID;\n}\n\ninterface ScopeInput extends EstimateInput {\n  scopeID: ID;\n}\n\ninterface VisibilityInput extends EstimateInput {\n  isPublic: boolean;\n}\n\ninterface LineItemInput extends ScopeInput {\n  lineItemID: ID;\n}\n\ninterface GetProjectsInput {\n  page: number;\n  pageSize: number;\n  filters: { name?: string; location_id: number };\n  sortBy?: string;\n  sortOrder?: string;\n}\n\nexport const queryKey = {\n  projects: (locationID: number, filters?: GetProjectsInput) => {\n    const key: Array<string | GetProjectsInput> = [String(locationID), \"cost\", \"project\"];\n\n    if (filters) {\n      key.push(filters);\n    }\n\n    return key;\n  },\n  mySubprojects: (locationID: number) => [String(locationID), \"cost\", \"mySubprojects\"],\n  project: (projectID: ID) => [\"cost\", \"project\", String(projectID)],\n  projectRefData: () => [\"cost\", \"projectRefData\"],\n  subprojects: (projectID: ID) => [\"cost\", \"project\", String(projectID), \"subproject\"],\n  subproject: ({ projectID, subprojectID }: SubprojectInput) => [\n    \"cost\",\n    \"project\",\n    String(projectID),\n    \"subproject\",\n    String(subprojectID),\n  ],\n  fundingRequestSubmission: (projectID: ID) => [\"cost\", \"project\", String(projectID), \"funding-request-submission\"],\n  fundingRequestsByProject: (projectID: ID) => [\"cost\", \"project\", String(projectID), \"funding-requests\"],\n  fundingRequest: ({ projectID, fundingRequestID }: FundingRequestInput) => [\n    \"cost\",\n    \"project\",\n    String(projectID),\n    \"funding-requests\",\n    String(fundingRequestID),\n  ],\n  pendingApprovals: (locationID: number) => [String(locationID), \"cost\", \"pending-aprovals\"],\n\n  subprojectRefData: (projectID: ID) => [\"cost\", \"project\", String(projectID), \"subprojectRefData\"],\n\n  estimates: ({ projectID, subprojectID }: SubprojectInput) => [\n    \"cost\",\n    \"project\",\n    String(projectID),\n    \"subproject\",\n    String(subprojectID),\n    \"estimates\",\n  ],\n\n  estimate: ({ projectID, subprojectID, costEstimateID }: EstimateInput) => [\n    \"cost\",\n    \"project\",\n    String(projectID),\n    \"subproject\",\n    String(subprojectID),\n    \"estimate\",\n    String(costEstimateID),\n  ],\n\n  estimateRefData: () => [\"cost\", \"estimate\", \"ref-data\"],\n\n  csiCostElements: (divisionIDs: ID[]) => [\n    \"cost\",\n    \"estimate\",\n    \"csi-cost-elements\",\n    ...[...divisionIDs].sort().map(String),\n  ],\n\n  laborRates: (locationID: number) => [\"cost\", \"labor-rates\", String(locationID)],\n  laborRatesRefData: (locationID: number) => [\"cost\", \"labor-rates-ref-data\", String(locationID)],\n  laborRatesHistory: ({ locationID, disciplineID }: { locationID?: number; disciplineID?: number }) => [\n    \"cost\",\n    \"labor-rates-history-location\",\n    String(locationID),\n    \"labor-rates-history-discipline\",\n    String(disciplineID),\n  ],\n};\n\nexport const useCostProjects = (input: GetProjectsInput, options?: { enabled: boolean }) => {\n  const { page, pageSize, filters, sortBy, sortOrder } = input;\n  const offset = (page - 1) * pageSize;\n\n  return useQuery({\n    queryFn: () =>\n      API.getCostProjects({\n        take: pageSize,\n        skip: offset,\n        sortBy,\n        sortOrder,\n        ...filters,\n      }),\n    queryKey: queryKey.projects(filters.location_id, input),\n    keepPreviousData: true,\n    enabled: options?.enabled ?? true,\n  });\n};\n\nexport const useMyCostSubprojects = (locationID: number) =>\n  useQuery({\n    queryKey: queryKey.mySubprojects(locationID),\n    queryFn: () => API.getMyCostSubprojects(locationID),\n  });\n\nexport const useCostProject = (projectID: ID, options: Omit<UseQueryOptions<CostProject>, \"queryFn\"> = {}) =>\n  useQuery({\n    queryKey: queryKey.project(projectID),\n    queryFn: () => API.getCostProject(projectID),\n    ...options,\n  });\n\nexport const useCostProjectRefData = (options: Omit<UseQueryOptions<CostProjectRefData>, \"queryFn\"> = {}) =>\n  useQuery({\n    queryKey: queryKey.projectRefData(),\n    queryFn: () => API.getProjectRefData(),\n    ...options,\n  });\n\nexport const useCostSubprojects = (\n  projectID: ID,\n  options: Omit<UseQueryOptions<CostProjectSubprojects>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.subprojects(projectID),\n    queryFn: () => API.getCostSubprojects(projectID),\n    ...options,\n  });\n\nexport const useCostSubproject = (\n  { projectID, subprojectID }: SubprojectInput,\n  options: Omit<UseQueryOptions<CostSubproject>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.subproject({ projectID, subprojectID }),\n    queryFn: () => API.getCostSubproject(projectID, subprojectID),\n    ...options,\n  });\n\nexport const useCostFundingRequestSubmission = (\n  projectID: ID,\n  options: Omit<UseQueryOptions<FundingRequestSubmission>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.fundingRequestSubmission(projectID),\n    queryFn: () => API.fundingRequestAPI.getDataForSubmission(projectID),\n    ...options,\n  });\n\nexport const useCostFundingRequestsByProject = (\n  projectID: ID,\n  options: Omit<UseQueryOptions<CostProjectsFundingRequest[]>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.fundingRequestsByProject(projectID),\n    queryFn: () => API.fundingRequestAPI.getFundingRequestsByProject(projectID),\n    ...options,\n  });\n\nexport const useCostFundingRequest = (\n  input: FundingRequestInput,\n  options: Omit<UseQueryOptions<FundingRequest>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.fundingRequest(input),\n    queryFn: () => API.fundingRequestAPI.getFundingRequest(input),\n    ...options,\n  });\n\nexport const usePendingApprovalFundingRequests = (\n  locationID: number,\n  options: Omit<UseQueryOptions<PendingApprovalFundingRequest[]>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.pendingApprovals(locationID),\n    queryFn: () => API.fundingRequestAPI.getPendingApprovals(locationID),\n    ...options,\n  });\n\nexport const useCostSubprojectRefData = (\n  projectID: ID,\n  options: Omit<UseQueryOptions<CostSubprojectRefData>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.subprojectRefData(projectID),\n    queryFn: () => API.getCostSubprojectRefData(projectID),\n    ...options,\n  });\n\nexport const useCostEstimate = (\n  { projectID, subprojectID, costEstimateID }: EstimateInput,\n  options: Omit<UseQueryOptions<CostEstimate>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.estimate({ projectID, subprojectID, costEstimateID }),\n    queryFn: () => API.getCostEstimate(projectID, subprojectID, costEstimateID),\n    keepPreviousData: true,\n    ...options,\n  });\n\nexport const useCostEstimates = (\n  { projectID, subprojectID }: SubprojectInput,\n  options: Omit<UseQueryOptions<CostSubprojectEstimates>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.estimates({ projectID, subprojectID }),\n    queryFn: () => API.getCostEstimates(projectID, subprojectID),\n    ...options,\n  });\n\nexport const useCostEstimateRefData = ({ projectID, subprojectID }: SubprojectInput) =>\n  useQuery({\n    queryKey: queryKey.estimateRefData(),\n    queryFn: () => API.getCostEstimateRefData(projectID, subprojectID),\n  });\n\nexport const useCSICostElementsRefData = (\n  divisionIDs: ID[],\n  options: Omit<UseQueryOptions<CSICostElementsRefData>, \"queryFn\"> = {}\n) =>\n  useQuery({\n    queryKey: queryKey.csiCostElements(divisionIDs),\n    queryFn: () => API.getCSICostElementsInDivisions(divisionIDs),\n    staleTime: Infinity,\n    ...options,\n  });\n\nexport const useLaborRates = (locationID: number | null) =>\n  useQuery({\n    queryKey: queryKey.laborRates(locationID!),\n    queryFn: () => API.laborRatesAPI.getLaborRates(locationID!),\n    enabled: locationID !== null,\n    staleTime: 0,\n  });\n\nexport const useLaborRatesRefData = (locationID: number | null) =>\n  useQuery({\n    queryKey: queryKey.laborRatesRefData(locationID!),\n    queryFn: () => API.laborRatesAPI.getLaborRatesRefData(locationID!),\n    enabled: locationID !== null,\n  });\n\nexport const useLaborRatesHistory = (locationID?: number, disciplineID?: number) =>\n  useQuery({\n    queryKey: queryKey.laborRatesHistory({ locationID, disciplineID }),\n    queryFn: () => API.laborRatesAPI.getLaborRatesHistory(locationID!, disciplineID!),\n    enabled: !isNil(locationID) && !isNil(disciplineID),\n  });\n\nexport const useSetEstimateAsPreferredMutation = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    ({ projectID, subprojectID, costEstimateID }: EstimateInput) =>\n      API.setCostEstimateAsPreferred(projectID, subprojectID, costEstimateID),\n    {\n      onMutate: async ({ projectID, subprojectID, costEstimateID }) => {\n        const estimateQueryKey = queryKey.estimate({ projectID, subprojectID, costEstimateID });\n        const estimatesQueryKey = queryKey.estimates({ projectID, subprojectID });\n        const toastId = toast.loading(\"Setting preferred estimate...\");\n\n        await Promise.all([\n          queryClient.cancelQueries({\n            queryKey: estimateQueryKey,\n          }),\n          queryClient.cancelQueries({\n            queryKey: estimatesQueryKey,\n          }),\n        ]);\n\n        const previousEstimate = queryClient.getQueryData<CostSubprojectEstimates>(estimateQueryKey);\n        const previousEstimates = queryClient.getQueryData<CostSubprojectEstimates>(estimatesQueryKey);\n\n        // Optimistically update the individual cost estimate\n        optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n          estimate.is_primary = true;\n        });\n\n        // Optimistically update the all cost estimates (preferred flag has to be removed from others)\n        optimisticUpdate.costEstimates.update({ projectID, subprojectID }, (estimates) => {\n          estimates.forEach((estimate) => {\n            estimate.is_primary = estimate.cost_estimate_id === costEstimateID;\n          });\n        });\n\n        const rollBackData = () => {\n          queryClient.setQueryData(estimateQueryKey, previousEstimate);\n          queryClient.setQueryData(estimatesQueryKey, previousEstimates);\n        };\n\n        return {\n          rollBackData,\n          toastId,\n        };\n      },\n      onError: (err, variables, context) => {\n        toast.error(\"Failed to update preferred estimate\", { id: context?.toastId });\n\n        context && context.rollBackData();\n      },\n      onSettled: (data, error, variables) => {\n        queryClient.invalidateQueries(queryKey.project(variables.projectID));\n      },\n      onSuccess: (data, variables, context) => {\n        toast.success(\"Preferred estimate updated\", { id: context?.toastId });\n      },\n    }\n  );\n};\n\nexport const useUpdateVisibilityMutation = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation(\n    ({ projectID, subprojectID, costEstimateID, isPublic }: VisibilityInput) =>\n      API.updateCostEstimateVisibility(projectID, subprojectID, costEstimateID, isPublic),\n    {\n      onMutate: async ({ projectID, subprojectID, costEstimateID, isPublic }) => {\n        const estimatesQueryKey = queryKey.estimates({ projectID, subprojectID });\n\n        await queryClient.cancelQueries({\n          queryKey: estimatesQueryKey,\n        });\n        const previousEstimates = queryClient.getQueryData<CostSubprojectEstimates>(estimatesQueryKey);\n\n        optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n          estimate.is_public = isPublic;\n        });\n\n        const rollBackData = () => {\n          queryClient.setQueryData(estimatesQueryKey, previousEstimates);\n        };\n\n        const invalidateData = () => {\n          queryClient.invalidateQueries(estimatesQueryKey);\n        };\n\n        return { rollBackData, invalidateData };\n      },\n    }\n  );\n};\n\nexport const optimisticUpdate = {\n  costEstimates: {\n    update: (\n      subprojectInput: SubprojectInput,\n      updateFunction: (draftEstimates: Draft<CostSubprojectEstimates>) => void\n    ) => {\n      queryClient.setQueryData<CostSubprojectEstimates>(queryKey.estimates(subprojectInput), (cachedEstimates) =>\n        produce(cachedEstimates, (draftEstimates) => {\n          if (!draftEstimates) {\n            return;\n          }\n\n          updateFunction(draftEstimates);\n        })\n      );\n    },\n  },\n  costEstimate: {\n    update: (estimateInput: EstimateInput, updateFunction: (draftEstimate: Draft<CostEstimate>) => void) => {\n      queryClient.setQueryData<CostEstimate>(queryKey.estimate(estimateInput), (cachedEstimate) =>\n        produce(cachedEstimate, (draftEstimate) => {\n          if (!draftEstimate) {\n            return;\n          }\n\n          updateFunction(draftEstimate);\n        })\n      );\n    },\n    addScope({\n      projectID,\n      subprojectID,\n      costEstimateID,\n      scope,\n    }: EstimateInput & {\n      scope: CostScope;\n    }) {\n      optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n        estimate.cost_scope.push(scope);\n      });\n    },\n\n    updateScope({\n      projectID,\n      subprojectID,\n      costEstimateID,\n      scopeID,\n      scopeChanges,\n    }: ScopeInput & {\n      scopeChanges: Partial<CostScope>;\n    }) {\n      optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n        const scope = estimate.cost_scope.find((cs) => cs.cost_scope_id === scopeID);\n\n        if (scope) {\n          Object.assign(scope, scopeChanges);\n        }\n      });\n    },\n\n    addLineItem({\n      projectID,\n      subprojectID,\n      costEstimateID,\n      scopeID,\n      lineItem,\n    }: ScopeInput & {\n      lineItem: CostLineItem;\n    }) {\n      optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n        const scope = estimate.cost_scope.find((cost_scope) => cost_scope.cost_scope_id === scopeID);\n        if (!scope) return;\n\n        scope.cost_line_item = scope.cost_line_item ?? [];\n        scope.cost_line_item.push(lineItem);\n      });\n    },\n\n    updateEstimate({\n      projectID,\n      subprojectID,\n      costEstimateID,\n      updateFn,\n    }: EstimateInput & { updateFn: (estimate: WritableDraft<CostEstimate>) => void }) {\n      optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, updateFn);\n    },\n\n    updateLineItem({\n      projectID,\n      subprojectID,\n      costEstimateID,\n      scopeID,\n      lineItemID,\n      lineItemChanges,\n    }: LineItemInput & {\n      lineItemChanges: Partial<CostLineItem>;\n    }) {\n      optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n        const scope = estimate.cost_scope.find((cost_scope) => cost_scope.cost_scope_id === scopeID);\n\n        if (!scope) return;\n\n        scope.cost_line_item = scope.cost_line_item ?? [];\n        const lineItem = scope.cost_line_item.find((cli) => cli.cost_line_item_id === lineItemID);\n\n        if (!lineItem) return;\n\n        Object.assign(lineItem, lineItemChanges);\n      });\n    },\n    deleteScope({ projectID, subprojectID, costEstimateID, scopeID }: ScopeInput) {\n      optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n        estimate.cost_scope = estimate.cost_scope.filter((scope) => scope.cost_scope_id !== scopeID);\n      });\n    },\n    deleteLineItem({ projectID, subprojectID, costEstimateID, scopeID, lineItemID }: LineItemInput) {\n      optimisticUpdate.costEstimate.update({ projectID, subprojectID, costEstimateID }, (estimate) => {\n        const scope = estimate.cost_scope.find((cost_scope) => cost_scope.cost_scope_id === scopeID);\n\n        if (!scope) return;\n\n        scope.cost_line_item = scope.cost_line_item ?? [];\n        scope.cost_line_item = scope.cost_line_item.filter((item) => item.cost_line_item_id !== lineItemID);\n      });\n    },\n  },\n};\n```\n\ni have prijects and project, projects is a lost or project, so when u create or update a project, should i invalidate the project or should i update hte projects with the new value\nFor optimal user experience and data consistency, I'd recommend a combined approach:\n\n1. For creating a new project:\n```typescript\n// Invalidate the projects list query since we need to update pagination, counts, etc.\nqueryClient.invalidateQueries(queryKey.projects(locationId));\n\n// Optionally, you can setQueryData for the individual project\nqueryClient.setQueryData(queryKey.project(newProject.id), newProject);\n```\n\n2. For updating an existing project:\n```typescript\n// Update the individual project cache\nqueryClient.setQueryData(queryKey.project(updatedProject.id), updatedProject);\n\n// Also update the project in the projects list\nqueryClient.setQueryData(\n  queryKey.projects(locationId),\n  (old: { projects: CostProject[] }) => ({\n    ...old,\n    projects: old.projects.map(project => \n      project.id === updatedProject.id ? updatedProject : project\n    )\n  })\n);\n```\n\nThe reasoning is:\n- For creation: The projects list needs to be refetched because it affects pagination, total count, and ordering\n- For updates: You can optimistically update both caches to provide immediate feedback, while maintaining consistency\n\nHowever, if your projects list includes complex filtering, sorting, or pagination, it might be safer to just invalidate the projects query in both cases:\n\n```typescript\n// Simpler approach\nqueryClient.invalidateQueries(queryKey.projects(locationId));\n```\n\nThis ensures the list is always in sync with the backend, though at the cost of an extra network request.\n\nChoose based on your specific needs:\n- If immediate feedback is crucial and you can reliably update the cache → Use the optimistic updates\n- If data consistency is more important than immediate feedback → Use invalidation\n\n\n\nthe user is not there is my db, should i create one or can i just recreate the view, will it pickup a different user\nIf the user doesn't exist in your database, you should create one first before recreating the view. Views are dependent on having valid user references, and trying to recreate a view without a corresponding user could cause issues:\n\n1. Database integrity: Views often need to reference valid users for permissions, ownership, or audit trails\n2. Foreign key constraints: If your views have user foreign keys, they'll fail without valid user records\n3. Application logic: Many features likely assume the existence of a user record\n\nThe recommended flow would be:\n\n1. First create the user:\n```sql\nINSERT INTO users (user_id, ...) VALUES (...);\n```\n\n2. Then recreate the view:\n```sql\nCREATE OR REPLACE VIEW your_view AS ...\n```\n\nSimply recreating the view without creating the user first could:\n- Break referential integrity\n- Cause runtime errors\n- Create inconsistent data states\n- Lead to permissions/access issues\n\nAlways ensure the user exists before creating or modifying views that depend on user data.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":224}}},{"id":{"replica_id":0,"value":54},"start":16816,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":225}}},{"id":{"replica_id":0,"value":165},"start":18537,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":226}}},{"id":{"replica_id":0,"value":181},"start":18655,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":227}}},{"id":{"replica_id":0,"value":182},"start":19662,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":228}}}],"summary":"Cache Invalidation vs Direct Update","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":16634},"icon":"File","label":"atom-web/src/browser/components/capital-cost/queries.ts","metadata":{"path":"atom-web/src/browser/components/capital-cost/queries.ts"}}],"thought_process_output_sections":[]}