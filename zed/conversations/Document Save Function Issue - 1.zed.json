{"id":"600a97b2-2c06-47b5-ac31-72d28720d3d6","zed":"context","version":"0.4.0","text":"\n\n\n```ts atom-web/src/server/new-structure/application/repositories/document.repo.ts\nimport { accessibleBy } from \"@casl/prisma\";\nimport { Prisma } from \"@prisma/client\";\nimport { inject, injectable } from \"inversify\";\nimport _, { isEmpty } from \"lodash\";\nimport { DBClient } from \"../../../config/database/client\";\nimport { DocumentNumberAlreadyExistsError, EntityNotFoundError } from \"../../../utils/errors\";\nimport { CompanyMap } from \"../../domain/company/company.map\";\nimport { CSIDivisionMap } from \"../../domain/csi-division/csi-division.map\";\nimport { DisciplineMap } from \"../../domain/discipline/discipline.map\";\nimport { DocumentRevisionLinkType } from \"../../domain/document/entities/doc-revision-link.entity\";\nimport { DocRevision } from \"../../domain/document/entities/doc-revision.entity\";\nimport { Document, DocumentProps } from \"../../domain/document/entities/document.entity\";\nimport { File } from \"../../domain/document/entities/file.entity\";\nimport { RevisionStatusType, TRevisionStatusType } from \"../../domain/document/entities/revision-status-type.entity\";\nimport { DocRevisionMap } from \"../../domain/document/mappers/doc-revision.map\";\nimport { DocumentMap } from \"../../domain/document/mappers/document.map\";\nimport { FileMap } from \"../../domain/document/mappers/file.map\";\nimport { IDocumentRepo } from \"../../domain/document/repos/document.repo\";\nimport { ReferencedDocData } from \"../../domain/document/services/document.service\";\nimport { AreaMap } from \"../../domain/location/mappers/area.map\";\nimport { LevelMap } from \"../../domain/location/mappers/level.map\";\nimport { ILocationRepo } from \"../../domain/location/repos/location.repo\";\nimport { PersistedProject, Project } from \"../../domain/project/entities/project.entity\";\nimport {\n  PersistedRequestInstance,\n  RequestInstance,\n} from \"../../domain/request/instance/entities/request-instance.entity\";\nimport { PersistedScope, Scope } from \"../../domain/scope/entities/scope.entity\";\nimport { DocumentPurposeMap } from \"../../domain/settings/document-purpose/map\";\nimport { DocumentTypeMap } from \"../../domain/settings/document-type/map\";\nimport { LocationDocumentPurpose } from \"../../domain/settings/locations/document-purpose/entity\";\nimport { LocationDocumentPurposeMap } from \"../../domain/settings/locations/document-purpose/map\";\nimport { LocationProgramMap } from \"../../domain/settings/locations/program/map\";\nimport { ProgramMap } from \"../../domain/settings/program/map\";\nimport { User } from \"../../domain/user/user.entity\";\nimport { UserMap } from \"../../domain/user/user.map\";\nimport { AuthzService } from \"../../framework/application/authz.service\";\nimport { FilterDTOPrisma } from \"../../framework/application/get-many\";\nimport { PaginatedFilteredDTO, PaginatedFilteredDTOResult } from \"../../framework/application/paginated-filtered-dto\";\nimport { Collection } from \"../../framework/domain/collection\";\nimport { assertPersistency, PersistedEntity } from \"../../framework/domain/entity\";\nimport { BaseRepo } from \"../../framework/infrastructure/base-repo\";\nimport TYPES from \"../../framework/inversify/types\";\nimport { companyQueryInclude } from \"./company.repo\";\nimport { userQueryInclude } from \"./user.repo\";\nimport {\n  DocumentSubmittalCategoryMap,\n  DocumentSubmittalDetailMap,\n  DocumentSubmittalTypeMap,\n} from \"../../domain/settings/locations/document-submittal-metadata/submittal.map\";\nimport { DocumentFieldType, DocumentNumberingScheme } from \"@atom/types\";\n\nexport const getDocumentQueryInclude = (authzService: AuthzService) => {\n  return {\n    document_package_document: true,\n    document_program: true,\n    document_revision: {\n      where: accessibleBy(authzService.getUserAbility(), \"read\").document_revision,\n      include: {\n        project_document_revision: {\n          include: {\n            project: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        scope_document_revision: {\n          include: {\n            scope: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        request_document_revision: {\n          include: {\n            request: {\n              select: {\n                request_form_value: {\n                  select: {\n                    title: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n        document_revision_status: {\n          include: {\n            document_revision_status_type: true,\n          },\n        },\n        file: {\n          select: {\n            extension: true,\n          },\n        },\n        location_document_purpose: {\n          include: {\n            document_purpose: true,\n          },\n        },\n      },\n    },\n    document_additional_area: {\n      select: {\n        area_id: true,\n      },\n    },\n    document_csi_division: true,\n    document_submittal_category: true,\n    document_submittal_type: true,\n    document_submittal_detail: true,\n  } satisfies Prisma.Args<typeof DBClient.document, \"findMany\">[\"include\"];\n};\nconst typeToProperty = {\n  [DocumentFieldType.Type.SITE]: \"siteID\",\n  [DocumentFieldType.Type.BUILDING]: \"buildingID\",\n  [DocumentFieldType.Type.AREA]: \"areaID\",\n  [DocumentFieldType.Type.AREA_DETAIL]: \"areaDetailID\",\n  [DocumentFieldType.Type.LEVEL]: \"levelID\",\n  [DocumentFieldType.Type.PROGRAM]: \"locationProgramIDs\",\n  [DocumentFieldType.Type.TYPE]: \"typeID\",\n  [DocumentFieldType.Type.DISCIPLINE]: \"disciplineID\",\n} as const satisfies Partial<{\n  [key in (typeof DocumentFieldType.Type)[keyof typeof DocumentFieldType.Type]]: string;\n}>;\nconst propertyToColumn = {\n  siteID: \"site_id\",\n  buildingID: \"building_id\",\n  areaID: \"area_id\",\n  areaDetailID: \"area_detail_id\",\n  levelID: \"level_id\",\n  locationProgramIDs: \"document_program\",\n  typeID: \"document_type_id\",\n  disciplineID: \"discipline_id\",\n} as const;\n\nexport type DocumentMetadata = {\n  number: string;\n  buildingID: number;\n  siteID: number | null;\n  areaID: number;\n  areaDetailID: number | null;\n  levelID: number;\n  locationProgramIDs: number[];\n  typeID: number;\n  disciplineID: number;\n  locationDocumentPurposeID: number;\n};\n\n@injectable()\nexport class DocumentRepo extends BaseRepo implements IDocumentRepo {\n  constructor(\n    @inject(TYPES.DBClient) protected readonly db: typeof DBClient,\n    @inject(TYPES.ILocationRepo) protected readonly locationRepo: ILocationRepo,\n    @inject(AuthzService) private readonly authzService: AuthzService,\n    @inject(\"DocumentFilterDTOPrisma\")\n    private readonly filterDTOPrisma: FilterDTOPrisma<DocumentProps>\n  ) {\n    super(db);\n  }\n\n  private readonly baseQuery = { is_deleted: 0 } satisfies Prisma.documentWhereInput;\n\n  async getByID(id: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: id,\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getManyByIDs(ids: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: {\n              in: ids,\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByDocumentNumbers(documentNumbers: string[], locationID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          { location_id: locationID },\n          {\n            document_number: { in: documentNumbers },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByPackageID(packageID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_package_document: {\n              some: {\n                package_id: packageID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByRevisionID(revisionID: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: revisionID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getByRevisionIDs(revisionIDs: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: { in: revisionIDs },\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getMany(paginatedFilteredDTO: PaginatedFilteredDTO<Document>): Promise<PaginatedFilteredDTOResult<Document>> {\n    const { filters, parentEntity, locationID, excludeParentEntity } = paginatedFilteredDTO;\n    const filterQuery = this.filterDTOPrisma.createPrismaQuery(filters.filterDTO);\n    const parentSelect = parentEntity && this.getParentSelect(parentEntity);\n    const excludeParent = excludeParentEntity && this.getParentSelect(excludeParentEntity);\n\n    const query: Prisma.documentWhereInput = {\n      AND: [\n        accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n        this.baseQuery,\n        filterQuery,\n        locationID ? { location_id: locationID } : {},\n        excludeParent\n          ? {\n              document_revision: {\n                some: {\n                  [excludeParent.table_name]: {\n                    none: {\n                      [excludeParent.ref_name]: excludeParent.id,\n                    },\n                  },\n                },\n              },\n            }\n          : {},\n        {\n          OR: [\n            parentSelect\n              ? {\n                  document_revision: {\n                    some: {\n                      [parentSelect.table_name]: {\n                        some: {\n                          [parentSelect.ref_name]: parentSelect.id,\n                        },\n                      },\n                    },\n                  },\n                }\n              : {},\n            filters.scopeIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.scopeIDs,\n                  refName: \"scope_id\",\n                  tableName: \"scope_document_revision\",\n                })\n              : {},\n            filters.requestIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.requestIDs,\n                  refName: \"request_id\",\n                  tableName: \"request_document_revision\",\n                })\n              : {},\n            filters.projectIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.projectIDs,\n                  refName: \"project_id\",\n                  tableName: \"project_document_revision\",\n                })\n              : {},\n          ],\n        },\n      ],\n    };\n\n    let pagination = {};\n\n    if (paginatedFilteredDTO.page && paginatedFilteredDTO.pageSize) {\n      pagination = {\n        take: paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize,\n        skip: (paginatedFilteredDTO.page - 1) * paginatedFilteredDTO.pageSize,\n      };\n    }\n\n    const orderBy = { document_id: \"desc\" } as const;\n    const dbDocumentList = await this.db.document.findMany({\n      where: query,\n      select: { document_id: true },\n      orderBy,\n      take: paginatedFilteredDTO.limit || 1000,\n      skip: \"skip\" in pagination ? (pagination.skip as number) : 0,\n    });\n\n    const count = dbDocumentList.length + (\"skip\" in pagination ? (pagination.skip as number) : 0);\n\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        document_id: {\n          in: dbDocumentList\n            .slice(0, paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize || 10)\n            .map(({ document_id }) => document_id),\n        },\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy,\n    });\n\n    return { result: dbDocuments.map(DocumentMap.toDomain), count };\n  }\n\n  async save(document: Document) {\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation)\n      throw new DocumentNumberAlreadyExistsError(\n        `A document with number ${document.number} already exists in this location.`\n      );\n\n    console.log(\"Saving document !\", document.id);\n    if (document.id) {\n      await this.db.document.update({\n        where: {\n          document_id: document.id,\n        },\n        data: DocumentMap.toPersistenceUpdate(document),\n      });\n\n      await this.updateDocumentCSIDivisions(document.id, document.csiDivisionIDs);\n    } else {\n      const createdDocument = await this.db.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n\n      document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    await this.saveAdditionalAreas(document);\n    await this.saveRevisions(document);\n    await this.saveLinks(document);\n    await this.savePrograms(document);\n  }\n\n  async saveAdditionalAreas(document: Document) {\n    if (document.id) {\n      await this.db.document_additional_area.deleteMany({\n        where: {\n          document_id: document.id,\n        },\n      });\n    }\n\n    if (document.additionalAreaIDs && document.additionalAreaIDs.length > 0) {\n      await this.db.document_additional_area.createMany({\n        data: document.additionalAreaIDs.map((areaID) => ({\n          area_id: areaID,\n          document_id: document.id!,\n        })),\n      });\n    }\n  }\n\n  async saveRevisions(document: Document) {\n    let dbStatuses: { creation_ts: Date; revision_status_id: number }[];\n\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        if (revision.id) {\n          const updateDetails = await this.db.document_revision.update({\n            where: {\n              document_revision_id: revision.id,\n            },\n            data: DocRevisionMap.toPersistence(revision),\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = updateDetails.document_revision_status;\n        } else {\n          const createdRevision = await this.db.document_revision.create({\n            data: {\n              document_id: document.id!,\n              ...DocRevisionMap.toPersistence(revision),\n            },\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = createdRevision.document_revision_status;\n\n          revision.setId(createdRevision.document_revision_id);\n        }\n\n        revision.statuses.forEach((status) => {\n          const updateStatusDetails = dbStatuses.find(\n            (updateStatusDetails) => updateStatusDetails.creation_ts.getTime() === status.creationTs.getTime()\n          );\n\n          updateStatusDetails && status.setId(updateStatusDetails.revision_status_id);\n        });\n      })\n    );\n\n    await Promise.all([this.saveLastStatus(document.lastRevision), this.saveLastRevision(document)]);\n  }\n\n  async saveLastRevision(document: Document) {\n    return this.db.document.update({\n      where: {\n        document_id: document.id,\n      },\n      data: {\n        latest_revision_id: document.lastRevision.id,\n      },\n    });\n  }\n\n  async saveLastStatus(revision: DocRevision) {\n    const statuses = await this.db.document_revision_status.findMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      orderBy: {\n        creation_ts: \"asc\",\n      },\n    });\n\n    if (statuses.at(-1)!.is_last && statuses.slice(0, statuses.length - 1).every((status) => !status.is_last)) {\n      return;\n    }\n\n    await this.db.document_revision_status.updateMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      data: {\n        is_last: false,\n      },\n    });\n\n    await this.db.document_revision_status.update({\n      where: {\n        revision_status_id: statuses.at(-1)!.revision_status_id,\n      },\n      data: {\n        is_last: true,\n      },\n    });\n  }\n\n  private async addDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const addedPrograms = document.locationProgramIDs.added;\n\n    if (_.isEmpty(addedPrograms)) return;\n\n    await this.db.document_program.createMany({\n      data: addedPrograms.map((removedLocationProgramID) => ({\n        document_id: document.id,\n        location_program_id: removedLocationProgramID,\n      })),\n    });\n  }\n\n  private async removeDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const removedPrograms = document.locationProgramIDs.removed;\n\n    if (_.isEmpty(removedPrograms)) return;\n\n    await this.db.document_program.deleteMany({\n      where: {\n        OR: removedPrograms.map((removedProgramID) => ({\n          document_id: document.id,\n          location_program_id: removedProgramID,\n        })),\n      },\n    });\n  }\n\n  private async savePrograms(document: PersistedEntity<Document>) {\n    await this.removeDocumentPrograms(document);\n    await this.addDocumentPrograms(document);\n  }\n\n  // TODO: Only run this function when entity has csi divisions updated (keep track of entity changes locally)\n  private async updateDocumentCSIDivisions(document_id: number, csi_division_ids: Collection<number>): Promise<void> {\n    if (!isEmpty(csi_division_ids.removed)) {\n      await this.db.document_csi_division.deleteMany({\n        where: {\n          document_id,\n          csi_division_id: {\n            in: csi_division_ids.removed,\n          },\n        },\n      });\n    }\n  }\n\n  private async saveLinks(document: Document) {\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        await this.updateLinks(revision);\n        await this.removeLinks(revision);\n        await this.addLinks(revision);\n      })\n    );\n  }\n\n  private async updateLinks(revision: DocRevision): Promise<void> {\n    const links = revision.links.filter((link) => link.didChange);\n\n    if (_.isEmpty(links)) return;\n\n    const scopeLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const requestLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Request);\n\n    await Promise.all([\n      ...scopeLinks.map((scopeLink) =>\n        this.db.scope_document_revision.update({\n          where: {\n            id: scopeLink.id,\n          },\n          data: {\n            is_released: scopeLink.isReleased,\n          },\n        })\n      ),\n      ...requestLinks.map((requestLink) =>\n        this.db.request_document_revision.update({\n          where: {\n            id: requestLink.id,\n          },\n          data: {\n            is_released: requestLink.isReleased,\n          },\n        })\n      ),\n    ]);\n  }\n\n  private async addLinks(revision: DocRevision): Promise<void> {\n    const addedLinks = revision.links.added;\n\n    if (_.isEmpty(addedLinks)) return;\n\n    const addedScopes = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const addedRequests = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Request);\n    const addedProjects = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Project);\n\n    await this.db.document_revision.update({\n      where: { document_revision_id: revision.id },\n      data: {\n        scope_document_revision: {\n          createMany: {\n            data: addedScopes.map((addedScope) => ({\n              scope_id: addedScope.parentID,\n              is_released: addedScope.isReleased,\n              created_by: addedScope.createdBy,\n            })),\n          },\n        },\n        request_document_revision: {\n          createMany: {\n            data: addedRequests.map((addedRequest) => ({\n              request_id: addedRequest.parentID,\n              is_released: addedRequest.isReleased,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n        project_document_revision: {\n          createMany: {\n            data: addedProjects.map((addedRequest) => ({\n              project_id: addedRequest.parentID,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n      },\n    });\n  }\n\n  private async removeLinks(revision: DocRevision): Promise<void> {\n    const removedLinks = revision.links.removed;\n\n    if (_.isEmpty(removedLinks)) return;\n\n    const removedScopes = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Scope);\n    const removedRequests = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Request);\n    const removedProjects = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Project);\n\n    if (!_.isEmpty(removedScopes))\n      await this.db.scope_document_revision.deleteMany({\n        where: {\n          OR: removedScopes.map((removedScope) => ({\n            scope_id: removedScope.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedRequests))\n      await this.db.request_document_revision.deleteMany({\n        where: {\n          OR: removedRequests.map((removedRequest) => ({\n            request_id: removedRequest.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedProjects))\n      await this.db.project_document_revision.deleteMany({\n        where: {\n          OR: removedProjects.map((removedProject) => ({\n            project_id: removedProject.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n  }\n\n  async isDocumentNumberUniqueInLocation(document: Document) {\n    const count = await this.db.document.count({\n      where: {\n        document_number: document.number,\n        location_id: document.locationID,\n        ...(document.id ? { document_id: { notIn: [document.id] } } : {}), // Exclude itself\n      },\n    });\n\n    return count === 0;\n  }\n\n  async delete(document: Document): Promise<void> {\n    if (!document.id) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n    assertPersistency(document);\n\n    const { count } = await this.db.document.updateMany({\n      where: {\n        AND: [this.baseQuery, { document_id: document.id }],\n      },\n      data: {\n        is_deleted: 1,\n      },\n    });\n\n    document.locationProgramIDs.removeAll();\n    await this.savePrograms(document);\n\n    if (!count) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n  }\n\n  async getRevisionStatusTypes(): Promise<RevisionStatusType[]> {\n    const dbStatusTypes = await this.db.document_revision_status_type.findMany();\n    return dbStatusTypes.map((dbStatusType) => RevisionStatusType.create(dbStatusType.type as TRevisionStatusType));\n  }\n\n  public getParentSelect(parentEntity: PersistedScope | PersistedRequestInstance | PersistedProject) {\n    if (parentEntity instanceof Scope) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"scope_id\",\n        table_name: \"scope_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof RequestInstance) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"request_id\",\n        table_name: \"request_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof Project) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"project_id\",\n        table_name: \"project_document_revision\",\n      };\n    }\n\n    throw new Error(\"Invalid parent entity\");\n  }\n\n  public async getDocumentsRefData(documentIDs: number[]) {\n    const dbRefDataDocuments = await this.db.document.findMany({\n      where: {\n        document_id: { in: documentIDs },\n      },\n      include: {\n        site: true,\n        building: true,\n        area: true,\n        area_detail: true,\n        document_additional_area: {\n          include: {\n            area: true,\n          },\n        },\n        location_level: true,\n        document_type: true,\n        discipline: true,\n        document_program: { include: { location_program: { include: { program: true } } } },\n        created_by_user: { include: userQueryInclude },\n        updated_by_user: { include: userQueryInclude },\n        created_by_company_full: { include: companyQueryInclude },\n        updated_by_company_full: { include: companyQueryInclude },\n        document_csi_division: { include: { csi_division: { select: { title: true } } } },\n        document_submittal_category: true,\n        document_submittal_type: true,\n        document_submittal_detail: { include: { document_submittal_type: true } },\n      },\n    });\n\n    const refData: ReferencedDocData = {};\n\n    if (dbRefDataDocuments.length === 0) return refData;\n\n    const programs: Record<number, (typeof programsList)[0]> = {};\n\n    const programsList = await this.locationRepo.getProgramsInLocation(dbRefDataDocuments[0].location_id);\n\n    programsList.forEach((locationProgram) => {\n      programs[locationProgram.program.id] = locationProgram;\n    });\n\n    dbRefDataDocuments.forEach((dbRefDataDocument) => {\n      refData[dbRefDataDocument.document_id] = {\n        type: DocumentTypeMap.toDomain(dbRefDataDocument.document_type),\n        discipline: DisciplineMap.toDomain(dbRefDataDocument.discipline),\n        createdBy: UserMap.toDomain(dbRefDataDocument.created_by_user),\n        updatedBy: dbRefDataDocument.updated_by_user ? UserMap.toDomain(dbRefDataDocument.updated_by_user) : null,\n        site: dbRefDataDocument.site ? AreaMap.toDomain(dbRefDataDocument.site) : null, // TODO: ATOM-3197 - Remove NULL when site is mandatory\n        building: AreaMap.toDomain(dbRefDataDocument.building),\n        area: AreaMap.toDomain(dbRefDataDocument.area),\n        areaDetail: dbRefDataDocument.area_detail ? AreaMap.toDomain(dbRefDataDocument.area_detail) : null,\n        additionalAreas: dbRefDataDocument.document_additional_area.map((additional_area) =>\n          AreaMap.toDomain(additional_area.area)\n        ),\n        level: LevelMap.toDomain(dbRefDataDocument.location_level),\n        programs: dbRefDataDocument.document_program.map(({ location_program }) =>\n          LocationProgramMap.toDomain(location_program, ProgramMap.toDomain(location_program.program), {\n            enabled: true,\n          })\n        ),\n        createdByCompany: CompanyMap.toDomain(dbRefDataDocument.created_by_company_full),\n        updatedByCompany: dbRefDataDocument.updated_by_company_full\n          ? CompanyMap.toDomain(dbRefDataDocument.updated_by_company_full)\n          : null,\n        csiDivisions: dbRefDataDocument.document_csi_division.map((csiDivision) =>\n          CSIDivisionMap.toDomain({ division_id: csiDivision.csi_division_id, title: csiDivision.csi_division.title })\n        ),\n        submittal: {\n          category: dbRefDataDocument.document_submittal_category\n            ? DocumentSubmittalCategoryMap.toDomain(dbRefDataDocument.document_submittal_category)\n            : null,\n          type: dbRefDataDocument.document_submittal_type\n            ? DocumentSubmittalTypeMap.toDomain(dbRefDataDocument.document_submittal_type)\n            : null,\n          detail: dbRefDataDocument.document_submittal_detail\n            ? DocumentSubmittalDetailMap.toDomain(dbRefDataDocument.document_submittal_detail)\n            : null,\n        },\n      };\n    });\n\n    return refData;\n  }\n\n  public async getRevisionsRefData(revisionIDs: number[]) {\n    const dbRefDataRevisions = await this.db.document_revision.findMany({\n      where: {\n        document_revision_id: { in: revisionIDs },\n      },\n      include: {\n        file: true,\n        user: { include: userQueryInclude },\n        location_document_purpose: { include: { document_purpose: true } },\n      },\n    });\n\n    const refData: Record<\n      number,\n      {\n        file: File;\n        createdByUser: PersistedEntity<User>;\n        purposeType: LocationDocumentPurpose;\n      }\n    > = {};\n\n    dbRefDataRevisions.forEach((dbRefDataRevision) => {\n      refData[dbRefDataRevision.document_revision_id] = {\n        file: FileMap.toDomain(dbRefDataRevision.file),\n        createdByUser: UserMap.toDomain(dbRefDataRevision.user),\n        purposeType: LocationDocumentPurposeMap.toDomain(\n          dbRefDataRevision.location_document_purpose,\n          DocumentPurposeMap.toDomain(dbRefDataRevision.location_document_purpose.document_purpose),\n          { enabled: true }\n        ),\n      };\n    });\n\n    return refData;\n  }\n\n  private getParentSelectFromIDs({\n    ids,\n    refName,\n    tableName,\n  }: {\n    ids: number[];\n    refName: string;\n    tableName: string;\n  }): Prisma.documentWhereInput {\n    return {\n      document_revision: {\n        some: {\n          [tableName]: {\n            some: {\n              [refName]: { in: ids },\n            },\n          },\n        },\n      },\n    };\n  }\n\n  private async getMaximumSequenceNumberDocument(\n    document: DocumentMetadata,\n    locationID: number,\n    numberingFormat: DocumentNumberingScheme.DocumentNumberingSegment[]\n  ): Promise<Document | undefined> {\n    const filter: any = {};\n\n    for (const segment of numberingFormat) {\n      if (\n        segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER ||\n        segment.fieldKey === DocumentFieldType.Type.FREE_TEXT ||\n        segment.fieldKey === DocumentFieldType.Type.ORIGINATING_ORGANIZATION\n      ) {\n        continue;\n      }\n      if (segment.fieldKey === DocumentFieldType.Type.PURPOSE) {\n        filter[\"document_revision\"] = {\n          some: {\n            location_document_purpose_id: document.locationDocumentPurposeID,\n          },\n        };\n        continue;\n      }\n      const property = typeToProperty[segment.fieldKey as keyof typeof typeToProperty];\n      if (!property) {\n        throw new Error(`Unsupported numbering scheme segment: ${segment}`);\n      }\n      const column = propertyToColumn[property as keyof typeof propertyToColumn] as string;\n      if (!column) {\n        throw new Error(`Unsupported property: ${property}`);\n      }\n      filter[column] = document[property];\n    }\n\n    const sequenceNumberIndex = numberingFormat.findIndex(\n      (segment) => segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER\n    );\n    const documentNumber = document.number.split(\"-\");\n\n    if (documentNumber[sequenceNumberIndex] === DocumentFieldType.Type.SEQUENCE_NUMBER) {\n      documentNumber[sequenceNumberIndex] = \"%\";\n    }\n\n    const numberingSchemeMatchCondition = {\n      document_number: {\n        contains: documentNumber.join(\"-\"),\n      },\n    };\n\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          filter,\n          numberingSchemeMatchCondition,\n          { location_id: locationID },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy: {\n        sequence_number: \"desc\",\n      },\n    });\n\n    if (!dbDocument) {\n      return undefined;\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getNextSequenceNumber(\n    document: DocumentMetadata,\n    locationID: number,\n    format: DocumentNumberingScheme.DocumentNumberingSegment[],\n    sequenceNumberStart: number\n  ): Promise<number> {\n    const matchingDocument = await this.getMaximumSequenceNumberDocument(document, locationID, format);\n    if (!matchingDocument) {\n      return sequenceNumberStart;\n    }\n    const maxSequenceNumber = matchingDocument.sequenceNumber ?? 0;\n    return Math.max(maxSequenceNumber + 1, sequenceNumberStart);\n  }\n}\n```\n\nhere i am trying to update the doucment fight after creating it, so calling the save function back to bac, onw eith document id and one without doucment id, but it s failing, can you see anything\n\nLooking at your code, I notice that after creating the document, you update its ID but the subsequent operations might be using the same document object without properly waiting for the ID to be set. Here's the relevant part:\n\n```typescript\nelse {\n  const createdDocument = await this.db.document.create({\n    data: DocumentMap.toPersistence(document),\n  });\n\n  document.setId(createdDocument.document_id);\n}\n\nassertPersistency(document);\nawait this.saveAdditionalAreas(document);\nawait this.saveRevisions(document);\nawait this.saveLinks(document);\nawait this.savePrograms(document);\n```\n\nTo fix this, you should:\n\n1. Make sure the `setId` operation is completed before continuing\n2. Add proper error handling\n3. Consider using a transaction to ensure atomicity\n\nHere's a suggested fix:\n\n```typescript\nelse {\n  try {\n    await this.db.$transaction(async (tx) => {\n      const createdDocument = await tx.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n\n      document.setId(createdDocument.document_id);\n\n      assertPersistency(document);\n\n      await Promise.all([\n        this.saveAdditionalAreas(document),\n        this.saveRevisions(document),\n        this.saveLinks(document),\n        this.savePrograms(document),\n      ]);\n    });\n  } catch (error) {\n    console.error('Error saving document:', error);\n    throw error;\n  }\n}\n```\n\nThis modification:\n1. Wraps the create and subsequent operations in a transaction\n2. Ensures the ID is set before proceeding with other operations\n3. Adds error handling\n4. Uses Promise.all for parallel execution of the subsequent saves\n5. Makes sure the document entity is properly persisted before being used in other operations\n\nAlso, make sure that your `setId` method in the Document entity properly updates the ID and that `assertPersistency` correctly validates the document's state.\nthis is the error \n\nError in create document use case PrismaClientKnownRequestError:\nInvalid `prisma.document.update()` invocation:\n\n\nUnique constraint failed on the constraint: `PRIMARY`\n    at $n.handleRequestError (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:121:7315)\n    at $n.handleAndLogRequestError (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:121:6623)\n    at $n.request (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:121:6307)\n    at l (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:130:9633)\n    at DocumentRepo.save (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/repositories/document.repo.ts:345:13)\n    at UseCase.execute (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-document/use-case.ts:35:13)\n    at /Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/use-case.ts:31:36\n    at /Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/transaction-service.ts:62:28\n    at Proxy._transactionWithCallback (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:130:8000)\n    at Function.retry (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/transaction-service.ts:20:32)\n    at TransactionService.getNewContainer (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/transaction-service.ts:56:16)\n    at UseCase.createDocument (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/use-case.ts:29:20)\n    at UseCase.execute (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/use-case.ts:20:34)\n    at BaseController.executeImpl (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/base-controller.ts:43:28)\n    at BaseController.execute (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/base-controller.ts:24:9) {\n  code: 'P2002',\n  clientVersion: '5.22.0',\n  meta: { modelName: 'document', target: 'PRIMARY' }\n}\n\nThe error indicates a primary key conflict when trying to update the document. This typically happens when you're trying to insert a record with a primary key that already exists or when there's a conflict in the transaction.\n\nLet's modify the `save` method in the DocumentRepo to better handle the document creation and update:\n\n```typescript\nasync save(document: Document) {\n  const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n  if (!isDocumentNumberUniqueInLocation) {\n    throw new DocumentNumberAlreadyExistsError(\n      `A document with number ${document.number} already exists in this location.`\n    );\n  }\n\n  try {\n    await this.db.$transaction(async (tx) => {\n      if (document.id) {\n        // Update existing document\n        await tx.document.update({\n          where: {\n            document_id: document.id,\n          },\n          data: DocumentMap.toPersistenceUpdate(document),\n        });\n      } else {\n        // Create new document\n        const createdDocument = await tx.document.create({\n          data: DocumentMap.toPersistence(document),\n        });\n        document.setId(createdDocument.document_id);\n      }\n\n      assertPersistency(document);\n\n      // Execute these operations sequentially to avoid conflicts\n      await this.saveAdditionalAreas(document);\n      await this.saveRevisions(document);\n      await this.saveLinks(document);\n      await this.savePrograms(document);\n    });\n  } catch (error) {\n    console.error('Error in document save:', error);\n    throw error;\n  }\n}\n```\n\nAlso, check these potential issues:\n\n1. Make sure `DocumentMap.toPersistence` and `DocumentMap.toPersistenceUpdate` are correctly handling the document ID:\n\n```typescript\n// In DocumentMap\nstatic toPersistence(document: Document) {\n  return {\n    // Don't include document_id for create\n    document_number: document.number,\n    // ... other fields\n  };\n}\n\nstatic toPersistenceUpdate(document: Document) {\n  return {\n    document_number: document.number,\n    // ... other fields\n    // Make sure you're not trying to update the primary key\n  };\n}\n```\n\n2. Check if you're using any transactions at a higher level (in your use case) that might be conflicting with this operation.\n\n3. Verify that the document ID is not being set incorrectly somewhere else in your code before calling save.\n\nCan you also share the code for:\n1. The use case that's calling this repository method\n2. The `DocumentMap.toPersistence` and `DocumentMap.toPersistenceUpdate` methods?\n\nThis would help identify if there's a problem in how the document is being prepared before saving.\ni am using a transation at a higher level, the create and update is happening in the same transatction, how would it impact this \nAh, that's likely the source of the problem! When you have nested transactions or operations within the same transaction trying to create and then immediately update the same record, it can cause conflicts, especially with primary keys.\n\nCould you share the higher-level transaction code? It's probably something like this:\n\n```typescript\n// Higher level transaction (perhaps in your use case)\nawait this.transactionService.getNewContainer(async () => {\n  await documentRepo.save(document); // First save (create)\n  await documentRepo.save(document); // Second save (update)\n});\n```\n\nTo fix this, you should:\n\n1. Either combine the operations into a single save call, or\n2. Modify your repository to handle the operations differently within an existing transaction\n\nHere's how you could modify your `DocumentRepo.save` method to handle this:\n\n```typescript\nasync save(document: Document) {\n  const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n  if (!isDocumentNumberUniqueInLocation) {\n    throw new DocumentNumberAlreadyExistsError(\n      `A document with number ${document.number} already exists in this location.`\n    );\n  }\n\n  // If we're already in a transaction, use the current one\n  if (this.db.$transaction.isActive) {\n    if (document.id) {\n      await this.db.document.update({\n        where: {\n          document_id: document.id,\n        },\n        data: DocumentMap.toPersistenceUpdate(document),\n      });\n    } else {\n      const createdDocument = await this.db.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n      document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    await this.saveAdditionalAreas(document);\n    await this.saveRevisions(document);\n    await this.saveLinks(document);\n    await this.savePrograms(document);\n  } else {\n    // If no active transaction, create our own\n    await this.db.$transaction(async (tx) => {\n      // ... same code as above\n    });\n  }\n}\n```\n\nAlternatively, you might want to consider modifying your higher-level code to avoid calling save twice. Could you share the use case code where you're using the transaction? That would help provide a more specific solution.\nbut i am not using any transaction inside at the moment\n\n```ts atom-web/src/server/new-structure/application/repositories/document.repo.ts\nimport { accessibleBy } from \"@casl/prisma\";\nimport { Prisma } from \"@prisma/client\";\nimport { inject, injectable } from \"inversify\";\nimport _, { isEmpty } from \"lodash\";\nimport { DBClient } from \"../../../config/database/client\";\nimport { DocumentNumberAlreadyExistsError, EntityNotFoundError } from \"../../../utils/errors\";\nimport { CompanyMap } from \"../../domain/company/company.map\";\nimport { CSIDivisionMap } from \"../../domain/csi-division/csi-division.map\";\nimport { DisciplineMap } from \"../../domain/discipline/discipline.map\";\nimport { DocumentRevisionLinkType } from \"../../domain/document/entities/doc-revision-link.entity\";\nimport { DocRevision } from \"../../domain/document/entities/doc-revision.entity\";\nimport { Document, DocumentProps } from \"../../domain/document/entities/document.entity\";\nimport { File } from \"../../domain/document/entities/file.entity\";\nimport { RevisionStatusType, TRevisionStatusType } from \"../../domain/document/entities/revision-status-type.entity\";\nimport { DocRevisionMap } from \"../../domain/document/mappers/doc-revision.map\";\nimport { DocumentMap } from \"../../domain/document/mappers/document.map\";\nimport { FileMap } from \"../../domain/document/mappers/file.map\";\nimport { IDocumentRepo } from \"../../domain/document/repos/document.repo\";\nimport { ReferencedDocData } from \"../../domain/document/services/document.service\";\nimport { AreaMap } from \"../../domain/location/mappers/area.map\";\nimport { LevelMap } from \"../../domain/location/mappers/level.map\";\nimport { ILocationRepo } from \"../../domain/location/repos/location.repo\";\nimport { PersistedProject, Project } from \"../../domain/project/entities/project.entity\";\nimport {\n  PersistedRequestInstance,\n  RequestInstance,\n} from \"../../domain/request/instance/entities/request-instance.entity\";\nimport { PersistedScope, Scope } from \"../../domain/scope/entities/scope.entity\";\nimport { DocumentPurposeMap } from \"../../domain/settings/document-purpose/map\";\nimport { DocumentTypeMap } from \"../../domain/settings/document-type/map\";\nimport { LocationDocumentPurpose } from \"../../domain/settings/locations/document-purpose/entity\";\nimport { LocationDocumentPurposeMap } from \"../../domain/settings/locations/document-purpose/map\";\nimport { LocationProgramMap } from \"../../domain/settings/locations/program/map\";\nimport { ProgramMap } from \"../../domain/settings/program/map\";\nimport { User } from \"../../domain/user/user.entity\";\nimport { UserMap } from \"../../domain/user/user.map\";\nimport { AuthzService } from \"../../framework/application/authz.service\";\nimport { FilterDTOPrisma } from \"../../framework/application/get-many\";\nimport { PaginatedFilteredDTO, PaginatedFilteredDTOResult } from \"../../framework/application/paginated-filtered-dto\";\nimport { Collection } from \"../../framework/domain/collection\";\nimport { assertPersistency, PersistedEntity } from \"../../framework/domain/entity\";\nimport { BaseRepo } from \"../../framework/infrastructure/base-repo\";\nimport TYPES from \"../../framework/inversify/types\";\nimport { companyQueryInclude } from \"./company.repo\";\nimport { userQueryInclude } from \"./user.repo\";\nimport {\n  DocumentSubmittalCategoryMap,\n  DocumentSubmittalDetailMap,\n  DocumentSubmittalTypeMap,\n} from \"../../domain/settings/locations/document-submittal-metadata/submittal.map\";\nimport { DocumentFieldType, DocumentNumberingScheme } from \"@atom/types\";\n\nexport const getDocumentQueryInclude = (authzService: AuthzService) => {\n  return {\n    document_package_document: true,\n    document_program: true,\n    document_revision: {\n      where: accessibleBy(authzService.getUserAbility(), \"read\").document_revision,\n      include: {\n        project_document_revision: {\n          include: {\n            project: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        scope_document_revision: {\n          include: {\n            scope: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        request_document_revision: {\n          include: {\n            request: {\n              select: {\n                request_form_value: {\n                  select: {\n                    title: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n        document_revision_status: {\n          include: {\n            document_revision_status_type: true,\n          },\n        },\n        file: {\n          select: {\n            extension: true,\n          },\n        },\n        location_document_purpose: {\n          include: {\n            document_purpose: true,\n          },\n        },\n      },\n    },\n    document_additional_area: {\n      select: {\n        area_id: true,\n      },\n    },\n    document_csi_division: true,\n    document_submittal_category: true,\n    document_submittal_type: true,\n    document_submittal_detail: true,\n  } satisfies Prisma.Args<typeof DBClient.document, \"findMany\">[\"include\"];\n};\nconst typeToProperty = {\n  [DocumentFieldType.Type.SITE]: \"siteID\",\n  [DocumentFieldType.Type.BUILDING]: \"buildingID\",\n  [DocumentFieldType.Type.AREA]: \"areaID\",\n  [DocumentFieldType.Type.AREA_DETAIL]: \"areaDetailID\",\n  [DocumentFieldType.Type.LEVEL]: \"levelID\",\n  [DocumentFieldType.Type.PROGRAM]: \"locationProgramIDs\",\n  [DocumentFieldType.Type.TYPE]: \"typeID\",\n  [DocumentFieldType.Type.DISCIPLINE]: \"disciplineID\",\n} as const satisfies Partial<{\n  [key in (typeof DocumentFieldType.Type)[keyof typeof DocumentFieldType.Type]]: string;\n}>;\nconst propertyToColumn = {\n  siteID: \"site_id\",\n  buildingID: \"building_id\",\n  areaID: \"area_id\",\n  areaDetailID: \"area_detail_id\",\n  levelID: \"level_id\",\n  locationProgramIDs: \"document_program\",\n  typeID: \"document_type_id\",\n  disciplineID: \"discipline_id\",\n} as const;\n\nexport type DocumentMetadata = {\n  number: string;\n  buildingID: number;\n  siteID: number | null;\n  areaID: number;\n  areaDetailID: number | null;\n  levelID: number;\n  locationProgramIDs: number[];\n  typeID: number;\n  disciplineID: number;\n  locationDocumentPurposeID: number;\n};\n\n@injectable()\nexport class DocumentRepo extends BaseRepo implements IDocumentRepo {\n  constructor(\n    @inject(TYPES.DBClient) protected readonly db: typeof DBClient,\n    @inject(TYPES.ILocationRepo) protected readonly locationRepo: ILocationRepo,\n    @inject(AuthzService) private readonly authzService: AuthzService,\n    @inject(\"DocumentFilterDTOPrisma\")\n    private readonly filterDTOPrisma: FilterDTOPrisma<DocumentProps>\n  ) {\n    super(db);\n  }\n\n  private readonly baseQuery = { is_deleted: 0 } satisfies Prisma.documentWhereInput;\n\n  async getByID(id: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: id,\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getManyByIDs(ids: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: {\n              in: ids,\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByDocumentNumbers(documentNumbers: string[], locationID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          { location_id: locationID },\n          {\n            document_number: { in: documentNumbers },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByPackageID(packageID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_package_document: {\n              some: {\n                package_id: packageID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByRevisionID(revisionID: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: revisionID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getByRevisionIDs(revisionIDs: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: { in: revisionIDs },\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getMany(paginatedFilteredDTO: PaginatedFilteredDTO<Document>): Promise<PaginatedFilteredDTOResult<Document>> {\n    const { filters, parentEntity, locationID, excludeParentEntity } = paginatedFilteredDTO;\n    const filterQuery = this.filterDTOPrisma.createPrismaQuery(filters.filterDTO);\n    const parentSelect = parentEntity && this.getParentSelect(parentEntity);\n    const excludeParent = excludeParentEntity && this.getParentSelect(excludeParentEntity);\n\n    const query: Prisma.documentWhereInput = {\n      AND: [\n        accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n        this.baseQuery,\n        filterQuery,\n        locationID ? { location_id: locationID } : {},\n        excludeParent\n          ? {\n              document_revision: {\n                some: {\n                  [excludeParent.table_name]: {\n                    none: {\n                      [excludeParent.ref_name]: excludeParent.id,\n                    },\n                  },\n                },\n              },\n            }\n          : {},\n        {\n          OR: [\n            parentSelect\n              ? {\n                  document_revision: {\n                    some: {\n                      [parentSelect.table_name]: {\n                        some: {\n                          [parentSelect.ref_name]: parentSelect.id,\n                        },\n                      },\n                    },\n                  },\n                }\n              : {},\n            filters.scopeIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.scopeIDs,\n                  refName: \"scope_id\",\n                  tableName: \"scope_document_revision\",\n                })\n              : {},\n            filters.requestIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.requestIDs,\n                  refName: \"request_id\",\n                  tableName: \"request_document_revision\",\n                })\n              : {},\n            filters.projectIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.projectIDs,\n                  refName: \"project_id\",\n                  tableName: \"project_document_revision\",\n                })\n              : {},\n          ],\n        },\n      ],\n    };\n\n    let pagination = {};\n\n    if (paginatedFilteredDTO.page && paginatedFilteredDTO.pageSize) {\n      pagination = {\n        take: paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize,\n        skip: (paginatedFilteredDTO.page - 1) * paginatedFilteredDTO.pageSize,\n      };\n    }\n\n    const orderBy = { document_id: \"desc\" } as const;\n    const dbDocumentList = await this.db.document.findMany({\n      where: query,\n      select: { document_id: true },\n      orderBy,\n      take: paginatedFilteredDTO.limit || 1000,\n      skip: \"skip\" in pagination ? (pagination.skip as number) : 0,\n    });\n\n    const count = dbDocumentList.length + (\"skip\" in pagination ? (pagination.skip as number) : 0);\n\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        document_id: {\n          in: dbDocumentList\n            .slice(0, paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize || 10)\n            .map(({ document_id }) => document_id),\n        },\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy,\n    });\n\n    return { result: dbDocuments.map(DocumentMap.toDomain), count };\n  }\n\n  async save(document: Document) {\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation)\n      throw new DocumentNumberAlreadyExistsError(\n        `A document with number ${document.number} already exists in this location.`\n      );\n\n    console.log(\"Saving document !\", document.id);\n    if (document.id) {\n      await this.db.document.update({\n        where: {\n          document_id: document.id,\n        },\n        data: DocumentMap.toPersistenceUpdate(document),\n      });\n\n      await this.updateDocumentCSIDivisions(document.id, document.csiDivisionIDs);\n    } else {\n      const createdDocument = await this.db.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n\n      document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    await this.saveAdditionalAreas(document);\n    await this.saveRevisions(document);\n    await this.saveLinks(document);\n    await this.savePrograms(document);\n  }\n\n  async saveAdditionalAreas(document: Document) {\n    if (document.id) {\n      await this.db.document_additional_area.deleteMany({\n        where: {\n          document_id: document.id,\n        },\n      });\n    }\n\n    if (document.additionalAreaIDs && document.additionalAreaIDs.length > 0) {\n      await this.db.document_additional_area.createMany({\n        data: document.additionalAreaIDs.map((areaID) => ({\n          area_id: areaID,\n          document_id: document.id!,\n        })),\n      });\n    }\n  }\n\n  async saveRevisions(document: Document) {\n    let dbStatuses: { creation_ts: Date; revision_status_id: number }[];\n\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        if (revision.id) {\n          const updateDetails = await this.db.document_revision.update({\n            where: {\n              document_revision_id: revision.id,\n            },\n            data: DocRevisionMap.toPersistence(revision),\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = updateDetails.document_revision_status;\n        } else {\n          const createdRevision = await this.db.document_revision.create({\n            data: {\n              document_id: document.id!,\n              ...DocRevisionMap.toPersistence(revision),\n            },\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = createdRevision.document_revision_status;\n\n          revision.setId(createdRevision.document_revision_id);\n        }\n\n        revision.statuses.forEach((status) => {\n          const updateStatusDetails = dbStatuses.find(\n            (updateStatusDetails) => updateStatusDetails.creation_ts.getTime() === status.creationTs.getTime()\n          );\n\n          updateStatusDetails && status.setId(updateStatusDetails.revision_status_id);\n        });\n      })\n    );\n\n    await Promise.all([this.saveLastStatus(document.lastRevision), this.saveLastRevision(document)]);\n  }\n\n  async saveLastRevision(document: Document) {\n    return this.db.document.update({\n      where: {\n        document_id: document.id,\n      },\n      data: {\n        latest_revision_id: document.lastRevision.id,\n      },\n    });\n  }\n\n  async saveLastStatus(revision: DocRevision) {\n    const statuses = await this.db.document_revision_status.findMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      orderBy: {\n        creation_ts: \"asc\",\n      },\n    });\n\n    if (statuses.at(-1)!.is_last && statuses.slice(0, statuses.length - 1).every((status) => !status.is_last)) {\n      return;\n    }\n\n    await this.db.document_revision_status.updateMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      data: {\n        is_last: false,\n      },\n    });\n\n    await this.db.document_revision_status.update({\n      where: {\n        revision_status_id: statuses.at(-1)!.revision_status_id,\n      },\n      data: {\n        is_last: true,\n      },\n    });\n  }\n\n  private async addDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const addedPrograms = document.locationProgramIDs.added;\n\n    if (_.isEmpty(addedPrograms)) return;\n\n    await this.db.document_program.createMany({\n      data: addedPrograms.map((removedLocationProgramID) => ({\n        document_id: document.id,\n        location_program_id: removedLocationProgramID,\n      })),\n    });\n  }\n\n  private async removeDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const removedPrograms = document.locationProgramIDs.removed;\n\n    if (_.isEmpty(removedPrograms)) return;\n\n    await this.db.document_program.deleteMany({\n      where: {\n        OR: removedPrograms.map((removedProgramID) => ({\n          document_id: document.id,\n          location_program_id: removedProgramID,\n        })),\n      },\n    });\n  }\n\n  private async savePrograms(document: PersistedEntity<Document>) {\n    await this.removeDocumentPrograms(document);\n    await this.addDocumentPrograms(document);\n  }\n\n  // TODO: Only run this function when entity has csi divisions updated (keep track of entity changes locally)\n  private async updateDocumentCSIDivisions(document_id: number, csi_division_ids: Collection<number>): Promise<void> {\n    if (!isEmpty(csi_division_ids.removed)) {\n      await this.db.document_csi_division.deleteMany({\n        where: {\n          document_id,\n          csi_division_id: {\n            in: csi_division_ids.removed,\n          },\n        },\n      });\n    }\n  }\n\n  private async saveLinks(document: Document) {\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        await this.updateLinks(revision);\n        await this.removeLinks(revision);\n        await this.addLinks(revision);\n      })\n    );\n  }\n\n  private async updateLinks(revision: DocRevision): Promise<void> {\n    const links = revision.links.filter((link) => link.didChange);\n\n    if (_.isEmpty(links)) return;\n\n    const scopeLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const requestLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Request);\n\n    await Promise.all([\n      ...scopeLinks.map((scopeLink) =>\n        this.db.scope_document_revision.update({\n          where: {\n            id: scopeLink.id,\n          },\n          data: {\n            is_released: scopeLink.isReleased,\n          },\n        })\n      ),\n      ...requestLinks.map((requestLink) =>\n        this.db.request_document_revision.update({\n          where: {\n            id: requestLink.id,\n          },\n          data: {\n            is_released: requestLink.isReleased,\n          },\n        })\n      ),\n    ]);\n  }\n\n  private async addLinks(revision: DocRevision): Promise<void> {\n    const addedLinks = revision.links.added;\n\n    if (_.isEmpty(addedLinks)) return;\n\n    const addedScopes = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const addedRequests = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Request);\n    const addedProjects = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Project);\n\n    await this.db.document_revision.update({\n      where: { document_revision_id: revision.id },\n      data: {\n        scope_document_revision: {\n          createMany: {\n            data: addedScopes.map((addedScope) => ({\n              scope_id: addedScope.parentID,\n              is_released: addedScope.isReleased,\n              created_by: addedScope.createdBy,\n            })),\n          },\n        },\n        request_document_revision: {\n          createMany: {\n            data: addedRequests.map((addedRequest) => ({\n              request_id: addedRequest.parentID,\n              is_released: addedRequest.isReleased,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n        project_document_revision: {\n          createMany: {\n            data: addedProjects.map((addedRequest) => ({\n              project_id: addedRequest.parentID,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n      },\n    });\n  }\n\n  private async removeLinks(revision: DocRevision): Promise<void> {\n    const removedLinks = revision.links.removed;\n\n    if (_.isEmpty(removedLinks)) return;\n\n    const removedScopes = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Scope);\n    const removedRequests = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Request);\n    const removedProjects = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Project);\n\n    if (!_.isEmpty(removedScopes))\n      await this.db.scope_document_revision.deleteMany({\n        where: {\n          OR: removedScopes.map((removedScope) => ({\n            scope_id: removedScope.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedRequests))\n      await this.db.request_document_revision.deleteMany({\n        where: {\n          OR: removedRequests.map((removedRequest) => ({\n            request_id: removedRequest.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedProjects))\n      await this.db.project_document_revision.deleteMany({\n        where: {\n          OR: removedProjects.map((removedProject) => ({\n            project_id: removedProject.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n  }\n\n  async isDocumentNumberUniqueInLocation(document: Document) {\n    const count = await this.db.document.count({\n      where: {\n        document_number: document.number,\n        location_id: document.locationID,\n        ...(document.id ? { document_id: { notIn: [document.id] } } : {}), // Exclude itself\n      },\n    });\n\n    return count === 0;\n  }\n\n  async delete(document: Document): Promise<void> {\n    if (!document.id) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n    assertPersistency(document);\n\n    const { count } = await this.db.document.updateMany({\n      where: {\n        AND: [this.baseQuery, { document_id: document.id }],\n      },\n      data: {\n        is_deleted: 1,\n      },\n    });\n\n    document.locationProgramIDs.removeAll();\n    await this.savePrograms(document);\n\n    if (!count) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n  }\n\n  async getRevisionStatusTypes(): Promise<RevisionStatusType[]> {\n    const dbStatusTypes = await this.db.document_revision_status_type.findMany();\n    return dbStatusTypes.map((dbStatusType) => RevisionStatusType.create(dbStatusType.type as TRevisionStatusType));\n  }\n\n  public getParentSelect(parentEntity: PersistedScope | PersistedRequestInstance | PersistedProject) {\n    if (parentEntity instanceof Scope) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"scope_id\",\n        table_name: \"scope_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof RequestInstance) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"request_id\",\n        table_name: \"request_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof Project) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"project_id\",\n        table_name: \"project_document_revision\",\n      };\n    }\n\n    throw new Error(\"Invalid parent entity\");\n  }\n\n  public async getDocumentsRefData(documentIDs: number[]) {\n    const dbRefDataDocuments = await this.db.document.findMany({\n      where: {\n        document_id: { in: documentIDs },\n      },\n      include: {\n        site: true,\n        building: true,\n        area: true,\n        area_detail: true,\n        document_additional_area: {\n          include: {\n            area: true,\n          },\n        },\n        location_level: true,\n        document_type: true,\n        discipline: true,\n        document_program: { include: { location_program: { include: { program: true } } } },\n        created_by_user: { include: userQueryInclude },\n        updated_by_user: { include: userQueryInclude },\n        created_by_company_full: { include: companyQueryInclude },\n        updated_by_company_full: { include: companyQueryInclude },\n        document_csi_division: { include: { csi_division: { select: { title: true } } } },\n        document_submittal_category: true,\n        document_submittal_type: true,\n        document_submittal_detail: { include: { document_submittal_type: true } },\n      },\n    });\n\n    const refData: ReferencedDocData = {};\n\n    if (dbRefDataDocuments.length === 0) return refData;\n\n    const programs: Record<number, (typeof programsList)[0]> = {};\n\n    const programsList = await this.locationRepo.getProgramsInLocation(dbRefDataDocuments[0].location_id);\n\n    programsList.forEach((locationProgram) => {\n      programs[locationProgram.program.id] = locationProgram;\n    });\n\n    dbRefDataDocuments.forEach((dbRefDataDocument) => {\n      refData[dbRefDataDocument.document_id] = {\n        type: DocumentTypeMap.toDomain(dbRefDataDocument.document_type),\n        discipline: DisciplineMap.toDomain(dbRefDataDocument.discipline),\n        createdBy: UserMap.toDomain(dbRefDataDocument.created_by_user),\n        updatedBy: dbRefDataDocument.updated_by_user ? UserMap.toDomain(dbRefDataDocument.updated_by_user) : null,\n        site: dbRefDataDocument.site ? AreaMap.toDomain(dbRefDataDocument.site) : null, // TODO: ATOM-3197 - Remove NULL when site is mandatory\n        building: AreaMap.toDomain(dbRefDataDocument.building),\n        area: AreaMap.toDomain(dbRefDataDocument.area),\n        areaDetail: dbRefDataDocument.area_detail ? AreaMap.toDomain(dbRefDataDocument.area_detail) : null,\n        additionalAreas: dbRefDataDocument.document_additional_area.map((additional_area) =>\n          AreaMap.toDomain(additional_area.area)\n        ),\n        level: LevelMap.toDomain(dbRefDataDocument.location_level),\n        programs: dbRefDataDocument.document_program.map(({ location_program }) =>\n          LocationProgramMap.toDomain(location_program, ProgramMap.toDomain(location_program.program), {\n            enabled: true,\n          })\n        ),\n        createdByCompany: CompanyMap.toDomain(dbRefDataDocument.created_by_company_full),\n        updatedByCompany: dbRefDataDocument.updated_by_company_full\n          ? CompanyMap.toDomain(dbRefDataDocument.updated_by_company_full)\n          : null,\n        csiDivisions: dbRefDataDocument.document_csi_division.map((csiDivision) =>\n          CSIDivisionMap.toDomain({ division_id: csiDivision.csi_division_id, title: csiDivision.csi_division.title })\n        ),\n        submittal: {\n          category: dbRefDataDocument.document_submittal_category\n            ? DocumentSubmittalCategoryMap.toDomain(dbRefDataDocument.document_submittal_category)\n            : null,\n          type: dbRefDataDocument.document_submittal_type\n            ? DocumentSubmittalTypeMap.toDomain(dbRefDataDocument.document_submittal_type)\n            : null,\n          detail: dbRefDataDocument.document_submittal_detail\n            ? DocumentSubmittalDetailMap.toDomain(dbRefDataDocument.document_submittal_detail)\n            : null,\n        },\n      };\n    });\n\n    return refData;\n  }\n\n  public async getRevisionsRefData(revisionIDs: number[]) {\n    const dbRefDataRevisions = await this.db.document_revision.findMany({\n      where: {\n        document_revision_id: { in: revisionIDs },\n      },\n      include: {\n        file: true,\n        user: { include: userQueryInclude },\n        location_document_purpose: { include: { document_purpose: true } },\n      },\n    });\n\n    const refData: Record<\n      number,\n      {\n        file: File;\n        createdByUser: PersistedEntity<User>;\n        purposeType: LocationDocumentPurpose;\n      }\n    > = {};\n\n    dbRefDataRevisions.forEach((dbRefDataRevision) => {\n      refData[dbRefDataRevision.document_revision_id] = {\n        file: FileMap.toDomain(dbRefDataRevision.file),\n        createdByUser: UserMap.toDomain(dbRefDataRevision.user),\n        purposeType: LocationDocumentPurposeMap.toDomain(\n          dbRefDataRevision.location_document_purpose,\n          DocumentPurposeMap.toDomain(dbRefDataRevision.location_document_purpose.document_purpose),\n          { enabled: true }\n        ),\n      };\n    });\n\n    return refData;\n  }\n\n  private getParentSelectFromIDs({\n    ids,\n    refName,\n    tableName,\n  }: {\n    ids: number[];\n    refName: string;\n    tableName: string;\n  }): Prisma.documentWhereInput {\n    return {\n      document_revision: {\n        some: {\n          [tableName]: {\n            some: {\n              [refName]: { in: ids },\n            },\n          },\n        },\n      },\n    };\n  }\n\n  private async getMaximumSequenceNumberDocument(\n    document: DocumentMetadata,\n    locationID: number,\n    numberingFormat: DocumentNumberingScheme.DocumentNumberingSegment[]\n  ): Promise<Document | undefined> {\n    const filter: any = {};\n\n    for (const segment of numberingFormat) {\n      if (\n        segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER ||\n        segment.fieldKey === DocumentFieldType.Type.FREE_TEXT ||\n        segment.fieldKey === DocumentFieldType.Type.ORIGINATING_ORGANIZATION\n      ) {\n        continue;\n      }\n      if (segment.fieldKey === DocumentFieldType.Type.PURPOSE) {\n        filter[\"document_revision\"] = {\n          some: {\n            location_document_purpose_id: document.locationDocumentPurposeID,\n          },\n        };\n        continue;\n      }\n      const property = typeToProperty[segment.fieldKey as keyof typeof typeToProperty];\n      if (!property) {\n        throw new Error(`Unsupported numbering scheme segment: ${segment}`);\n      }\n      const column = propertyToColumn[property as keyof typeof propertyToColumn] as string;\n      if (!column) {\n        throw new Error(`Unsupported property: ${property}`);\n      }\n      filter[column] = document[property];\n    }\n\n    const sequenceNumberIndex = numberingFormat.findIndex(\n      (segment) => segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER\n    );\n    const documentNumber = document.number.split(\"-\");\n\n    if (documentNumber[sequenceNumberIndex] === DocumentFieldType.Type.SEQUENCE_NUMBER) {\n      documentNumber[sequenceNumberIndex] = \"%\";\n    }\n\n    const numberingSchemeMatchCondition = {\n      document_number: {\n        contains: documentNumber.join(\"-\"),\n      },\n    };\n\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          filter,\n          numberingSchemeMatchCondition,\n          { location_id: locationID },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy: {\n        sequence_number: \"desc\",\n      },\n    });\n\n    if (!dbDocument) {\n      return undefined;\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getNextSequenceNumber(\n    document: DocumentMetadata,\n    locationID: number,\n    format: DocumentNumberingScheme.DocumentNumberingSegment[],\n    sequenceNumberStart: number\n  ): Promise<number> {\n    const matchingDocument = await this.getMaximumSequenceNumberDocument(document, locationID, format);\n    if (!matchingDocument) {\n      return sequenceNumberStart;\n    }\n    const maxSequenceNumber = matchingDocument.sequenceNumber ?? 0;\n    return Math.max(maxSequenceNumber + 1, sequenceNumberStart);\n  }\n}\n```\n\n\n\nLet's wrap the save method in a transaction to ensure all operations are atomic. This should prevent the primary key conflict error:\n\n```typescript\nasync save(document: Document) {\n  const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n  if (!isDocumentNumberUniqueInLocation)\n    throw new DocumentNumberAlreadyExistsError(\n      `A document with number ${document.number} already exists in this location.`\n    );\n\n  console.log(\"Saving document !\", document.id);\n  \n  await this.db.$transaction(async (tx) => {\n    if (document.id) {\n      await tx.document.update({\n        where: {\n          document_id: document.id,\n        },\n        data: DocumentMap.toPersistenceUpdate(document),\n      });\n\n      await this.updateDocumentCSIDivisions(document.id, document.csiDivisionIDs);\n    } else {\n      const createdDocument = await tx.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n\n      document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    await this.saveAdditionalAreas(document);\n    await this.saveRevisions(document);\n    await this.saveLinks(document);\n    await this.savePrograms(document);\n  });\n}\n```\n\nYou'll also need to modify the helper methods to use the transaction client:\n\n```typescript\nprivate async saveAdditionalAreas(document: Document, tx?: Prisma.TransactionClient) {\n  const client = tx || this.db;\n  // Use client instead of this.db\n  // ...\n}\n\nprivate async saveRevisions(document: Document, tx?: Prisma.TransactionClient) {\n  const client = tx || this.db;\n  // Use client instead of this.db\n  // ...\n}\n\n// Do the same for other helper methods\n```\n\nThis ensures that all database operations within the save method are executed in a single transaction. If any operation fails, all changes will be rolled back.\n\nIf you're still seeing the error, could you share:\n1. The document entity code \n2. The use case code where you're calling save()\n3. The DocumentMap code\n\nThis would help identify if there might be issues with how the document is being prepared or how multiple saves are being triggered.\ni noticed something, this only happens while i run my tests\n\nAh, that's a crucial detail! The issue is likely related to test setup and cleanup. In tests, you might be:\n\n1. Not cleaning up the database between tests\n2. Running tests in parallel which causes conflicts\n3. Using the same document data across different tests\n\nCould you share:\n1. Your test setup\n2. The relevant test file where this error occurs\n3. How you're handling database cleanup between tests\n\nCommon solutions for test-related database issues include:\n\n1. Clear the database before each test:\n```typescript\nbeforeEach(async () => {\n  await db.document.deleteMany();\n  // Clear other related tables\n});\n```\n\n2. Use unique data for each test:\n```typescript\nit('should create a document', async () => {\n  const uniqueNumber = `DOC-${Date.now()}`;\n  const document = Document.create({\n    number: uniqueNumber,\n    // other props\n  });\n  // ...\n});\n```\n\n3. Use transactions in tests:\n```typescript\nit('should create a document', async () => {\n  await db.$transaction(async (tx) => {\n    // Your test code here\n  });\n});\n```\n\n4. If using Jest, configure it to run tests serially:\n```json\n{\n  \"jest\": {\n    \"maxConcurrency\": 1,\n    \"runInBand\": true\n  }\n}\n```\n\nCould you share your test code so we can identify the specific issue?\n\n\n```ts atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/system.test.ts\nimport { DocumentFieldType, DocumentNumberingScheme, Document as DocumentType, Location, Review } from \"@atom/types\";\nimport { StatusCodes } from \"http-status-codes\";\nimport { Id } from \"../../../../../test/mocks/types/common\";\nimport { DocumentMock } from \"../../../../../test/mocks/types/document\";\nimport { createFiles, deleteFiles } from \"../../../../../test/utils/document/test.utils\";\nimport { DocumentTestContext, setupDocumentTestContext, teardownDocumentTestContext } from \"../test/test.context\";\n\nconst { any } = expect;\n\nconst { ACKNOWLEDGE, IGNORE } = Review.AggregationStrategy;\nconst { ALL, FIRST } = Review.ApprovalStrategy;\nconst { PENDING } = Review.Status;\nconst { DOCUMENT } = Location.ReviewDomain;\nconst { FINAL } = Location.DocumentReview.StepStrategy;\n\ndescribe(\"Location Documents - Create Documents\", () => {\n  let ctx: DocumentTestContext;\n  let locationID: number;\n  let documentTypeID: number;\n  let applicationTypeID: number;\n  let scheme: DocumentNumberingScheme.DocumentNumbering;\n  let numberingFormat: DocumentNumberingScheme.DocumentNumberingSegment[];\n  let documentNumber: string;\n\n  beforeAll(async () => {\n    ctx = await setupDocumentTestContext();\n    locationID = ctx.location_id;\n    const documentType = await ctx.admin.settings.documentType.create({\n      name: \"Drawing\",\n    });\n    await ctx.admin.settings.documentType.update(documentType.id, {\n      name: \"Drawing\",\n      abbreviation: `DT${documentType.id}`,\n    });\n\n    await ctx.admin.settings.locations.documentType.update(locationID, documentType.id, {\n      enable: true,\n    });\n    await ctx.admin.settings.locations.documentType.update(locationID, documentType.id, {\n      enable: true,\n      autoNumbering: true,\n    });\n    documentTypeID = documentType.id;\n\n    const applicationType = await ctx.admin.settings.documentType.create({\n      name: \"Application\",\n    });\n    await ctx.admin.settings.documentType.update(applicationType.id, {\n      name: \"Application\",\n      abbreviation: `AP${applicationType.id}`,\n    });\n    await ctx.admin.settings.locations.documentType.update(locationID, applicationType.id, {\n      enable: true,\n    });\n    applicationTypeID = applicationType.id;\n    numberingFormat = [\n      { schemeID: 2, documentFieldTypeID: 1, fieldKey: DocumentFieldType.Type.SITE },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 2,\n        fieldKey: DocumentFieldType.Type.BUILDING,\n      },\n      { schemeID: 2, documentFieldTypeID: 3, fieldKey: DocumentFieldType.Type.AREA },\n      { schemeID: 2, documentFieldTypeID: 9, fieldKey: DocumentFieldType.Type.TYPE },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 13,\n        fieldKey: DocumentFieldType.Type.ORIGINATING_ORGANIZATION,\n      },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 7,\n        fieldKey: DocumentFieldType.Type.PURPOSE,\n      },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 6,\n        fieldKey: DocumentFieldType.Type.SEQUENCE_NUMBER,\n      },\n    ];\n    await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n      numberingFormat: numberingFormat,\n      sequenceNumberLength: 6,\n      sequenceNumberStart: 1,\n    });\n    scheme = (await ctx.admin.settings.locations.documentNumberingScheme.get(ctx.location_id)).documentNumberingScheme;\n    const abbreviation = (\n      await ctx.admin.settings.locations.documentPurpose.list(ctx.location_id)\n    ).locationDocumentPurposes.find((purpose) => purpose.id === ctx.location_document_purpose_id)?.abbreviation;\n    documentNumber = `S1-B1-A1-DT${documentTypeID}-TSLA-${abbreviation}`;\n  });\n\n  afterAll(async () => {\n    await db.settings.locations.documentType.delete(ctx.location_id, documentTypeID);\n    await db.settings.locations.documentType.delete(ctx.location_id, applicationTypeID);\n    await db.settings.documentType.delete(documentTypeID);\n    await db.settings.documentType.delete(applicationTypeID);\n    await db.settings.locations.documentNumberingScheme.delete(ctx.location_id);\n    await teardownDocumentTestContext(ctx);\n  });\n\n  describe(\"create one document\", () => {\n    let fileID: string;\n\n    beforeEach(async () => {\n      fileID = (await createFiles(1, ctx.admin_id))[0];\n    });\n\n    afterEach(async () => {\n      await deleteFiles([fileID]);\n    });\n\n    it(\"creates document\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID })],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(\"id\");\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const { revision } = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(revision.reviewFlow).not.toBeDefined();\n      expect(revision.currentStatus.type).toBe(\"unreviewed\");\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"creates document with sequence number if auto numbering is applied\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `AP-12-AGCB`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(\"id\");\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}-000001`);\n      expect(document.sequenceNumber).toBe(1);\n      await db.document.delete(documentID);\n    });\n\n    it(\"creates document with correct starting sequence number if auto numbering is applied\", async () => {\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: scheme.numberingFormat,\n        sequenceNumberStart: 12,\n        sequenceNumberLength: 4,\n      });\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `AP-12-AGCB`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(`id`);\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}-0012`);\n      expect(document.sequenceNumber).toBe(12);\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: scheme.numberingFormat,\n        sequenceNumberStart: 1,\n        sequenceNumberLength: 6,\n      });\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"does not assign a sequence number if sequence number segment is not included in the scheme\", async () => {\n      numberingFormat.pop();\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: numberingFormat,\n        sequenceNumberLength: 6,\n        sequenceNumberStart: 1,\n      });\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `some_screenshot`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(`id`);\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}`);\n      expect(document.sequenceNumber).toBeUndefined();\n\n      numberingFormat.push({\n        schemeID: 2,\n        documentFieldTypeID: 6,\n        fieldKey: DocumentFieldType.Type.SEQUENCE_NUMBER,\n      });\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: numberingFormat,\n        sequenceNumberLength: 6,\n        sequenceNumberStart: 1,\n      });\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"does not create document with sequence number if auto numbering is disabled\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `${documentNumber}-002`,\n            typeID: applicationTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(`id`);\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}-002`);\n      expect(document.sequenceNumber).toBeUndefined();\n\n      await db.document.delete(documentID);\n    });\n    it(\"creates multiple documents with sequence number if auto numbering is applied\", async () => {\n      const fileIDs = await createFiles(3, ctx.admin_id);\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `screenshot1`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n          DocumentMock({\n            ctx,\n            fileID: fileIDs[0],\n            documentNumber: `screenshot2`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n          DocumentMock({\n            ctx,\n            fileID: fileIDs[1],\n            documentNumber: `screenshot3`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n          DocumentMock({\n            ctx,\n            fileID: fileIDs[2],\n            documentNumber: `screenshot4`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(4);\n      result.documents.forEach((document) => {\n        expect(document).toHaveProperty(\"id\");\n      });\n\n      for (const document of result.documents) {\n        const documentID = (document as { id: number }).id;\n\n        expect(documentID).toBeDefined();\n\n        const fetchedDocument = await ctx.admin.documents.getDocument(locationID, documentID);\n        const sequenceNumber = result.documents.indexOf(document) + 1;\n        const expectedNumber = `${documentNumber}-${String(sequenceNumber).padStart(6, \"0\")}`;\n        expect(fetchedDocument.number).toBe(expectedNumber);\n        expect(fetchedDocument.sequenceNumber).toBe(sequenceNumber);\n\n        await db.document.delete(documentID);\n      }\n      await deleteFiles(fileIDs);\n    });\n\n    it(\"rejects if the area is not in the location\", async () => {\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID, areaID: Id() })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          { error: { details: [\"area\"], message: \"Areas are not part of this location.\", name: \"INVALID_ARGUMENT\" } },\n        ],\n      });\n    });\n\n    it(\"rejects if the level is not in location\", async () => {\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID, levelID: Id() })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          {\n            error: {\n              details: [\"level\"],\n              message: \"Levels are not part of this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n    });\n\n    it(\"rejects if the program is not in location\", async () => {\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID, locationProgramIDs: [Id()] })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          {\n            error: {\n              details: [\"program\"],\n              message: \"Programs are not part of this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n    });\n\n    it(\"rejects if there is already a document with the same file\", async () => {\n      const { documents } = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID })],\n      });\n      const documentID = (documents[0] as { id: number }).id;\n\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          {\n            error: {\n              details: [\"file\"],\n              message: \"A file with the same content already exists in this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"creates document with review flow\", async () => {\n      const team = await ctx.admin.team.create(ctx.location_id, {\n        name: \"Team 1\",\n        members: [{ userID: ctx.user_id, isManager: true, areaDisciplines: [] }],\n      });\n\n      const { id: reviewFlowTemplateID } = await ctx.admin.documentRevisionReviewFlowTemplate.create(\n        ctx.location_id,\n        Review.Template.createSchema.parse({\n          steps: [{ groups: [{ reviewers: [{ userID: ctx.reviewer_id }] }, { reviewers: [{ teamID: team.id }] }] }],\n        })\n      );\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID, reviewFlowTemplateID })],\n      });\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      const getResult = await ctx.admin.documents.getDocument(locationID, documentID);\n\n      expect(getResult.revision.currentStatus.type).toBe(\"in_review\");\n      expect(getResult.revision.reviewFlow).toMatchObject({\n        name: \"Template\",\n        subjectType: Review.Subject.DOCUMENT_REVISION,\n        subjectID: getResult.lastRevision.id,\n        createdByUser: { id: ctx.admin_id },\n        submissionByUser: { id: ctx.admin_id },\n        approvalStrategy: ALL,\n        status: PENDING,\n        steps: [\n          {\n            index: 0,\n            name: \"Step 1\",\n            aggregationStrategy: ACKNOWLEDGE,\n            approvalStrategy: ALL,\n            status: PENDING,\n            groups: [\n              {\n                index: 0,\n                name: \"Group 0\",\n                type: Review.GroupType.GROUP,\n                aggregationStrategy: ACKNOWLEDGE,\n                approvalStrategy: FIRST,\n                status: PENDING,\n                decisions: [\n                  {\n                    reviewer: { id: ctx.reviewer_id },\n                    reviewerAuthority: { type: \"other\" },\n                    status: PENDING,\n                  },\n                ],\n              },\n              {\n                index: 1,\n                name: \"Team 1\",\n                type: Review.GroupType.GROUP,\n                aggregationStrategy: ACKNOWLEDGE,\n                approvalStrategy: FIRST,\n                status: PENDING,\n                decisions: [\n                  {\n                    reviewer: { id: ctx.user_id },\n                    reviewerAuthority: { type: \"other\" },\n                    status: PENDING,\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n      await db.review_template.delete(reviewFlowTemplateID);\n      await db.review_flow.delete(getResult.revision.reviewFlow!.id);\n    });\n\n    it(\"creates document with doc control review step when configured in settings\", async () => {\n      await ctx.admin.location.createLocationDocumentReviewSetting(locationID, {\n        domain: DOCUMENT,\n        option: { DocumentControlReviewRequired: true },\n      });\n\n      const { id: reviewFlowTemplateID } = await ctx.admin.documentRevisionReviewFlowTemplate.create(\n        ctx.location_id,\n        Review.Template.createSchema.parse({\n          steps: [{ groups: [{ authority: \"other\", reviewers: [{ userID: ctx.reviewer_id }] }] }],\n        })\n      );\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID, reviewFlowTemplateID })],\n      });\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      const { revision } = await ctx.admin.documents.getDocument(locationID, documentID);\n\n      expect(revision.reviewFlow).toMatchObject({\n        steps: [\n          {\n            index: 0,\n            name: \"Document Control\",\n            groups: [\n              {\n                name: \"Document Control\",\n                decisions: [\n                  {\n                    reviewer: { id: ctx.docController_id },\n                    reviewerAuthority: { type: \"document_control\" },\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            index: 1,\n            name: \"Step 1\",\n            groups: [\n              {\n                name: \"Group 0\",\n              },\n            ],\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n      await db.review_flow.delete(revision.reviewFlow!.id);\n      await db.location_review_setting.delete(locationID, DOCUMENT);\n      await db.review_template.delete(reviewFlowTemplateID);\n    });\n\n    it(\"creates document with final review step strategy when configured in settings\", async () => {\n      await ctx.admin.location.createLocationDocumentReviewSetting(locationID, {\n        domain: DOCUMENT,\n        option: { DocumentControlReviewRequired: true, ReviewStepStrategy: FINAL },\n      });\n\n      const { id: reviewFlowTemplateID } = await ctx.admin.documentRevisionReviewFlowTemplate.create(\n        ctx.location_id,\n        Review.Template.createSchema.parse({\n          steps: [\n            { index: 0, groups: [{ authority: \"other\", index: 0, reviewers: [{ userID: ctx.reviewer_id }] }] },\n            { index: 1, groups: [{ authority: \"other\", index: 0, reviewers: [{ userID: ctx.creator_id }] }] },\n          ],\n        })\n      );\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID, reviewFlowTemplateID })],\n      });\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      const { revision } = await ctx.admin.documents.getDocument(locationID, documentID);\n\n      expect(revision.reviewFlow).toMatchObject({\n        steps: [\n          {\n            index: 0,\n            aggregationStrategy: ACKNOWLEDGE,\n            name: \"Document Control\",\n            groups: [{ aggregationStrategy: ACKNOWLEDGE }],\n          },\n          {\n            index: 1,\n            aggregationStrategy: IGNORE,\n            name: \"Step 1\",\n            groups: [{ aggregationStrategy: IGNORE }],\n          },\n          {\n            index: 2,\n            aggregationStrategy: ACKNOWLEDGE,\n            name: \"Step 2\",\n            groups: [{ aggregationStrategy: ACKNOWLEDGE }],\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n      await db.review_flow.delete(revision.reviewFlow!.id);\n      await db.location_review_setting.delete(locationID, DOCUMENT);\n      await db.review_template.delete(reviewFlowTemplateID);\n    });\n\n    it(\"creates document with permit\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({ ctx, fileID, permit: { isRequired: true, frequency: \"annually\", number: \"permit 1\" } }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(\"id\");\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const { permit } = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(permit?.isRequired).toBeTrue();\n      expect(permit?.number).toBe(\"permit 1\");\n      expect(permit?.frequency).toBe(\"annually\");\n\n      await db.document.delete(documentID);\n    });\n  });\n\n  describe(\"create multiple documents\", () => {\n    it(\"should create many documents\", async () => {\n      const fileIDs = await createFiles(2, ctx.admin_id);\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID: fileIDs[0] }), DocumentMock({ ctx, fileID: fileIDs[1] })],\n      });\n\n      expect(result).toMatchObject({ documents: [{ id: any(Number) }, { id: any(Number) }] });\n\n      await Promise.all(\n        result.documents\n          .filter((document) => \"id\" in document)\n          .map((document) => db.document.delete((document as { id: number }).id))\n      );\n      await deleteFiles(fileIDs);\n    });\n\n    it(\"should return partial error if one of the documents conflicts with the other\", async () => {\n      const number = `${Id()}`;\n      const fileIDs = await createFiles(2, ctx.admin_id);\n\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [\n          DocumentMock({ ctx, fileID: fileIDs[0], number, revision: \"RRR\" }),\n          DocumentMock({ ctx, fileID: fileIDs[1], number, revision: \"RRR\" }),\n        ],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      const body = (await response.json()) as DocumentType.ResCreateDocuments;\n      expect(body).toMatchObject({\n        documents: [\n          {\n            id: any(Number),\n          },\n          {\n            error: {\n              details: [\"revision\"],\n              message: \"The revision RRR already exists on the document Document 1.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n\n      await Promise.all(\n        body.documents\n          .filter((document) => \"id\" in document)\n          .map((document) => db.document.delete((document as { id: number }).id))\n      );\n      await deleteFiles(fileIDs);\n    });\n\n    it(\"should return partial error if one of the documents contains an invalid argument\", async () => {\n      const fileIDs = await createFiles(2, ctx.admin_id);\n\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID: fileIDs[0] }), DocumentMock({ ctx, fileID: fileIDs[1], areaID: Id() })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      const body = (await response.json()) as DocumentType.ResCreateDocuments;\n      expect(body).toMatchObject({\n        documents: [\n          {\n            id: any(Number),\n          },\n          {\n            error: {\n              details: [\"area\"],\n              message: \"Areas are not part of this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n\n      await Promise.all(\n        body.documents\n          .filter((document) => \"id\" in document)\n          .map((document) => db.document.delete((document as { id: number }).id))\n      );\n      await deleteFiles(fileIDs);\n    });\n  });\n});\n```\n\n\nthis is the test code\n\n```ts atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/system.test.ts\nimport { DocumentFieldType, DocumentNumberingScheme, Document as DocumentType, Location, Review } from \"@atom/types\";\nimport { StatusCodes } from \"http-status-codes\";\nimport { Id } from \"../../../../../test/mocks/types/common\";\nimport { DocumentMock } from \"../../../../../test/mocks/types/document\";\nimport { createFiles, deleteFiles } from \"../../../../../test/utils/document/test.utils\";\nimport { DocumentTestContext, setupDocumentTestContext, teardownDocumentTestContext } from \"../test/test.context\";\n\nconst { any } = expect;\n\nconst { ACKNOWLEDGE, IGNORE } = Review.AggregationStrategy;\nconst { ALL, FIRST } = Review.ApprovalStrategy;\nconst { PENDING } = Review.Status;\nconst { DOCUMENT } = Location.ReviewDomain;\nconst { FINAL } = Location.DocumentReview.StepStrategy;\n\ndescribe(\"Location Documents - Create Documents\", () => {\n  let ctx: DocumentTestContext;\n  let locationID: number;\n  let documentTypeID: number;\n  let applicationTypeID: number;\n  let scheme: DocumentNumberingScheme.DocumentNumbering;\n  let numberingFormat: DocumentNumberingScheme.DocumentNumberingSegment[];\n  let documentNumber: string;\n\n  beforeAll(async () => {\n    ctx = await setupDocumentTestContext();\n    locationID = ctx.location_id;\n    const documentType = await ctx.admin.settings.documentType.create({\n      name: \"Drawing\",\n    });\n    await ctx.admin.settings.documentType.update(documentType.id, {\n      name: \"Drawing\",\n      abbreviation: `DT${documentType.id}`,\n    });\n\n    await ctx.admin.settings.locations.documentType.update(locationID, documentType.id, {\n      enable: true,\n    });\n    await ctx.admin.settings.locations.documentType.update(locationID, documentType.id, {\n      enable: true,\n      autoNumbering: true,\n    });\n    documentTypeID = documentType.id;\n\n    const applicationType = await ctx.admin.settings.documentType.create({\n      name: \"Application\",\n    });\n    await ctx.admin.settings.documentType.update(applicationType.id, {\n      name: \"Application\",\n      abbreviation: `AP${applicationType.id}`,\n    });\n    await ctx.admin.settings.locations.documentType.update(locationID, applicationType.id, {\n      enable: true,\n    });\n    applicationTypeID = applicationType.id;\n    numberingFormat = [\n      { schemeID: 2, documentFieldTypeID: 1, fieldKey: DocumentFieldType.Type.SITE },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 2,\n        fieldKey: DocumentFieldType.Type.BUILDING,\n      },\n      { schemeID: 2, documentFieldTypeID: 3, fieldKey: DocumentFieldType.Type.AREA },\n      { schemeID: 2, documentFieldTypeID: 9, fieldKey: DocumentFieldType.Type.TYPE },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 13,\n        fieldKey: DocumentFieldType.Type.ORIGINATING_ORGANIZATION,\n      },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 7,\n        fieldKey: DocumentFieldType.Type.PURPOSE,\n      },\n      {\n        schemeID: 2,\n        documentFieldTypeID: 6,\n        fieldKey: DocumentFieldType.Type.SEQUENCE_NUMBER,\n      },\n    ];\n    await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n      numberingFormat: numberingFormat,\n      sequenceNumberLength: 6,\n      sequenceNumberStart: 1,\n    });\n    scheme = (await ctx.admin.settings.locations.documentNumberingScheme.get(ctx.location_id)).documentNumberingScheme;\n    const abbreviation = (\n      await ctx.admin.settings.locations.documentPurpose.list(ctx.location_id)\n    ).locationDocumentPurposes.find((purpose) => purpose.id === ctx.location_document_purpose_id)?.abbreviation;\n    documentNumber = `S1-B1-A1-DT${documentTypeID}-TSLA-${abbreviation}`;\n  });\n\n  afterAll(async () => {\n    await db.settings.locations.documentType.delete(ctx.location_id, documentTypeID);\n    await db.settings.locations.documentType.delete(ctx.location_id, applicationTypeID);\n    await db.settings.documentType.delete(documentTypeID);\n    await db.settings.documentType.delete(applicationTypeID);\n    await db.settings.locations.documentNumberingScheme.delete(ctx.location_id);\n    await teardownDocumentTestContext(ctx);\n  });\n\n  describe(\"create one document\", () => {\n    let fileID: string;\n\n    beforeEach(async () => {\n      fileID = (await createFiles(1, ctx.admin_id))[0];\n    });\n\n    afterEach(async () => {\n      await deleteFiles([fileID]);\n    });\n\n    it(\"creates document\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID })],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(\"id\");\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const { revision } = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(revision.reviewFlow).not.toBeDefined();\n      expect(revision.currentStatus.type).toBe(\"unreviewed\");\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"creates document with sequence number if auto numbering is applied\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `AP-12-AGCB`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(\"id\");\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}-000001`);\n      expect(document.sequenceNumber).toBe(1);\n      await db.document.delete(documentID);\n    });\n\n    it(\"creates document with correct starting sequence number if auto numbering is applied\", async () => {\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: scheme.numberingFormat,\n        sequenceNumberStart: 12,\n        sequenceNumberLength: 4,\n      });\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `AP-12-AGCB`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(`id`);\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}-0012`);\n      expect(document.sequenceNumber).toBe(12);\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: scheme.numberingFormat,\n        sequenceNumberStart: 1,\n        sequenceNumberLength: 6,\n      });\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"does not assign a sequence number if sequence number segment is not included in the scheme\", async () => {\n      numberingFormat.pop();\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: numberingFormat,\n        sequenceNumberLength: 6,\n        sequenceNumberStart: 1,\n      });\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `some_screenshot`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(`id`);\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}`);\n      expect(document.sequenceNumber).toBeUndefined();\n\n      numberingFormat.push({\n        schemeID: 2,\n        documentFieldTypeID: 6,\n        fieldKey: DocumentFieldType.Type.SEQUENCE_NUMBER,\n      });\n      await ctx.admin.settings.locations.documentNumberingScheme.updateRaw(ctx.location_id, {\n        numberingFormat: numberingFormat,\n        sequenceNumberLength: 6,\n        sequenceNumberStart: 1,\n      });\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"does not create document with sequence number if auto numbering is disabled\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `${documentNumber}-002`,\n            typeID: applicationTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(`id`);\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const document = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(document.number).toBe(`${documentNumber}-002`);\n      expect(document.sequenceNumber).toBeUndefined();\n\n      await db.document.delete(documentID);\n    });\n    it(\"creates multiple documents with sequence number if auto numbering is applied\", async () => {\n      const fileIDs = await createFiles(3, ctx.admin_id);\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({\n            ctx,\n            fileID,\n            documentNumber: `screenshot1`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n          DocumentMock({\n            ctx,\n            fileID: fileIDs[0],\n            documentNumber: `screenshot2`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n          DocumentMock({\n            ctx,\n            fileID: fileIDs[1],\n            documentNumber: `screenshot3`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n          DocumentMock({\n            ctx,\n            fileID: fileIDs[2],\n            documentNumber: `screenshot4`,\n            typeID: documentTypeID,\n            locationDocumentPurposeID: ctx.location_document_purpose_id,\n          }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(4);\n      result.documents.forEach((document) => {\n        expect(document).toHaveProperty(\"id\");\n      });\n\n      for (const document of result.documents) {\n        const documentID = (document as { id: number }).id;\n\n        expect(documentID).toBeDefined();\n\n        const fetchedDocument = await ctx.admin.documents.getDocument(locationID, documentID);\n        const sequenceNumber = result.documents.indexOf(document) + 1;\n        const expectedNumber = `${documentNumber}-${String(sequenceNumber).padStart(6, \"0\")}`;\n        expect(fetchedDocument.number).toBe(expectedNumber);\n        expect(fetchedDocument.sequenceNumber).toBe(sequenceNumber);\n\n        await db.document.delete(documentID);\n      }\n      await deleteFiles(fileIDs);\n    });\n\n    it(\"rejects if the area is not in the location\", async () => {\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID, areaID: Id() })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          { error: { details: [\"area\"], message: \"Areas are not part of this location.\", name: \"INVALID_ARGUMENT\" } },\n        ],\n      });\n    });\n\n    it(\"rejects if the level is not in location\", async () => {\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID, levelID: Id() })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          {\n            error: {\n              details: [\"level\"],\n              message: \"Levels are not part of this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n    });\n\n    it(\"rejects if the program is not in location\", async () => {\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID, locationProgramIDs: [Id()] })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          {\n            error: {\n              details: [\"program\"],\n              message: \"Programs are not part of this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n    });\n\n    it(\"rejects if there is already a document with the same file\", async () => {\n      const { documents } = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID })],\n      });\n      const documentID = (documents[0] as { id: number }).id;\n\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      await expect(response).toHaveBody({\n        documents: [\n          {\n            error: {\n              details: [\"file\"],\n              message: \"A file with the same content already exists in this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n    });\n\n    it(\"creates document with review flow\", async () => {\n      const team = await ctx.admin.team.create(ctx.location_id, {\n        name: \"Team 1\",\n        members: [{ userID: ctx.user_id, isManager: true, areaDisciplines: [] }],\n      });\n\n      const { id: reviewFlowTemplateID } = await ctx.admin.documentRevisionReviewFlowTemplate.create(\n        ctx.location_id,\n        Review.Template.createSchema.parse({\n          steps: [{ groups: [{ reviewers: [{ userID: ctx.reviewer_id }] }, { reviewers: [{ teamID: team.id }] }] }],\n        })\n      );\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID, reviewFlowTemplateID })],\n      });\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      const getResult = await ctx.admin.documents.getDocument(locationID, documentID);\n\n      expect(getResult.revision.currentStatus.type).toBe(\"in_review\");\n      expect(getResult.revision.reviewFlow).toMatchObject({\n        name: \"Template\",\n        subjectType: Review.Subject.DOCUMENT_REVISION,\n        subjectID: getResult.lastRevision.id,\n        createdByUser: { id: ctx.admin_id },\n        submissionByUser: { id: ctx.admin_id },\n        approvalStrategy: ALL,\n        status: PENDING,\n        steps: [\n          {\n            index: 0,\n            name: \"Step 1\",\n            aggregationStrategy: ACKNOWLEDGE,\n            approvalStrategy: ALL,\n            status: PENDING,\n            groups: [\n              {\n                index: 0,\n                name: \"Group 0\",\n                type: Review.GroupType.GROUP,\n                aggregationStrategy: ACKNOWLEDGE,\n                approvalStrategy: FIRST,\n                status: PENDING,\n                decisions: [\n                  {\n                    reviewer: { id: ctx.reviewer_id },\n                    reviewerAuthority: { type: \"other\" },\n                    status: PENDING,\n                  },\n                ],\n              },\n              {\n                index: 1,\n                name: \"Team 1\",\n                type: Review.GroupType.GROUP,\n                aggregationStrategy: ACKNOWLEDGE,\n                approvalStrategy: FIRST,\n                status: PENDING,\n                decisions: [\n                  {\n                    reviewer: { id: ctx.user_id },\n                    reviewerAuthority: { type: \"other\" },\n                    status: PENDING,\n                  },\n                ],\n              },\n            ],\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n      await db.review_template.delete(reviewFlowTemplateID);\n      await db.review_flow.delete(getResult.revision.reviewFlow!.id);\n    });\n\n    it(\"creates document with doc control review step when configured in settings\", async () => {\n      await ctx.admin.location.createLocationDocumentReviewSetting(locationID, {\n        domain: DOCUMENT,\n        option: { DocumentControlReviewRequired: true },\n      });\n\n      const { id: reviewFlowTemplateID } = await ctx.admin.documentRevisionReviewFlowTemplate.create(\n        ctx.location_id,\n        Review.Template.createSchema.parse({\n          steps: [{ groups: [{ authority: \"other\", reviewers: [{ userID: ctx.reviewer_id }] }] }],\n        })\n      );\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID, reviewFlowTemplateID })],\n      });\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      const { revision } = await ctx.admin.documents.getDocument(locationID, documentID);\n\n      expect(revision.reviewFlow).toMatchObject({\n        steps: [\n          {\n            index: 0,\n            name: \"Document Control\",\n            groups: [\n              {\n                name: \"Document Control\",\n                decisions: [\n                  {\n                    reviewer: { id: ctx.docController_id },\n                    reviewerAuthority: { type: \"document_control\" },\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            index: 1,\n            name: \"Step 1\",\n            groups: [\n              {\n                name: \"Group 0\",\n              },\n            ],\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n      await db.review_flow.delete(revision.reviewFlow!.id);\n      await db.location_review_setting.delete(locationID, DOCUMENT);\n      await db.review_template.delete(reviewFlowTemplateID);\n    });\n\n    it(\"creates document with final review step strategy when configured in settings\", async () => {\n      await ctx.admin.location.createLocationDocumentReviewSetting(locationID, {\n        domain: DOCUMENT,\n        option: { DocumentControlReviewRequired: true, ReviewStepStrategy: FINAL },\n      });\n\n      const { id: reviewFlowTemplateID } = await ctx.admin.documentRevisionReviewFlowTemplate.create(\n        ctx.location_id,\n        Review.Template.createSchema.parse({\n          steps: [\n            { index: 0, groups: [{ authority: \"other\", index: 0, reviewers: [{ userID: ctx.reviewer_id }] }] },\n            { index: 1, groups: [{ authority: \"other\", index: 0, reviewers: [{ userID: ctx.creator_id }] }] },\n          ],\n        })\n      );\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID, reviewFlowTemplateID })],\n      });\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      const { revision } = await ctx.admin.documents.getDocument(locationID, documentID);\n\n      expect(revision.reviewFlow).toMatchObject({\n        steps: [\n          {\n            index: 0,\n            aggregationStrategy: ACKNOWLEDGE,\n            name: \"Document Control\",\n            groups: [{ aggregationStrategy: ACKNOWLEDGE }],\n          },\n          {\n            index: 1,\n            aggregationStrategy: IGNORE,\n            name: \"Step 1\",\n            groups: [{ aggregationStrategy: IGNORE }],\n          },\n          {\n            index: 2,\n            aggregationStrategy: ACKNOWLEDGE,\n            name: \"Step 2\",\n            groups: [{ aggregationStrategy: ACKNOWLEDGE }],\n          },\n        ],\n      });\n\n      await db.document.delete(documentID);\n      await db.review_flow.delete(revision.reviewFlow!.id);\n      await db.location_review_setting.delete(locationID, DOCUMENT);\n      await db.review_template.delete(reviewFlowTemplateID);\n    });\n\n    it(\"creates document with permit\", async () => {\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [\n          DocumentMock({ ctx, fileID, permit: { isRequired: true, frequency: \"annually\", number: \"permit 1\" } }),\n        ],\n      });\n\n      expect(result.documents.length).toBe(1);\n      expect(result.documents[0]).toHaveProperty(\"id\");\n\n      const documentID = (result.documents[0] as { id: number }).id;\n\n      expect(documentID).toBeDefined();\n\n      const { permit } = await ctx.admin.documents.getDocument(locationID, documentID);\n      expect(permit?.isRequired).toBeTrue();\n      expect(permit?.number).toBe(\"permit 1\");\n      expect(permit?.frequency).toBe(\"annually\");\n\n      await db.document.delete(documentID);\n    });\n  });\n\n  describe(\"create multiple documents\", () => {\n    it(\"should create many documents\", async () => {\n      const fileIDs = await createFiles(2, ctx.admin_id);\n\n      const result = await ctx.admin.documents.createDocuments(locationID, {\n        documents: [DocumentMock({ ctx, fileID: fileIDs[0] }), DocumentMock({ ctx, fileID: fileIDs[1] })],\n      });\n\n      expect(result).toMatchObject({ documents: [{ id: any(Number) }, { id: any(Number) }] });\n\n      await Promise.all(\n        result.documents\n          .filter((document) => \"id\" in document)\n          .map((document) => db.document.delete((document as { id: number }).id))\n      );\n      await deleteFiles(fileIDs);\n    });\n\n    it(\"should return partial error if one of the documents conflicts with the other\", async () => {\n      const number = `${Id()}`;\n      const fileIDs = await createFiles(2, ctx.admin_id);\n\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [\n          DocumentMock({ ctx, fileID: fileIDs[0], number, revision: \"RRR\" }),\n          DocumentMock({ ctx, fileID: fileIDs[1], number, revision: \"RRR\" }),\n        ],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      const body = (await response.json()) as DocumentType.ResCreateDocuments;\n      expect(body).toMatchObject({\n        documents: [\n          {\n            id: any(Number),\n          },\n          {\n            error: {\n              details: [\"revision\"],\n              message: \"The revision RRR already exists on the document Document 1.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n\n      await Promise.all(\n        body.documents\n          .filter((document) => \"id\" in document)\n          .map((document) => db.document.delete((document as { id: number }).id))\n      );\n      await deleteFiles(fileIDs);\n    });\n\n    it(\"should return partial error if one of the documents contains an invalid argument\", async () => {\n      const fileIDs = await createFiles(2, ctx.admin_id);\n\n      const response = await ctx.admin.documents.createDocumentsRaw(locationID, {\n        documents: [DocumentMock({ ctx, fileID: fileIDs[0] }), DocumentMock({ ctx, fileID: fileIDs[1], areaID: Id() })],\n      });\n\n      expect(response).toHaveStatusCode(StatusCodes.MULTI_STATUS);\n      const body = (await response.json()) as DocumentType.ResCreateDocuments;\n      expect(body).toMatchObject({\n        documents: [\n          {\n            id: any(Number),\n          },\n          {\n            error: {\n              details: [\"area\"],\n              message: \"Areas are not part of this location.\",\n              name: \"INVALID_ARGUMENT\",\n            },\n          },\n        ],\n      });\n\n      await Promise.all(\n        body.documents\n          .filter((document) => \"id\" in document)\n          .map((document) => db.document.delete((document as { id: number }).id))\n      );\n      await deleteFiles(fileIDs);\n    });\n  });\n});\n```\n\n\nthis is the test code\nI see the issue. In your test, particularly in the test case \"creates multiple documents with sequence number if auto numbering is applied\", you're creating multiple documents in sequence, and the documents are being processed concurrently. This can cause race conditions when generating sequence numbers.\n\nLet's modify the DocumentRepo.save method to handle this properly using transactions:\n\n```typescript\nasync save(document: Document) {\n  const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n  if (!isDocumentNumberUniqueInLocation) {\n    throw new DocumentNumberAlreadyExistsError(\n      `A document with number ${document.number} already exists in this location.`\n    );\n  }\n\n  return this.db.$transaction(async (tx) => {\n    console.log(\"Saving document!\", document.id);\n    \n    if (document.id) {\n      await tx.document.update({\n        where: {\n          document_id: document.id,\n        },\n        data: DocumentMap.toPersistenceUpdate(document),\n      });\n\n      await this.updateDocumentCSIDivisions(document.id, document.csiDivisionIDs);\n    } else {\n      const createdDocument = await tx.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n\n      document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    \n    // Use the transaction client for all subsequent operations\n    await this.saveAdditionalAreas(document, tx);\n    await this.saveRevisions(document, tx);\n    await this.saveLinks(document, tx);\n    await this.savePrograms(document, tx);\n\n    return document;\n  });\n}\n```\n\nAnd modify the helper methods to accept a transaction client:\n\n```typescript\nprivate async saveAdditionalAreas(document: Document, tx?: Prisma.TransactionClient) {\n  const client = tx || this.db;\n  if (document.id) {\n    await client.document_additional_area.deleteMany({\n      where: {\n        document_id: document.id,\n      },\n    });\n  }\n  // ... rest of the method using client instead of this.db\n}\n\nprivate async saveRevisions(document: Document, tx?: Prisma.TransactionClient) {\n  const client = tx || this.db;\n  // ... use client instead of this.db\n}\n\n// Update other helper methods similarly\n```\n\nAlso, consider modifying the test to handle the documents sequentially or add proper cleanup between tests:\n\n```typescript\nit(\"creates multiple documents with sequence number if auto numbering is applied\", async () => {\n  const fileIDs = await createFiles(3, ctx.admin_id);\n  \n  // Create documents sequentially to avoid race conditions\n  const documents = [];\n  for (const [index, fid] of [fileID, ...fileIDs].entries()) {\n    const result = await ctx.admin.documents.createDocuments(locationID, {\n      documents: [\n        DocumentMock({\n          ctx,\n          fileID: fid,\n          documentNumber: `screenshot${index + 1}`,\n          typeID: documentTypeID,\n          locationDocumentPurposeID: ctx.location_document_purpose_id,\n        }),\n      ],\n    });\n    documents.push(result.documents[0]);\n  }\n\n  // Rest of your test...\n});\n```\n\n    \n    \nThis should resolve the primary key conflict by:\n1. Ensuring all document operations are atomic within a transaction\n2. Preventing race conditions during sequence number generation\n3. Using the same transaction client for all related operations\nkk","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1669}}},{"id":{"replica_id":0,"value":237},"start":33245,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1670}}},{"id":{"replica_id":0,"value":238},"start":35104,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1671}}},{"id":{"replica_id":0,"value":276},"start":35123,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1672}}},{"id":{"replica_id":0,"value":277},"start":35124,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1673}}},{"id":{"replica_id":0,"value":298},"start":37385,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1674}}},{"id":{"replica_id":0,"value":299},"start":40009,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1675}}},{"id":{"replica_id":0,"value":511},"start":40139,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1676}}},{"id":{"replica_id":0,"value":512},"start":42374,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1677}}},{"id":{"replica_id":0,"value":649},"start":42430,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1678}}},{"id":{"replica_id":0,"value":650},"start":42431,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1679}}},{"id":{"replica_id":0,"value":721},"start":75478,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1680}}},{"id":{"replica_id":0,"value":722},"start":77614,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1681}}},{"id":{"replica_id":0,"value":971},"start":77675,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1682}}},{"id":{"replica_id":0,"value":1193},"start":103572,"metadata":{"role":"assistant","status":{"Error":"The final message must be from the user. To provide a system prompt, you must provide the system prompt followed by a user prompt."},"timestamp":{"replica_id":0,"value":1683}}},{"id":{"replica_id":0,"value":1194},"start":103573,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1684}}},{"id":{"replica_id":0,"value":1360},"start":128232,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":1685}}},{"id":{"replica_id":0,"value":1361},"start":131541,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1686}}}],"summary":"Document Save Function Issue","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":33047},"icon":"File","label":"atom-web/src/server/new-structure/application/repositories/document.repo.ts","metadata":{"path":"atom-web/src/server/new-structure/application/repositories/document.repo.ts"}},{"range":{"start":42431,"end":75475},"icon":"File","label":"atom-web/src/server/new-structure/application/repositories/document.repo.ts","metadata":{"path":"atom-web/src/server/new-structure/application/repositories/document.repo.ts"}},{"range":{"start":78913,"end":103548},"icon":"File","label":"atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/system.test.ts","metadata":{"path":"atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/system.test.ts"}},{"range":{"start":103573,"end":128208},"icon":"File","label":"atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/system.test.ts","metadata":{"path":"atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/system.test.ts"}}],"thought_process_output_sections":[]}