{"id":"346e3fea-823e-4ce0-8573-a3f1a69aa295","zed":"context","version":"0.4.0","text":"\n\n\n```tsx atom-web/src/browser/components/access-request/request/access-request.page.tsx\nimport React from \"react\";\nimport { Page } from \"~/components/shared/ui/page\";\nimport { Form, FormState } from \"informed\";\nimport { BackButton } from \"~/components/shared/ui/BackButton\";\nimport { PageHeading } from \"~/components/shared/ui/Heading\";\nimport { ZodError } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { toast } from \"~/components/shared/ui/toast\";\nimport { AccessRequestFormValidationSchema } from \"./form-schema\";\nimport { useCreateAccessRequestMutation } from \"../queries\";\nimport { useNavigate } from \"react-router-dom\";\nimport { StickyFooter } from \"~/components/shared/ui/sticky-footer\";\nimport { Button } from \"@tesla/design-system-react\";\nimport { useDebounce } from \"use-debounce\";\nimport { useFilters } from \"../hooks/use-filters\";\nimport { useLocations } from \"~/components/settings/queries\";\nimport { buildOptions } from \"~/util/ref-data\";\nimport { useUser } from \"~/providers/AuthProvider\";\nimport { FormLayout } from \"@tesla/design-system-react\";\nimport { Dropdown, Input, TextArea } from \"@tesla/informed-tds\";\nimport { usePendingRequests } from \"../queries\";\nimport { Icon, Heading } from \"@tesla/design-system-react\";\nimport { iconSuccess } from \"@tesla/design-system-icons\";\n\nexport const AccessRequestPage: React.FC = () => {\n  const navigate = useNavigate();\n  const user = useUser();\n  const createAccessRequestMutation = useCreateAccessRequestMutation();\n  const pendingRequestsQuery = usePendingRequests(1);\n  const hasPendingRequest = pendingRequestsQuery.isSuccess && pendingRequestsQuery.data?.count;\n\n  const { filters, setFilter, page, pageSize } = useFilters();\n  const [debouncedFilters] = useDebounce(filters, 250);\n  const locationsQuery = useLocations({ page, pageSize, ...debouncedFilters });\n  const isLoading = pendingRequestsQuery.isLoading || locationsQuery.isLoading;\n\n  const onCancel = () => {\n    navigate(-1);\n  };\n\n  const onSave = (formState: FormState) => {\n    try {\n      const payload = AccessRequestFormValidationSchema.parse(formState.values);\n\n      createAccessRequestMutation.mutate(\n        { locationID: payload.locationID, input: { justification: payload.justification } },\n        {\n          onSuccess: () => {\n            toast.success({ header: \"Access requested.\" });\n          },\n          onError: (error) => {\n            toast.error({ header: \"Access request failed.\", body: (error as Error).message });\n          },\n        }\n      );\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const validationError = fromZodError(error);\n        toast.error({ header: \"Form validation failed\", body: validationError.toString() });\n      }\n    }\n  };\n\n  if (hasPendingRequest) {\n    return (\n      <Page>\n        <div className=\"flex items-center justify-center h-screen\">\n          <div className=\"text-center flex flex-col justify-center items-center\">\n            <Icon data={iconSuccess} color=\"var(--tds-color-green)\" size=\"xxl\" />\n            <Heading is=\"h2\">Request Sent</Heading>\n            <p>You will receive an email when your request is approved</p>\n          </div>\n        </div>\n      </Page>\n    );\n  }\n\n  return (\n    <Page loading={isLoading}>\n      <BackButton label=\"Back\" />\n\n      <PageHeading className=\"mt-1 mb-6\">Request Access</PageHeading>\n\n      <Form preventEnter onSubmit={onSave} validateOn=\"submit\" autoComplete=\"off\">\n        <FormLayout>\n          {locationsQuery.isSuccess && (\n            <>\n              <FormLayout className=\"max-w-input\">\n                <Input name=\"user\" label=\"User\" defaultValue={user.name} disabled />\n                <Dropdown\n                  autoFocus={true}\n                  name=\"locationID\"\n                  label=\"Location\"\n                  placeholder=\"Select\"\n                  options={buildOptions({\n                    items: locationsQuery.data?.locations,\n                    id: \"location_id\",\n                    label: \"name\",\n                  })}\n                  required\n                  enableSearch\n                  searchProps={{\n                    value: filters.name,\n                    onClear: () => setFilter(\"name\", \"\"),\n                    onChange: (e) => {\n                      setFilter(\"name\", e.target.value);\n                    },\n                    externallyFiltered: true,\n                  }}\n                />\n                <TextArea name=\"justification\" label=\"Justification\" required />\n              </FormLayout>\n            </>\n          )}\n        </FormLayout>\n\n        <StickyFooter>\n          <div className=\"flex gap-3\">\n            <Button type=\"submit\" className=\"w-button\">\n              Apply\n            </Button>\n            <Button type=\"button\" onClick={onCancel} className=\"w-button\" variant=\"secondary\">\n              Cancel\n            </Button>\n          </div>\n        </StickyFooter>\n      </Form>\n    </Page>\n  );\n};\n```\n\nhow can i split this component\n\n# Component Split Recommendation\n\nTo improve the maintainability of the `AccessRequestPage` component, I'd recommend splitting it into smaller, focused components based on responsibilities:\n\n### 1. Main Structure: AccessRequestPage\n```tsx\nimport React from \"react\";\nimport { Page } from \"~/components/shared/ui/page\";\nimport { usePendingRequests } from \"../queries\";\nimport { RequestSentSuccessView } from \"./RequestSentSuccessView\";\nimport { AccessRequestForm } from \"./AccessRequestForm\";\nimport { useLocations } from \"~/components/settings/queries\";\nimport { useDebounce } from \"use-debounce\";\nimport { useFilters } from \"../hooks/use-filters\";\n\nexport const AccessRequestPage: React.FC = () => {\n  const { filters, setFilter, page, pageSize } = useFilters();\n  const [debouncedFilters] = useDebounce(filters, 250);\n  const locationsQuery = useLocations({ page, pageSize, ...debouncedFilters });\n  const pendingRequestsQuery = usePendingRequests(1);\n  \n  const hasPendingRequest = pendingRequestsQuery.isSuccess && pendingRequestsQuery.data?.count;\n  const isLoading = pendingRequestsQuery.isLoading || locationsQuery.isLoading;\n\n  if (hasPendingRequest) {\n    return <RequestSentSuccessView />;\n  }\n\n  return (\n    <Page loading={isLoading}>\n      <AccessRequestForm \n        locationsQuery={locationsQuery} \n        filters={filters} \n        setFilter={setFilter}\n      />\n    </Page>\n  );\n};\n```\n\n### 2. Success State: RequestSentSuccessView\n```tsx\nimport React from \"react\";\nimport { Page } from \"~/components/shared/ui/page\";\nimport { Icon, Heading } from \"@tesla/design-system-react\";\nimport { iconSuccess } from \"@tesla/design-system-icons\";\n\nexport const RequestSentSuccessView: React.FC = () => {\n  return (\n    <Page>\n      <div className=\"flex items-center justify-center h-screen\">\n        <div className=\"text-center flex flex-col justify-center items-center\">\n          <Icon data={iconSuccess} color=\"var(--tds-color-green)\" size=\"xxl\" />\n          <Heading is=\"h2\">Request Sent</Heading>\n          <p>You will receive an email when your request is approved</p>\n        </div>\n      </div>\n    </Page>\n  );\n};\n```\n\n### 3. Form Component: AccessRequestForm\n```tsx\nimport React from \"react\";\nimport { Form, FormState } from \"informed\";\nimport { BackButton } from \"~/components/shared/ui/BackButton\";\nimport { PageHeading } from \"~/components/shared/ui/Heading\";\nimport { useNavigate } from \"react-router-dom\";\nimport { StickyFooter } from \"~/components/shared/ui/sticky-footer\";\nimport { Button, FormLayout } from \"@tesla/design-system-react\";\nimport { Dropdown, Input, TextArea } from \"@tesla/informed-tds\";\nimport { buildOptions } from \"~/util/ref-data\";\nimport { useUser } from \"~/providers/AuthProvider\";\nimport { toast } from \"~/components/shared/ui/toast\";\nimport { ZodError } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { AccessRequestFormValidationSchema } from \"./form-schema\";\nimport { useCreateAccessRequestMutation } from \"../queries\";\n\nexport const AccessRequestForm = ({ locationsQuery, filters, setFilter }) => {\n  const navigate = useNavigate();\n  const user = useUser();\n  const createAccessRequestMutation = useCreateAccessRequestMutation();\n\n  const onCancel = () => {\n    navigate(-1);\n  };\n\n  const onSave = (formState: FormState) => {\n    try {\n      const payload = AccessRequestFormValidationSchema.parse(formState.values);\n\n      createAccessRequestMutation.mutate(\n        { locationID: payload.locationID, input: { justification: payload.justification } },\n        {\n          onSuccess: () => {\n            toast.success({ header: \"Access requested.\" });\n          },\n          onError: (error) => {\n            toast.error({ header: \"Access request failed.\", body: (error as Error).message });\n          },\n        }\n      );\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const validationError = fromZodError(error);\n        toast.error({ header: \"Form validation failed\", body: validationError.toString() });\n      }\n    }\n  };\n\n  return (\n    <>\n      <BackButton label=\"Back\" />\n      <PageHeading className=\"mt-1 mb-6\">Request Access</PageHeading>\n\n      <Form preventEnter onSubmit={onSave} validateOn=\"submit\" autoComplete=\"off\">\n        <FormLayout>\n          {locationsQuery.isSuccess && (\n            <FormLayout className=\"max-w-input\">\n              <Input name=\"user\" label=\"User\" defaultValue={user.name} disabled />\n              <LocationDropdown \n                filters={filters} \n                setFilter={setFilter} \n                locations={locationsQuery.data?.locations} \n              />\n              <TextArea name=\"justification\" label=\"Justification\" required />\n            </FormLayout>\n          )}\n        </FormLayout>\n\n        <FormFooter onCancel={onCancel} />\n      </Form>\n    </>\n  );\n};\n```\n\n### 4. Form Footer: FormFooter\n```tsx\nimport React from \"react\";\nimport { StickyFooter } from \"~/components/shared/ui/sticky-footer\";\nimport { Button } from \"@tesla/design-system-react\";\n\nexport const FormFooter = ({ onCancel }) => (\n  <StickyFooter>\n    <div className=\"flex gap-3\">\n      <Button type=\"submit\" className=\"w-button\">\n        Apply\n      </Button>\n      <Button type=\"button\" onClick={onCancel} className=\"w-button\" variant=\"secondary\">\n        Cancel\n      </Button>\n    </div>\n  </StickyFooter>\n);\n```\n\n### 5. Location Dropdown: LocationDropdown\n```tsx\nimport React from \"react\";\nimport { Dropdown } from \"@tesla/informed-tds\";\nimport { buildOptions } from \"~/util/ref-data\";\n\nexport const LocationDropdown = ({ filters, setFilter, locations }) => (\n  <Dropdown\n    autoFocus={true}\n    name=\"locationID\"\n    label=\"Location\"\n    placeholder=\"Select\"\n    options={buildOptions({\n      items: locations,\n      id: \"location_id\",\n      label: \"name\",\n    })}\n    required\n    enableSearch\n    searchProps={{\n      value: filters.name,\n      onClear: () => setFilter(\"name\", \"\"),\n      onChange: (e) => {\n        setFilter(\"name\", e.target.value);\n      },\n      externallyFiltered: true,\n    }}\n  />\n);\n```\n\nThis approach breaks the component into smaller, focused pieces with clear responsibilities, making it easier to maintain and test. Each component handles a specific part of the UI or logic.\ncan i just move the form outside and keep the footer here\n\n# Simplified Component Split\n\nAbsolutely. Here's a simplified approach that just extracts the form content while keeping the footer in the main component:\n\n### 1. Main Component: AccessRequestPage\n```tsx\nimport React from \"react\";\nimport { Page } from \"~/components/shared/ui/page\";\nimport { Form, FormState } from \"informed\";\nimport { BackButton } from \"~/components/shared/ui/BackButton\";\nimport { PageHeading } from \"~/components/shared/ui/Heading\";\nimport { ZodError } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { AccessRequestFormValidationSchema } from \"./form-schema\";\nimport { useCreateAccessRequestMutation } from \"../queries\";\nimport { useNavigate } from \"react-router-dom\";\nimport { StickyFooter } from \"~/components/shared/ui/sticky-footer\";\nimport { Button } from \"@tesla/design-system-react\";\nimport { useDebounce } from \"use-debounce\";\nimport { useFilters } from \"../hooks/use-filters\";\nimport { useLocations } from \"~/components/settings/queries\";\nimport { usePendingRequests } from \"../queries\";\nimport { Icon, Heading } from \"@tesla/design-system-react\";\nimport { iconSuccess } from \"@tesla/design-system-icons\";\nimport { toast } from \"~/components/shared/ui/toast\";\nimport { AccessRequestFormContent } from \"./AccessRequestFormContent\";\n\nexport const AccessRequestPage: React.FC = () => {\n  const navigate = useNavigate();\n  const createAccessRequestMutation = useCreateAccessRequestMutation();\n  const pendingRequestsQuery = usePendingRequests(1);\n  const hasPendingRequest = pendingRequestsQuery.isSuccess && pendingRequestsQuery.data?.count;\n\n  const { filters, setFilter, page, pageSize } = useFilters();\n  const [debouncedFilters] = useDebounce(filters, 250);\n  const locationsQuery = useLocations({ page, pageSize, ...debouncedFilters });\n  const isLoading = pendingRequestsQuery.isLoading || locationsQuery.isLoading;\n\n  const onCancel = () => {\n    navigate(-1);\n  };\n\n  const onSave = (formState: FormState) => {\n    try {\n      const payload = AccessRequestFormValidationSchema.parse(formState.values);\n\n      createAccessRequestMutation.mutate(\n        { locationID: payload.locationID, input: { justification: payload.justification } },\n        {\n          onSuccess: () => {\n            toast.success({ header: \"Access requested.\" });\n          },\n          onError: (error) => {\n            toast.error({ header: \"Access request failed.\", body: (error as Error).message });\n          },\n        }\n      );\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const validationError = fromZodError(error);\n        toast.error({ header: \"Form validation failed\", body: validationError.toString() });\n      }\n    }\n  };\n\n  if (hasPendingRequest) {\n    return (\n      <Page>\n        <div className=\"flex items-center justify-center h-screen\">\n          <div className=\"text-center flex flex-col justify-center items-center\">\n            <Icon data={iconSuccess} color=\"var(--tds-color-green)\" size=\"xxl\" />\n            <Heading is=\"h2\">Request Sent</Heading>\n            <p>You will receive an email when your request is approved</p>\n          </div>\n        </div>\n      </Page>\n    );\n  }\n\n  return (\n    <Page loading={isLoading}>\n      <BackButton label=\"Back\" />\n\n      <PageHeading className=\"mt-1 mb-6\">Request Access</PageHeading>\n\n      <Form preventEnter onSubmit={onSave} validateOn=\"submit\" autoComplete=\"off\">\n        <AccessRequestFormContent \n          locationsQuery={locationsQuery} \n          filters={filters} \n          setFilter={setFilter} \n        />\n\n        <StickyFooter>\n          <div className=\"flex gap-3\">\n            <Button type=\"submit\" className=\"w-button\">\n              Apply\n            </Button>\n            <Button type=\"button\" onClick={onCancel} className=\"w-button\" variant=\"secondary\">\n              Cancel\n            </Button>\n          </div>\n        </StickyFooter>\n      </Form>\n    </Page>\n  );\n};\n```\n\n### 2. Form Content Component: AccessRequestFormContent.tsx\n```tsx\nimport React from \"react\";\nimport { FormLayout } from \"@tesla/design-system-react\";\nimport { Dropdown, Input, TextArea } from \"@tesla/informed-tds\";\nimport { buildOptions } from \"~/util/ref-data\";\nimport { useUser } from \"~/providers/AuthProvider\";\n\nexport const AccessRequestFormContent = ({ locationsQuery, filters, setFilter }) => {\n  const user = useUser();\n\n  if (!locationsQuery.isSuccess) {\n    return null;\n  }\n\n  return (\n    <FormLayout>\n      <FormLayout className=\"max-w-input\">\n        <Input name=\"user\" label=\"User\" defaultValue={user.name} disabled />\n        <Dropdown\n          autoFocus={true}\n          name=\"locationID\"\n          label=\"Location\"\n          placeholder=\"Select\"\n          options={buildOptions({\n            items: locationsQuery.data?.locations,\n            id: \"location_id\",\n            label: \"name\",\n          })}\n          required\n          enableSearch\n          searchProps={{\n            value: filters.name,\n            onClear: () => setFilter(\"name\", \"\"),\n            onChange: (e) => {\n              setFilter(\"name\", e.target.value);\n            },\n            externallyFiltered: true,\n          }}\n        />\n        <TextArea name=\"justification\" label=\"Justification\" required />\n      </FormLayout>\n    </FormLayout>\n  );\n};\n```\n\nThis approach:\n1. Keeps the page structure, form wrapper, and footer in the main component\n2. Extracts just the form fields to a separate component\n3. Maintains all the business logic in the main component\n4. Simplifies maintenance of the form fields in their own dedicated component\n\nThis is a good balance between keeping the related components together while still breaking down the complex component into more manageable parts.\ncan the filters be inside the form content\n# Updated Component Split with Filters Inside Form Content\n\nYes, you can absolutely move the filters inside the form content component. Here's how that would look:\n\n### 1. Main Component: AccessRequestPage\n```tsx\nimport React from \"react\";\nimport { Page } from \"~/components/shared/ui/page\";\nimport { Form, FormState } from \"informed\";\nimport { BackButton } from \"~/components/shared/ui/BackButton\";\nimport { PageHeading } from \"~/components/shared/ui/Heading\";\nimport { ZodError } from \"zod\";\nimport { fromZodError } from \"zod-validation-error\";\nimport { AccessRequestFormValidationSchema } from \"./form-schema\";\nimport { useCreateAccessRequestMutation } from \"../queries\";\nimport { useNavigate } from \"react-router-dom\";\nimport { StickyFooter } from \"~/components/shared/ui/sticky-footer\";\nimport { Button } from \"@tesla/design-system-react\";\nimport { usePendingRequests } from \"../queries\";\nimport { Icon, Heading } from \"@tesla/design-system-react\";\nimport { iconSuccess } from \"@tesla/design-system-icons\";\nimport { toast } from \"~/components/shared/ui/toast\";\nimport { AccessRequestFormContent } from \"./AccessRequestFormContent\";\n\nexport const AccessRequestPage: React.FC = () => {\n  const navigate = useNavigate();\n  const createAccessRequestMutation = useCreateAccessRequestMutation();\n  const pendingRequestsQuery = usePendingRequests(1);\n  const hasPendingRequest = pendingRequestsQuery.isSuccess && pendingRequestsQuery.data?.count;\n  const isLoading = pendingRequestsQuery.isLoading;\n\n  const onCancel = () => {\n    navigate(-1);\n  };\n\n  const onSave = (formState: FormState) => {\n    try {\n      const payload = AccessRequestFormValidationSchema.parse(formState.values);\n\n      createAccessRequestMutation.mutate(\n        { locationID: payload.locationID, input: { justification: payload.justification } },\n        {\n          onSuccess: () => {\n            toast.success({ header: \"Access requested.\" });\n          },\n          onError: (error) => {\n            toast.error({ header: \"Access request failed.\", body: (error as Error).message });\n          },\n        }\n      );\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const validationError = fromZodError(error);\n        toast.error({ header: \"Form validation failed\", body: validationError.toString() });\n      }\n    }\n  };\n\n  if (hasPendingRequest) {\n    return (\n      <Page>\n        <div className=\"flex items-center justify-center h-screen\">\n          <div className=\"text-center flex flex-col justify-center items-center\">\n            <Icon data={iconSuccess} color=\"var(--tds-color-green)\" size=\"xxl\" />\n            <Heading is=\"h2\">Request Sent</Heading>\n            <p>You will receive an email when your request is approved</p>\n          </div>\n        </div>\n      </Page>\n    );\n  }\n\n  return (\n    <Page loading={isLoading}>\n      <BackButton label=\"Back\" />\n\n      <PageHeading className=\"mt-1 mb-6\">Request Access</PageHeading>\n\n      <Form preventEnter onSubmit={onSave} validateOn=\"submit\" autoComplete=\"off\">\n        <AccessRequestFormContent />\n\n        <StickyFooter>\n          <div className=\"flex gap-3\">\n            <Button type=\"submit\" className=\"w-button\">\n              Apply\n            </Button>\n            <Button type=\"button\" onClick={onCancel} className=\"w-button\" variant=\"secondary\">\n              Cancel\n            </Button>\n          </div>\n        </StickyFooter>\n      </Form>\n    </Page>\n  );\n};\n```\n\n### 2. Form Content Component with Filters: AccessRequestFormContent.tsx\n```tsx\nimport React from \"react\";\nimport { FormLayout } from \"@tesla/design-system-react\";\nimport { Dropdown, Input, TextArea } from \"@tesla/informed-tds\";\nimport { buildOptions } from \"~/util/ref-data\";\nimport { useUser } from \"~/providers/AuthProvider\";\nimport { useFilters } from \"../hooks/use-filters\";\nimport { useDebounce } from \"use-debounce\";\nimport { useLocations } from \"~/components/settings/queries\";\n\nexport const AccessRequestFormContent = () => {\n  const user = useUser();\n  const { filters, setFilter, page, pageSize } = useFilters();\n  const [debouncedFilters] = useDebounce(filters, 250);\n  const locationsQuery = useLocations({ page, pageSize, ...debouncedFilters });\n  const isLoading = locationsQuery.isLoading;\n\n  if (isLoading) {\n    return <div>Loading locations...</div>;\n  }\n\n  if (!locationsQuery.isSuccess) {\n    return null;\n  }\n\n  return (\n    <FormLayout>\n      <FormLayout className=\"max-w-input\">\n        <Input name=\"user\" label=\"User\" defaultValue={user.name} disabled />\n        <Dropdown\n          autoFocus={true}\n          name=\"locationID\"\n          label=\"Location\"\n          placeholder=\"Select\"\n          options={buildOptions({\n            items: locationsQuery.data?.locations,\n            id: \"location_id\",\n            label: \"name\",\n          })}\n          required\n          enableSearch\n          searchProps={{\n            value: filters.name,\n            onClear: () => setFilter(\"name\", \"\"),\n            onChange: (e) => {\n              setFilter(\"name\", e.target.value);\n            },\n            externallyFiltered: true,\n          }}\n        />\n        <TextArea name=\"justification\" label=\"Justification\" required />\n      </FormLayout>\n    </FormLayout>\n  );\n};\n```\n\n### Benefits of this approach:\n\n1. The form content component is now self-contained - it manages its own data fetching and filtering\n2. The main component is simplified as it no longer needs to manage or pass filter state\n3. The separation of concerns is clearer - the main page handles form submission, navigation, and showing the success state, while the form content handles displaying and filtering the form fields\n4. The loading state for the locations can be handled directly within the form component rather than affecting the entire page\n\nThis approach makes the component more modular and independent, which is a good practice for reusability and maintenance.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":218}}},{"id":{"replica_id":0,"value":19},"start":5005,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":219}}},{"id":{"replica_id":0,"value":20},"start":11250,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":220}}},{"id":{"replica_id":0,"value":84},"start":11309,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":221}}},{"id":{"replica_id":0,"value":85},"start":17021,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":222}}},{"id":{"replica_id":0,"value":152},"start":17064,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":223}}},{"id":{"replica_id":0,"value":153},"start":22968,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":224}}}],"summary":"React Component Refactoring Strategy","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":4972},"icon":"File","label":"atom-web/src/browser/components/access-request/request/access-request.page.tsx","metadata":{"path":"atom-web/src/browser/components/access-request/request/access-request.page.tsx"}}]}