{"id":"d977f0bb-aa87-4d88-88c5-4ea1780fb571","zed":"context","version":"0.4.0","text":"\n\n\n```ts atom-web/src/server/settings/locations/permissions/permissions.system.test.ts\nimport { StatusCodes } from \"http-status-codes\";\nimport { Location, User } from \"@atom/types\";\nimport { Api } from \"../../../test/system/api\";\nimport { TestContext, setupTestContext, teardownTestContext } from \"../../../test/system/context/test.context\";\nimport { anticipateConsoleErrorMessage } from \"../../../test/system/utils\";\n\ndescribe(\"permissions\", () => {\n  let ctx: TestContext;\n  let locationAdminID: User.ID;\n  let locationAdmin: Api;\n  let documentControlID: User.ID;\n  let documentControl: Api;\n\n  beforeAll(async () => {\n    ctx = await setupTestContext();\n  });\n\n  afterAll(async () => {\n    await teardownTestContext(ctx);\n  });\n\n  beforeEach(async () => {\n    locationAdminID = (\n      await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { roles: [\"Location Admin\"], location_id: ctx.location_id }\n      )\n    ).user_id;\n\n    locationAdmin = new Api(await login(locationAdminID));\n\n    documentControlID = (\n      await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { roles: [\"Document Control\"], location_id: ctx.location_id }\n      )\n    ).user_id;\n\n    documentControl = new Api(await login(documentControlID));\n  });\n\n  afterEach(async () => {\n    await db.user.delete(locationAdminID);\n    await db.user.delete(documentControlID);\n  });\n\n  describe(\"Add roles\", () => {\n    it(\"should allow an admin to add location admin user role\", async () => {\n      const input = { new_user_id: documentControlID, role_id: User.UserRoleType.LocationAdmin };\n      const response = await ctx.admin.permissions.createUserRoleRaw(ctx.location_id, input);\n      expect(response.status).toBe(StatusCodes.OK);\n    });\n\n    it(\"should not allow a location admin to assign admin user role\", async () => {\n      anticipateConsoleErrorMessage(\"You are not allowed to perform this action\");\n      const input = { new_user_id: documentControlID, role_id: User.UserRoleType.Admin };\n      const response = await locationAdmin.permissions.createUserRoleRaw(ctx.location_id, input);\n      expect(response.status).toBe(StatusCodes.FORBIDDEN);\n    });\n\n    it(\"should allow document control to add non-admin user roles\", async () => {\n      const input = { new_user_id: locationAdminID, role_id: User.UserRoleType.ConstructionManager };\n      const response = await documentControl.permissions.createUserRoleRaw(ctx.location_id, input);\n      expect(response.status).toBe(StatusCodes.OK);\n    });\n\n    it(\"should not allow a document control to add admin user role\", async () => {\n      anticipateConsoleErrorMessage(\"You are not allowed to perform this action\");\n      const input = { new_user_id: locationAdminID, role_id: User.UserRoleType.Admin };\n      const response = await documentControl.permissions.createUserRoleRaw(ctx.location_id, input);\n      expect(response.status).toBe(StatusCodes.FORBIDDEN);\n    });\n\n    it(\"should not allow a document control to add location admin user role\", async () => {\n      anticipateConsoleErrorMessage(\"You are not allowed to perform this action\");\n      const input = { new_user_id: locationAdminID, role_id: User.UserRoleType.LocationAdmin };\n      const response = await documentControl.permissions.createUserRoleRaw(ctx.location_id, input);\n      expect(response.status).toBe(StatusCodes.FORBIDDEN);\n    });\n  });\n\n  describe(\"revoke access\", () => {\n    it(\"should allow admins to revoke location admin access\", async () => {\n      const input = { location_id: ctx.location_id, new_user_id: locationAdminID };\n      const response = await ctx.admin.permissions.revokeLocationAccessRaw(input);\n      expect(response.status).toBe(StatusCodes.NO_CONTENT);\n    });\n\n    it(\"should not allow location admins to revoke admin access\", async () => {\n      anticipateConsoleErrorMessage(\"You are not allowed to perform this action\");\n      const input = { location_id: ctx.location_id, new_user_id: ctx.admin_id };\n      const response = await locationAdmin.permissions.revokeLocationAccessRaw(input);\n      expect(response.status).toBe(StatusCodes.FORBIDDEN);\n    });\n\n    it(\"should allow document control to revoke non admin access\", async () => {\n      const ConstructionManager = await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { roles: [\"Construction Manager\"], location_id: ctx.location_id }\n      );\n\n      const input = { location_id: ctx.location_id, new_user_id: ConstructionManager.user_id };\n      const response = await documentControl.permissions.revokeLocationAccessRaw(input);\n      expect(response.status).toBe(StatusCodes.NO_CONTENT);\n      await db.user.delete(ConstructionManager.user_id);\n    });\n\n    it(\"should not allow document control to revoke admin access\", async () => {\n      anticipateConsoleErrorMessage(\"You are not allowed to perform this action\");\n      const input = { location_id: ctx.location_id, new_user_id: locationAdminID };\n      const response = await documentControl.permissions.revokeLocationAccessRaw(input);\n      expect(response.status).toBe(StatusCodes.FORBIDDEN);\n    });\n\n    it(\"should not allow a document control user role to be revoked, if it is the last in the location\", async () => {\n      anticipateConsoleErrorMessage(\"You are not allowed to perform this action\");\n      const domain = Location.ReviewDomain.DOCUMENT;\n      await documentControl.settings.locations.documentReviewSetting.create(ctx.location_id, {\n        domain,\n        option: { DocumentControlReviewRequired: true },\n      });\n\n      const input = { location_id: ctx.location_id, new_user_id: locationAdminID };\n      const response = await documentControl.permissions.revokeLocationAccessRaw(input);\n      expect(response.status).toBe(StatusCodes.FORBIDDEN);\n      await db.location_review_setting.delete(ctx.location_id, domain);\n    });\n  });\n\n  describe(\"access requests\", () => {\n    let regularUserID: User.ID;\n    let regularUser: Api;\n\n    beforeEach(async () => {\n      regularUserID = (await db.user.create({ l360_trt_id: ctx.l360_trt_id }, { location_id: ctx.location_id }))\n        .user_id;\n\n      regularUser = new Api(await login(regularUserID));\n    });\n\n    afterEach(async () => {\n      await db.user.delete(regularUserID);\n    });\n\n    it(\"should allow a user to request access\", async () => {\n      const input = { justification: \"Testing access request\" };\n      const response = await regularUser.permissions.requestAccessRaw(ctx.location_id, input);\n\n      expect(response.status).toBe(StatusCodes.CREATED);\n    });\n\n    it(\"should allow a user to get the pending access request\", async () => {\n      const requestInput = { justification: \"Testing access request\" };\n      await regularUser.permissions.requestAccessRaw(ctx.location_id, requestInput);\n\n      const response = await regularUser.permissions.getPendingAccessRequest(ctx.location_id);\n\n      expect(response.count).toBe(1);\n    });\n\n    it(\"should allow location admin to get all access requests\", async () => {\n      const requestInput = { justification: \"Testing access request\" };\n\n      await regularUser.permissions.requestAccessRaw(ctx.location_id, requestInput);\n      const response = await locationAdmin.permissions.getAccessRequestsRaw(ctx.location_id);\n\n      expect(response.status).toBe(StatusCodes.OK);\n    });\n\n    it(\"should allow location admin to approve a access request\", async () => {\n      const requestInput = { justification: \"Testing access request\" };\n      await regularUser.permissions.requestAccessRaw(ctx.location_id, requestInput);\n\n      const requests = await locationAdmin.permissions.getAccessRequests(ctx.location_id);\n      const requestId = requests.find((r) => r.user_id === regularUserID)?.id;\n\n      expect(requestId).toBeDefined();\n\n      const approveInput = { role_id: User.UserRoleType.ConstructionManager, justification: \"Approve access request\" };\n      const response = await locationAdmin.permissions.approveAccessRequestRaw(\n        ctx.location_id,\n        requestId!,\n        approveInput\n      );\n\n      expect(response.status).toBe(StatusCodes.NO_CONTENT);\n\n      // Verify request is no longer pending\n      const updatedRequests = await locationAdmin.permissions.getAccessRequests(ctx.location_id);\n      const rejectedRequest = updatedRequests.find((r) => r.id === requestId);\n      expect(rejectedRequest).toBeUndefined();\n    });\n\n    it(\"should allow location admin to reject a access request\", async () => {\n      const requestInput = { justification: \"Testing access request\" };\n      await regularUser.permissions.requestAccessRaw(ctx.location_id, requestInput);\n\n      const requests = await locationAdmin.permissions.getAccessRequests(ctx.location_id);\n      const requestId = requests.find((r) => r.user_id === regularUserID)?.id;\n\n      expect(requestId).toBeDefined();\n\n      const rejectInput = { justification: \"Reject access request\" };\n      const response = await locationAdmin.permissions.rejectAccessRequestRaw(ctx.location_id, requestId!, rejectInput);\n\n      expect(response.status).toBe(StatusCodes.NO_CONTENT);\n\n      // Verify request is no longer pending\n      const updatedRequests = await locationAdmin.permissions.getAccessRequests(ctx.location_id);\n      const rejectedRequest = updatedRequests.find((r) => r.id === requestId);\n      expect(rejectedRequest).toBeUndefined();\n    });\n  });\n});\n```\n\n```ts atom-web/src/server/settings/locations/permissions/permissions.service.ts\nimport { User } from \"@atom/types\";\nimport { Prisma } from \"@prisma/client\";\nimport { DBClient, DBTransaction, transaction } from \"../../../config/database/client\";\nimport { getBaseURL } from \"../../../config/env\";\nimport ReviewFlowService from \"../../../review-flows/review-flow.service\";\nimport ScopeReadService from \"../../../scope/scope-read.service\";\nimport UserService from \"../../../settings/users/users.service\";\nimport { invalidateSessionsPermissions } from \"../../../utils/authentication/sessions\";\nimport AuthorizedService, { AbilityContainer, authorized } from \"../../../utils/authorization/AuthorizedService\";\nimport { buildPagination } from \"../../../utils/database/pagination\";\nimport { sendEmail } from \"../../../utils/emails\";\nimport { SimpleEmail } from \"../../../utils/emails/emails.simple.model\";\nimport logger from \"../../../utils/loggers/logger\";\nimport LocationService from \"../../locations/location.service\";\nimport { getAddRoleChecker, getRemoveRoleChecker } from \"./role-checkers/role-checker-factory\";\nimport { ForbiddenError } from \"server/utils/errors\";\n\nconst { user_role: UserRole, role: Role } = DBClient;\n\nexport default class PermissionsService extends AuthorizedService {\n  private userService: UserService;\n  private locationService: LocationService;\n\n  constructor(abilityContainer: AbilityContainer) {\n    super(abilityContainer);\n\n    this.userService = new UserService(abilityContainer);\n    this.locationService = new LocationService(abilityContainer);\n  }\n\n  @authorized(\"read\", \"location_settings\")\n  public async getTeslaUsers({\n    name,\n    locationID,\n    page,\n    pageSize,\n  }: {\n    name: string | undefined;\n    locationID: number;\n    page: number;\n    pageSize: number;\n  }) {\n    const userQueryFilter: Prisma.new_userWhereInput[] = [\n      {\n        user_role: {\n          some: {\n            location_id: locationID,\n          },\n        },\n        tesla_user_id: { not: null },\n      },\n    ];\n\n    const nameFilter = name?.trim();\n\n    if (nameFilter) {\n      userQueryFilter.push({\n        OR: [{ name: { contains: nameFilter } }, { email: { contains: nameFilter } }],\n      });\n    }\n\n    const [users, count] = await Promise.all([\n      DBClient.new_user.findMany({\n        ...buildPagination({ page, pageSize }),\n        where: { AND: userQueryFilter },\n        orderBy: {\n          name: \"asc\",\n        },\n        include: {\n          tesla_user: true,\n          user_role: {\n            where: { location_id: locationID },\n            include: {\n              role: true,\n            },\n          },\n        },\n      }),\n      DBClient.new_user.count({\n        where: { AND: userQueryFilter },\n      }),\n    ]);\n\n    return {\n      users,\n      count,\n    };\n  }\n\n  @authorized(\"create\", \"location_settings\")\n  public async createUserRoles({\n    userID,\n    locationID,\n    roles,\n    reviewFlowService,\n    scopeReadService,\n    tx,\n  }: {\n    userID: User.ID;\n    locationID: number;\n    roles: number[];\n    reviewFlowService: ReviewFlowService;\n    scopeReadService: ScopeReadService;\n    tx?: DBTransaction;\n  }) {\n    await Promise.all(roles.map((userRoleID) => this.canUserAddRole(userRoleID, locationID)));\n\n    await this.validateRoles(userID, roles);\n\n    return transaction(async (tx) => {\n      await tx.user_role.createMany({\n        data: roles.map((role) => ({\n          role_id: role,\n          location_id: locationID,\n          new_user_id: userID,\n        })),\n      });\n\n      await invalidateSessionsPermissions([userID]);\n\n      await Promise.all(\n        roles.map((roleID) =>\n          reviewFlowService.addDocControlReviewers(locationID, userID, roleID, scopeReadService, tx)\n        )\n      );\n    }, tx);\n  }\n\n  private async validateRoles(userID: User.ID, roleIDs: number[]) {\n    const [user, roles] = await Promise.all([\n      this.userService.getUserById(userID),\n      Role.findMany({ where: { role_id: { in: roleIDs } } }),\n    ]);\n\n    const areAllRolesInternal = roles.every((role) => role.user_type === \"internal\");\n    const areAllRolesExternal = roles.every((role) => role.user_type === \"external\");\n    const isInternalUser = user.isInternal;\n\n    if (!areAllRolesInternal && !areAllRolesExternal) {\n      throw new ForbiddenError(\"All roles has to be either internal or external\");\n    }\n\n    if (isInternalUser && areAllRolesExternal) {\n      throw new ForbiddenError(\"Internal user cannot be assigned external roles\");\n    }\n\n    if (!isInternalUser && areAllRolesInternal) {\n      throw new ForbiddenError(\"External user cannot be assigned internal roles\");\n    }\n  }\n\n  @authorized(\"update\", \"scope\")\n  public async createScopesUserRoles({\n    userID,\n    scopeIDs,\n    roles,\n    tx,\n  }: {\n    userID: User.ID;\n    scopeIDs: number[];\n    roles: number[];\n    tx?: DBTransaction;\n  }) {\n    return transaction(async (tx) => {\n      await tx.user_role.createMany({\n        data: scopeIDs.flatMap((scopeID) =>\n          roles.map((role) => ({\n            role_id: role,\n            scope_id: scopeID,\n            new_user_id: userID,\n          }))\n        ),\n        skipDuplicates: true,\n      });\n\n      await invalidateSessionsPermissions([userID]);\n    }, tx);\n  }\n\n  @authorized(\"read\", \"settings\")\n  public async getAllRoles() {\n    return Role.findMany({\n      where: {\n        level: \"location\",\n      },\n      orderBy: {\n        name: \"asc\",\n      },\n    });\n  }\n\n  public async canUserRemoveRole(userRoleID: number, locationID: number) {\n    const userRole = await UserRole.findFirstOrThrow({\n      where: { user_role_id: userRoleID },\n      include: { role: { select: { role_id: true, name: true } } },\n    });\n    const roleChecker = getRemoveRoleChecker(this.abilityContainer, userRole.role.name);\n    await roleChecker.checkRole(userRole.role, locationID);\n    return userRole;\n  }\n\n  public async canUserAddRole(roleID: number, locationID: number): Promise<void> {\n    const role = await Role.findFirstOrThrow({ where: { role_id: roleID } });\n    const roleChecker = getAddRoleChecker(this.abilityContainer, role.name);\n    await roleChecker.checkRole(role, locationID);\n  }\n\n  @authorized(\"delete\", \"location_settings\")\n  public async deleteUserRole(\n    userRoleID: number,\n    locationID: number,\n    reviewFlowService: ReviewFlowService,\n    scopeReadService: ScopeReadService\n  ) {\n    const userRole = await this.canUserRemoveRole(userRoleID, locationID);\n    return transaction(async (tx) => {\n      await tx.user_role.delete({\n        where: {\n          user_role_id: userRoleID,\n        },\n      });\n\n      await invalidateSessionsPermissions([User.createUserID(userRole.new_user_id)]);\n\n      await reviewFlowService.removeDocControlReviewers(\n        locationID,\n        User.createUserID(userRole.new_user_id),\n        userRole.role_id,\n        scopeReadService,\n        tx\n      );\n    });\n  }\n\n  @authorized(\"read\", \"user\")\n  public async getRolesByUserID(userID: User.ID) {\n    return UserRole.findMany({\n      where: {\n        new_user_id: userID,\n      },\n      include: {\n        role: true,\n      },\n    });\n  }\n\n  @authorized(\"delete\", \"location_settings\")\n  public async revokeLocationAccess(\n    userID: User.ID,\n    locationID: number,\n    reviewFlowService: ReviewFlowService,\n    scopeReadService: ScopeReadService\n  ) {\n    const userRoles = await this.getRolesByUserID(userID);\n\n    await Promise.all(userRoles.map((userRole) => this.canUserRemoveRole(userRole.user_role_id, locationID)));\n\n    return transaction(async (tx) => {\n      await tx.user_role.deleteMany({ where: { new_user_id: userID, location_id: locationID } });\n\n      await invalidateSessionsPermissions([userID]);\n\n      await Promise.all(\n        userRoles.map(\n          async (userRole) =>\n            await reviewFlowService.removeDocControlReviewers(\n              locationID,\n              userID,\n              userRole.role_id,\n              scopeReadService,\n              tx\n            )\n        )\n      );\n    });\n  }\n\n  @authorized(\"update\", \"scope\")\n  public async revokeScopesAccess({\n    userID,\n    scopeIDs,\n    tx,\n  }: {\n    userID: User.ID;\n    scopeIDs: number[];\n    tx?: DBTransaction;\n  }) {\n    return transaction(async (tx) => {\n      const result = await tx.user_role.deleteMany({ where: { new_user_id: userID, scope_id: { in: scopeIDs } } });\n\n      await invalidateSessionsPermissions([userID]);\n      logger.info(`${result.count} supplier user scopes deleted for user_id: ${userID} and scope_ids: ${scopeIDs}`);\n    }, tx);\n  }\n\n  @authorized(\"read\", \"settings\")\n  public async getActiveTeslaUsersWithRole({ locationID, roleID }: { locationID: number; roleID: number }) {\n    const userRoles = await UserRole.findMany({\n      where: {\n        role_id: roleID,\n        location_id: locationID,\n        new_user: {\n          tesla_user: {\n            is_active: 1,\n          },\n        },\n      },\n      include: {\n        new_user: {\n          include: {\n            tesla_user: true,\n          },\n        },\n      },\n    });\n\n    return userRoles.map((u) => ({ id: u.new_user_id, name: u.new_user.name }));\n  }\n\n  public async getPendingAccessRequest(userID: User.ID, locationID?: number) {\n    return DBClient.access_request.findFirst({\n      where: {\n        user_id: userID,\n        location_id: locationID,\n        status: \"pending\",\n      },\n    });\n  }\n\n  public async requestAccess(userID: User.ID, locationID: number, justification: string) {\n    await DBClient.access_request.create({\n      data: {\n        user_id: userID,\n        created_by: userID,\n        location_id: locationID,\n        request_justification: justification,\n      },\n    });\n\n    await this.notifyAccessRequested({ userID, locationID, justification });\n  }\n\n  @authorized(\"create\", \"location_settings\")\n  public async getAccessRequests({ locationID, name }: { locationID: number; name?: string }) {\n    const accessRequestQueryFilter: Prisma.access_requestWhereInput[] = [\n      {\n        location_id: locationID,\n        status: \"pending\",\n      },\n    ];\n\n    const nameFilter = name?.trim();\n\n    if (nameFilter) {\n      accessRequestQueryFilter.push({\n        OR: [{ new_user: { name: { contains: nameFilter } } }, { new_user: { email: { contains: nameFilter } } }],\n      });\n    }\n\n    return DBClient.access_request.findMany({\n      where: { AND: accessRequestQueryFilter },\n      include: {\n        new_user: {\n          include: {\n            tesla_user: true,\n          },\n        },\n      },\n    });\n  }\n\n  @authorized(\"create\", \"location_settings\")\n  public async approveAccessRequest({\n    accessRequestID,\n    approverID,\n    roleID,\n    justification,\n    reviewFlowService,\n    scopeReadService,\n  }: {\n    accessRequestID: number;\n    approverID: number;\n    roleID: number;\n    justification: string;\n    reviewFlowService: ReviewFlowService;\n    scopeReadService: ScopeReadService;\n  }) {\n    return transaction(async (tx) => {\n      const accessRequest = await tx.access_request.findFirstOrThrow({\n        where: {\n          id: accessRequestID,\n          status: \"pending\",\n        },\n      });\n\n      await this.createUserRoles({\n        userID: accessRequest.user_id as User.ID,\n        locationID: accessRequest.location_id,\n        roles: [roleID],\n        reviewFlowService,\n        scopeReadService,\n        tx,\n      });\n\n      await tx.access_request.update({\n        where: { id: accessRequestID },\n        data: {\n          status: \"approved\",\n          responded_by: approverID,\n          response_ts: new Date(),\n          response_justification: justification,\n        },\n      });\n\n      await invalidateSessionsPermissions([accessRequest.user_id as User.ID]);\n\n      await this.notifyAccessGranted({\n        userID: accessRequest.user_id as User.ID,\n        locationID: accessRequest.location_id,\n      });\n    });\n  }\n\n  @authorized(\"create\", \"location_settings\")\n  public async rejectAccessRequest({\n    accessRequestID,\n    rejecterID,\n    justification,\n  }: {\n    accessRequestID: number;\n    rejecterID: number;\n    justification: string;\n  }) {\n    return transaction(async (tx) => {\n      const accessRequest = await tx.access_request.findFirstOrThrow({\n        where: {\n          id: accessRequestID,\n          status: \"pending\",\n        },\n      });\n\n      await tx.access_request.update({\n        where: { id: accessRequestID },\n        data: {\n          status: \"rejected\",\n          responded_by: rejecterID,\n          response_ts: new Date(),\n          response_justification: justification,\n        },\n      });\n\n      await this.notifyAccessRejected({\n        userID: accessRequest.user_id as User.ID,\n        locationID: accessRequest.location_id,\n        justification,\n      });\n    });\n  }\n\n  private async notifyAccessRequested({\n    userID,\n    locationID,\n    justification,\n  }: {\n    userID: User.ID;\n    locationID: number;\n    justification: string;\n  }) {\n    const [user, locationAdmins, location] = await Promise.all([\n      this.userService.getUserById(userID),\n      this.userService.getLocationAdmins(locationID),\n\n      // cannot use location service because of the read permission check\n      DBClient.location.findUnique({ where: { location_id: locationID } }),\n    ]);\n\n    const ctaUrl = new URL(`/settings/locations/${locationID}/user-access`, getBaseURL()).href;\n    const body = `${user.name} requested access to ${location?.name}, with the justification: ${justification}`;\n\n    await Promise.all(\n      locationAdmins.map(async (locationAdmin) => {\n        const email = new SimpleEmail({\n          recipientEmail: locationAdmin.email,\n          subject: `${user.name} Requested Access`,\n          body,\n          ctaTitle: \"Review Request\",\n          ctaUrl,\n        });\n\n        await sendEmail(email);\n      })\n    );\n  }\n\n  private async notifyAccessGranted({ userID, locationID }: { userID: User.ID; locationID: number }) {\n    const ctaUrl = getBaseURL();\n    const [user, location] = await Promise.all([\n      this.userService.getUserById(userID),\n      this.locationService.get(locationID),\n    ]);\n\n    const email = new SimpleEmail({\n      recipientEmail: user.email,\n      subject: \"Your Access Request was Granted\",\n      body: `You now have access to Atom. Location: ${location?.name}`,\n      ctaTitle: \"Open Atom\",\n      ctaUrl,\n    });\n\n    await sendEmail(email);\n  }\n\n  private async notifyAccessRejected({\n    userID,\n    locationID,\n    justification,\n  }: {\n    userID: User.ID;\n    locationID: number;\n    justification: string;\n  }) {\n    const ctaUrl = getBaseURL();\n    const [user, location] = await Promise.all([\n      this.userService.getUserById(userID),\n      this.locationService.get(locationID),\n    ]);\n\n    const body = `Access Rejected to ${location?.name}. Justification: ${justification}`;\n\n    const email = new SimpleEmail({\n      recipientEmail: user.email,\n      subject: \"Your Access Request was Rejected\",\n      body,\n      ctaTitle: \"Request Access\",\n      ctaUrl,\n    });\n\n    await sendEmail(email);\n  }\n}\n```\n\ni have added a validation function which checks if the user is internal or external and if the roles are internal or external. help me write a test case for this function.\nI can help you write test cases for the `validateRoles` function. We should test different combinations of internal/external users and roles. Here's a suggested test suite that you can add to your existing tests:\n\n```typescript\ndescribe(\"validateRoles\", () => {\n  let internalUserID: User.ID;\n  let externalUserID: User.ID;\n  let permissionsService: PermissionsService;\n\n  beforeAll(async () => {\n    ctx = await setupTestContext();\n    permissionsService = new PermissionsService(ctx.admin.abilityContainer);\n  });\n\n  beforeEach(async () => {\n    // Create an internal user\n    internalUserID = (\n      await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { is_internal: true }\n      )\n    ).user_id;\n\n    // Create an external user\n    externalUserID = (\n      await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { is_internal: false }\n      )\n    ).user_id;\n  });\n\n  afterEach(async () => {\n    await db.user.delete(internalUserID);\n    await db.user.delete(externalUserID);\n  });\n\n  it(\"should allow internal user to be assigned internal roles\", async () => {\n    const internalRoles = [User.UserRoleType.Admin, User.UserRoleType.LocationAdmin];\n    await expect(\n      permissionsService[\"validateRoles\"](internalUserID, internalRoles)\n    ).resolves.not.toThrow();\n  });\n\n  it(\"should allow external user to be assigned external roles\", async () => {\n    const externalRoles = [User.UserRoleType.Supplier, User.UserRoleType.Contractor];\n    await expect(\n      permissionsService[\"validateRoles\"](externalUserID, externalRoles)\n    ).resolves.not.toThrow();\n  });\n\n  it(\"should not allow internal user to be assigned external roles\", async () => {\n    const externalRoles = [User.UserRoleType.Supplier, User.UserRoleType.Contractor];\n    await expect(\n      permissionsService[\"validateRoles\"](internalUserID, externalRoles)\n    ).rejects.toThrow(\"Internal user cannot be assigned external roles\");\n  });\n\n  it(\"should not allow external user to be assigned internal roles\", async () => {\n    const internalRoles = [User.UserRoleType.Admin, User.UserRoleType.LocationAdmin];\n    await expect(\n      permissionsService[\"validateRoles\"](externalUserID, internalRoles)\n    ).rejects.toThrow(\"External user cannot be assigned internal roles\");\n  });\n\n  it(\"should not allow mixing internal and external roles\", async () => {\n    const mixedRoles = [User.UserRoleType.Admin, User.UserRoleType.Supplier];\n    await expect(\n      permissionsService[\"validateRoles\"](internalUserID, mixedRoles)\n    ).rejects.toThrow(\"All roles has to be either internal or external\");\n  });\n});\n```\n\nA few notes about the test suite:\n\n1. We create two users in the `beforeEach` block - one internal and one external.\n2. We clean up the users in the `afterEach` block.\n3. We test five scenarios:\n   - Assigning internal roles to internal users (should succeed)\n   - Assigning external roles to external users (should succeed)\n   - Assigning external roles to internal users (should fail)\n   - Assigning internal roles to external users (should fail)\n   - Trying to assign a mix of internal and external roles (should fail)\n\nYou might need to adjust the role types (UserRoleType.Admin, UserRoleType.Supplier, etc.) to match your actual enum values, and you might need to modify the user creation to match your database schema.\n\nAlso, you'll need to make sure your test database has the proper role definitions with the correct `user_type` values set to \"internal\" or \"external\" as appropriate.\n\nRemember to add error handling in your actual implementation if you haven't already:\n\n```typescript\nif (!areAllRolesInternal && !areAllRolesExternal) {\n  throw new ForbiddenError(\"All roles has to be either internal or external\");\n}\n\nif (isInternalUser && areAllRolesExternal) {\n  throw new ForbiddenError(\"Internal user cannot be assigned external roles\");\n}\n\nif (!isInternalUser && areAllRolesInternal) {\n  throw new ForbiddenError(\"External user cannot be assigned internal roles\");\n}\n```\ninstead of using permission service you can use the create user role raw function to test the validation function.\nHere's the modified test suite using the `createUserRoleRaw` function:\n\n```typescript\ndescribe(\"Role validation\", () => {\n  let internalUserID: User.ID;\n  let externalUserID: User.ID;\n\n  beforeEach(async () => {\n    // Create an internal user\n    internalUserID = (\n      await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { is_internal: true }\n      )\n    ).user_id;\n\n    // Create an external user\n    externalUserID = (\n      await db.user.create(\n        { l360_trt_id: ctx.l360_trt_id },\n        { is_internal: false }\n      )\n    ).user_id;\n  });\n\n  afterEach(async () => {\n    await db.user.delete(internalUserID);\n    await db.user.delete(externalUserID);\n  });\n\n  it(\"should allow internal user to be assigned internal roles\", async () => {\n    const input = { \n      new_user_id: internalUserID, \n      role_id: User.UserRoleType.LocationAdmin \n    };\n    const response = await ctx.admin.permissions.createUserRoleRaw(ctx.location_id, input);\n    expect(response.status).toBe(StatusCodes.OK);\n  });\n\n  it(\"should allow external user to be assigned external roles\", async () => {\n    const input = { \n      new_user_id: externalUserID, \n      role_id: User.UserRoleType.Supplier \n    };\n    const response = await ctx.admin.permissions.createUserRoleRaw(ctx.location_id, input);\n    expect(response.status).toBe(StatusCodes.OK);\n  });\n\n  it(\"should not allow internal user to be assigned external roles\", async () => {\n    anticipateConsoleErrorMessage(\"Internal user cannot be assigned external roles\");\n    const input = { \n      new_user_id: internalUserID, \n      role_id: User.UserRoleType.Supplier \n    };\n    const response = await ctx.admin.permissions.createUserRoleRaw(ctx.location_id, input);\n    expect(response.status).toBe(StatusCodes.FORBIDDEN);\n  });\n\n  it(\"should not allow external user to be assigned internal roles\", async () => {\n    anticipateConsoleErrorMessage(\"External user cannot be assigned internal roles\");\n    const input = { \n      new_user_id: externalUserID, \n      role_id: User.UserRoleType.LocationAdmin \n    };\n    const response = await ctx.admin.permissions.createUserRoleRaw(ctx.location_id, input);\n    expect(response.status).toBe(StatusCodes.FORBIDDEN);\n  });\n\n  it(\"should not allow mixing internal and external roles\", async () => {\n    anticipateConsoleErrorMessage(\"All roles has to be either internal or external\");\n    // First assign an internal role\n    const input1 = { \n      new_user_id: internalUserID, \n      role_id: User.UserRoleType.LocationAdmin \n    };\n    await ctx.admin.permissions.createUserRoleRaw(ctx.location_id, input1);\n\n    // Then try to assign an external role\n    const input2 = { \n      new_user_id: internalUserID, \n      role_id: User.UserRoleType.Supplier \n    };\n    const response = await ctx.admin.permissions.createUserRoleRaw(ctx.location_id, input2);\n    expect(response.status).toBe(StatusCodes.FORBIDDEN);\n  });\n});\n```\n\nThis test suite:\n\n1. Creates internal and external users in the `beforeEach` block\n2. Cleans up the users in the `afterEach` block\n3. Tests the same five scenarios as before, but using the `createUserRoleRaw` API endpoint:\n   - Assigning internal roles to internal users (should succeed)\n   - Assigning external roles to external users (should succeed)\n   - Assigning external roles to internal users (should fail)\n   - Assigning internal roles to external users (should fail)\n   - Trying to assign a mix of internal and external roles (should fail)\n\nMake sure to:\n1. Adjust the role types (UserRoleType.LocationAdmin, UserRoleType.Supplier) to match your actual enum values\n2. Verify that these roles are properly configured in your test database with the correct `user_type` values\n3. Ensure the error messages match the ones thrown by your validation function\n\nThis approach tests the validation through the API layer, which is closer to how the function will be used in production.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":234}}},{"id":{"replica_id":0,"value":41},"start":24605,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":235}}},{"id":{"replica_id":0,"value":42},"start":28611,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":236}}},{"id":{"replica_id":0,"value":131},"start":28726,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":237}}},{"id":{"replica_id":0,"value":132},"start":32651,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":238}}}],"summary":"Role Type Validation Test Cases","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":9385},"icon":"File","label":"atom-web/src/server/settings/locations/permissions/permissions.system.test.ts","metadata":{"path":"atom-web/src/server/settings/locations/permissions/permissions.system.test.ts"}},{"range":{"start":9386,"end":24432},"icon":"File","label":"atom-web/src/server/settings/locations/permissions/permissions.service.ts","metadata":{"path":"atom-web/src/server/settings/locations/permissions/permissions.service.ts"}}],"thought_process_output_sections":[]}