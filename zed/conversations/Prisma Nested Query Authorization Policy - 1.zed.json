{"id":"b34a4952-e578-4001-8466-38c15b4e937d","zed":"context","version":"0.4.0","text":"\n\n\n```ts atom-web/src/server/auth/authorization-policy-builder/casl-config/external-roles/document-reviewer.ts\nimport { Prisma } from \"@prisma/client\";\nimport logger from \"../../../../utils/loggers/logger\";\nimport { conditionsMap } from \"../conditions\";\nimport { DefinePermissions } from \"../types\";\nimport { AuthRepo } from \"../../../auth.repo\";\nimport { Review } from \"@atom/types\";\n\nexport const externalDocReviewer: DefinePermissions = async (conditions, { can }, policyUser) => {\n  if (!policyUser) return;\n\n  if (policyUser.isInternal) {\n    logger.warn({ user: policyUser }, \"External user role used for internal user.\");\n    return;\n  }\n\n  const authRepo = new AuthRepo();\n  const docrevisionIDs = await authRepo.getUserReviewSubjects(policyUser.id, Review.Subject.DOCUMENT_REVISION);\n\n  const canReadDocumentRevision = {\n    document_revision_id: {\n      in: docrevisionIDs,\n    },\n  } satisfies Prisma.document_revisionWhereInput;\n\n  can(\"read\", \"document_revision\", canReadDocumentRevision);\n\n  can(\"read\", \"document\", {\n    document_revision: {\n      some: canReadDocumentRevision,\n    },\n  });\n\n  can(\"read\", \"document_package\", {\n    OR: [\n      {\n        document_package_document: {\n          some: {\n            document: {\n              document_revision: {\n                some: canReadDocumentRevision,\n              },\n            },\n          },\n        },\n      },\n    ],\n  });\n\n  can([\"read\", \"create\"], \"comment\", {\n    visible_to_external: true,\n  });\n\n  can([\"read\"], \"notification\", conditionsMap.notification(conditions, policyUser));\n};\n```\n\ni have this as my cash prisma query, but here, can i pass a nested query so that its fetched in the fly instead of fetching the docrevisionid here and passing hardcoded ids\nYes, you can use a nested query in CASL to create more dynamic conditions without fetching IDs beforehand. Here's how you can modify your code to use nested queries:\n\n```typescript\nexport const externalDocReviewer: DefinePermissions = async (conditions, { can }, policyUser) => {\n  if (!policyUser) return;\n\n  if (policyUser.isInternal) {\n    logger.warn({ user: policyUser }, \"External user role used for internal user.\");\n    return;\n  }\n\n  // Define the base condition for document revisions that the user can review\n  const canReadDocumentRevision = {\n    reviews: {\n      some: {\n        reviewer_id: policyUser.id,\n        subject: Review.Subject.DOCUMENT_REVISION\n      }\n    }\n  } satisfies Prisma.document_revisionWhereInput;\n\n  can(\"read\", \"document_revision\", canReadDocumentRevision);\n\n  can(\"read\", \"document\", {\n    document_revision: {\n      some: canReadDocumentRevision\n    }\n  });\n\n  can(\"read\", \"document_package\", {\n    OR: [\n      {\n        document_package_document: {\n          some: {\n            document: {\n              document_revision: {\n                some: canReadDocumentRevision\n              }\n            }\n          }\n        }\n      }\n    ]\n  });\n\n  can([\"read\", \"create\"], \"comment\", {\n    visible_to_external: true\n  });\n\n  can([\"read\"], \"notification\", conditionsMap.notification(conditions, policyUser));\n};\n```\n\nThe key changes are:\n1. Removed the explicit `authRepo.getUserReviewSubjects()` call\n2. Replaced the `document_revision_id: { in: docrevisionIDs }` condition with a nested query using the `reviews` relation\n\nThis approach has several benefits:\n- It's more efficient as it avoids an extra database query to fetch IDs\n- The conditions are evaluated at query time\n- It's more maintainable as the logic is contained in the permission definition\n- It will automatically stay in sync with any changes to the review relationships\n\nMake sure your Prisma schema has the proper relations defined between `document_revision` and `reviews` for this to work correctly.\nbut i dont have a relation between review and docRevision since the review is used for other tables as well, we differentiate based on subject as document and subjectid as docrevisionid\n\nAh, I see! In that case, since you're using a polymorphic relationship through the `subject` and `subject_id` fields, you'll need to structure the query differently. Here's how you can modify it:\n\n```typescript\nexport const externalDocReviewer: DefinePermissions = async (conditions, { can }, policyUser) => {\n  if (!policyUser) return;\n\n  if (policyUser.isInternal) {\n    logger.warn({ user: policyUser }, \"External user role used for internal user.\");\n    return;\n  }\n\n  const canReadDocumentRevision = {\n    id: {\n      in: {\n        select: {\n          subject_id: true\n        },\n        from: 'review',\n        where: {\n          reviewer_id: policyUser.id,\n          subject: Review.Subject.DOCUMENT_REVISION\n        }\n      }\n    }\n  } satisfies Prisma.document_revisionWhereInput;\n\n  can(\"read\", \"document_revision\", canReadDocumentRevision);\n\n  can(\"read\", \"document\", {\n    document_revision: {\n      some: canReadDocumentRevision\n    }\n  });\n\n  can(\"read\", \"document_package\", {\n    OR: [\n      {\n        document_package_document: {\n          some: {\n            document: {\n              document_revision: {\n                some: canReadDocumentRevision\n              }\n            }\n          }\n        }\n      }\n    ]\n  });\n\n  can([\"read\", \"create\"], \"comment\", {\n    visible_to_external: true\n  });\n\n  can([\"read\"], \"notification\", conditionsMap.notification(conditions, policyUser));\n};\n```\n\nThis approach uses a subquery to find the relevant `subject_id`s from the `review` table that match the user's permissions. The query will be executed at runtime when the permissions are checked.\n\nIf your Prisma version doesn't support this exact syntax for subqueries, you might need to use raw SQL or adjust the query structure according to your Prisma version's capabilities. Let me know if you need help adjusting it further!\nprisma type only takes number in the in block\n\nAh, for Prisma's type safety, we'll need to use a slightly different approach since the `in` operator expects an array of numbers. Here's how we can modify it:\n\n```typescript\nexport const externalDocReviewer: DefinePermissions = async (conditions, { can }, policyUser) => {\n  if (!policyUser) return;\n\n  if (policyUser.isInternal) {\n    logger.warn({ user: policyUser }, \"External user role used for internal user.\");\n    return;\n  }\n\n  const canReadDocumentRevision = {\n    id: {\n      in: {\n        $queryRaw: Prisma.sql`\n          SELECT subject_id::int \n          FROM review \n          WHERE reviewer_id = ${policyUser.id} \n          AND subject = ${Review.Subject.DOCUMENT_REVISION}\n        `\n      }\n    }\n  } satisfies Prisma.document_revisionWhereInput;\n\n  // ... rest of the code remains the same\n};\n```\n\nOr alternatively, you might need to use a raw filter expression:\n\n```typescript\nconst canReadDocumentRevision = Prisma.sql`\n  id IN (\n    SELECT subject_id::int \n    FROM review \n    WHERE reviewer_id = ${policyUser.id} \n    AND subject = ${Review.Subject.DOCUMENT_REVISION}\n  )\n`;\n```\n\nHowever, if these don't work with CASL's type system, you might need to stick with the original approach of fetching the IDs first. The performance impact might be negligible depending on your use case, and it might be the most type-safe solution:\n\n```typescript\nexport const externalDocReviewer: DefinePermissions = async (conditions, { can }, policyUser) => {\n  if (!policyUser) return;\n\n  if (policyUser.isInternal) {\n    logger.warn({ user: policyUser }, \"External user role used for internal user.\");\n    return;\n  }\n\n  const authRepo = new AuthRepo();\n  const docrevisionIDs = await authRepo.getUserReviewSubjects(policyUser.id, Review.Subject.DOCUMENT_REVISION);\n\n  const canReadDocumentRevision = {\n    document_revision_id: {\n      in: docrevisionIDs,\n    },\n  } satisfies Prisma.document_revisionWhereInput;\n\n  // ... rest of the code remains the same\n};\n```\n\nThe raw SQL approach might be more efficient but could be less type-safe and more difficult to maintain. The original approach with separate fetching might be the better compromise between type safety, maintainability, and performance unless you're dealing with a very large number of records.\ncan i create a raw query which satisfies satisfies Prisma.document_revisionWhereInput\n\nNo, unfortunately you can't directly use a raw SQL query that satisfies `Prisma.document_revisionWhereInput`. The type system requires structured objects that match Prisma's query builders.\n\nIn this case, the original approach is the most type-safe and maintainable solution:\n\n```typescript\nexport const externalDocReviewer: DefinePermissions = async (conditions, { can }, policyUser) => {\n  if (!policyUser) return;\n\n  if (policyUser.isInternal) {\n    logger.warn({ user: policyUser }, \"External user role used for internal user.\");\n    return;\n  }\n\n  const authRepo = new AuthRepo();\n  const docrevisionIDs = await authRepo.getUserReviewSubjects(policyUser.id, Review.Subject.DOCUMENT_REVISION);\n\n  const canReadDocumentRevision = {\n    document_revision_id: {\n      in: docrevisionIDs,\n    },\n  } satisfies Prisma.document_revisionWhereInput;\n\n  // ... rest of the code remains the same\n};\n```\n\nIf performance becomes a concern, you might want to consider:\n1. Caching the results of `getUserReviewSubjects`\n2. Optimizing the database query in `getUserReviewSubjects`\n3. Adding appropriate indexes to your database\n4. Implementing pagination if dealing with large datasets\n\nBut for now, the current implementation with explicit ID fetching is the most reliable approach that maintains type safety and clear intent.\ni dont care about type safety here, i want the function to be not async and just pass the query, so that the query can be run in the runtime\nAh, now I understand! You want to remove the async operation and have the filtering happen at runtime. Here's how you can do it by removing the type safety constraint:\n\n```typescript\nexport const externalDocReviewer: DefinePermissions = (conditions, { can }, policyUser) => {\n  if (!policyUser) return;\n\n  if (policyUser.isInternal) {\n    logger.warn({ user: policyUser }, \"External user role used for internal user.\");\n    return;\n  }\n\n  // Remove type constraint and use raw query condition\n  const canReadDocumentRevision = {\n    id: {\n      in: Prisma.raw(`(\n        SELECT subject_id::int \n        FROM review \n        WHERE reviewer_id = ${policyUser.id} \n        AND subject = '${Review.Subject.DOCUMENT_REVISION}'\n      )`)\n    }\n  };\n\n  can(\"read\", \"document_revision\", canReadDocumentRevision);\n\n  can(\"read\", \"document\", {\n    document_revision: {\n      some: canReadDocumentRevision\n    }\n  });\n\n  can(\"read\", \"document_package\", {\n    OR: [\n      {\n        document_package_document: {\n          some: {\n            document: {\n              document_revision: {\n                some: canReadDocumentRevision\n              }\n            }\n          }\n        }\n      }\n    ]\n  });\n\n  can([\"read\", \"create\"], \"comment\", {\n    visible_to_external: true\n  });\n\n  can([\"read\"], \"notification\", conditionsMap.notification(conditions, policyUser));\n};\n```\n\nNow the function is synchronous and the actual query will be executed when the permission is checked at runtime. The subquery will be part of the WHERE clause in the final SQL query.\n\nNote: Make sure to properly escape any values to prevent SQL injection if you're using raw queries. In this case, since `policyUser.id` is presumably a number and `Review.Subject.DOCUMENT_REVISION` is a controlled enum, it should be safe, but it's always good to be cautious with raw SQL.\nit throws type error because the id in has to be a number","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":990}}},{"id":{"replica_id":0,"value":58},"start":1745,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":991}}},{"id":{"replica_id":0,"value":59},"start":3757,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":992}}},{"id":{"replica_id":0,"value":199},"start":3944,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":993}}},{"id":{"replica_id":0,"value":200},"start":5785,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":994}}},{"id":{"replica_id":0,"value":337},"start":5832,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":995}}},{"id":{"replica_id":0,"value":338},"start":8098,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":996}}},{"id":{"replica_id":0,"value":487},"start":8185,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":997}}},{"id":{"replica_id":0,"value":488},"start":9502,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":998}}},{"id":{"replica_id":0,"value":679},"start":9643,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":999}}},{"id":{"replica_id":0,"value":680},"start":11480,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":1000}}}],"summary":"Prisma Nested Query Authorization Policy","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":1571},"icon":"File","label":"atom-web/src/server/auth/authorization-policy-builder/casl-config/external-roles/document-reviewer.ts","metadata":{"path":"atom-web/src/server/auth/authorization-policy-builder/casl-config/external-roles/document-reviewer.ts"}}],"thought_process_output_sections":[]}