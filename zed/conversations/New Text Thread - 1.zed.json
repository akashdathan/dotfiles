{"id":"f6da9e9c-30c3-47cd-97d5-4d86cca1ec1e","zed":"context","version":"0.4.0","text":"\n\n```ts atom-web/src/server/cost/project/sub-project/sub-project.service.ts\nimport { User } from \"@atom/types\";\nimport { subject } from \"@casl/ability\";\nimport { accessibleBy } from \"@casl/prisma\";\nimport { Prisma, cost_estimate, cost_sub_project } from \"@prisma/client\";\nimport { isNumber } from \"lodash\";\nimport { XOR } from \"ts-essentials\";\nimport { AppActions } from \"../../../auth\";\nimport DBClient, { transaction } from \"../../../config/database/client\";\nimport AuthorizedService from \"../../../utils/authorization/AuthorizedService\";\nimport { EntityNotFoundError, ForbiddenError, InvalidArgumentError } from \"../../../utils/errors\";\nimport logger from \"../../../utils/loggers/logger\";\nimport EstimateService from \"./estimate/estimate.service\";\nimport { ReqCreateSubProjectSchema, ReqUpdateSubProjectSchema } from \"./sub-project\";\n\nconst prisma = DBClient.instance;\nconst { cost_project: CostProject, cost_sub_project: CostSubProject } = prisma;\n\ninterface CostSubProjectTotals extends cost_sub_project {\n  currency: string;\n  subproject_total_cost: number;\n  created_by_name: string;\n  updated_by_name: string | null;\n  area_name: string | null;\n}\n\ninterface CostSubprojectForFundingRequest {\n  subproject_id: number;\n  subproject_name: string;\n  subproject_code: string;\n  primary_estimate_id: number;\n  primary_estimate_name: string;\n  update_ts: number | null;\n  creation_ts: number;\n  updated_by_user_id: User.ID;\n  updated_by_user_name: string;\n  supplier_user_sso_id: string;\n  tesla_user_id: string;\n  updated_by_user_email: string;\n  searchable_user_name_email: string;\n  total_cost: number;\n}\n\nexport default class SubProjectService extends AuthorizedService {\n  public async create(costProjectID: number, userID: User.ID, subProject: ReqCreateSubProjectSchema) {\n    if (!(await this.isActionAuthorized(\"create\", costProjectID))) {\n      throw new ForbiddenError();\n    }\n\n    return CostSubProject.create({\n      data: {\n        ...subProject,\n        cost_project_id: costProjectID,\n        created_by: userID,\n        updated_by: userID,\n      },\n    });\n  }\n\n  public async update({\n    projectID,\n    subprojectID,\n    userID,\n    subproject,\n  }: {\n    projectID: number;\n    userID: User.ID;\n    subprojectID: number;\n    subproject: ReqUpdateSubProjectSchema;\n  }) {\n    const updatedSubproject = await CostSubProject.updateMany({\n      data: {\n        ...subproject,\n        updated_by: userID,\n      },\n      where: {\n        AND: [\n          accessibleBy(this.ability, \"update\").cost_sub_project,\n          { cost_sub_project_id: subprojectID },\n          { cost_project_id: projectID },\n        ],\n      },\n    });\n\n    if (updatedSubproject.count === 0) {\n      throw new EntityNotFoundError(\"Subproject\");\n    }\n\n    return updatedSubproject;\n  }\n\n  public async get({\n    projectId,\n    subprojectId,\n    userID,\n    estimateService,\n  }: {\n    projectId: number;\n    subprojectId: number;\n    userID: User.ID;\n    estimateService: EstimateService;\n  }) {\n    return transaction(async (tx) => {\n      const { cost_sub_project: CostSubproject } = tx;\n\n      const subproject = await CostSubproject.findFirst({\n        where: {\n          AND: [\n            accessibleBy(this.ability, \"read\").cost_sub_project,\n            { cost_project_id: projectId },\n            { cost_sub_project_id: subprojectId },\n          ],\n        },\n        include: {\n          area: true,\n          created_by_user: true,\n          updated_by_user: true,\n          cost_project: {\n            include: {\n              currency: true,\n            },\n          },\n        },\n      });\n\n      if (!subproject) {\n        throw new EntityNotFoundError(\"Subproject\");\n      }\n\n      let primaryEstimate: cost_estimate | null = null;\n\n      if (subproject.primary_cost_estimate_id) {\n        primaryEstimate = await estimateService.getOne(subproject.primary_cost_estimate_id, userID, tx);\n      }\n\n      return {\n        ...subproject,\n        primary_cost_estimate: primaryEstimate,\n      };\n    });\n  }\n\n  public async getAll({\n    locationID,\n    projectId,\n    estimateService,\n  }: {\n    locationID: number;\n    projectId: number;\n    estimateService: EstimateService;\n  }) {\n    if (!(await this.isActionAuthorized(\"read\", projectId))) {\n      return [];\n    }\n\n    try {\n      const subProjects = await this.getSubProjectsWithTotals({ location_id: locationID, cost_project_id: projectId });\n\n      return await Promise.all(\n        subProjects.map(async (subProject) => {\n          let status: string | null = null;\n\n          if (subProject.primary_cost_estimate_id !== null) {\n            const estimate = await estimateService.getOne(subProject.primary_cost_estimate_id);\n            status = estimate?.cost_estimate_status.name || null;\n          }\n\n          return { ...subProject, status };\n        })\n      );\n    } catch (error) {\n      logger.error({ prismaError: error }, \"Error retrieving subprojects totals for a project\");\n      return [];\n    }\n  }\n  public async getAllOwnedByUser(location_id: number, userID: User.ID, estimateService: EstimateService) {\n    try {\n      const subProjects = await this.getSubProjectsWithTotals({ location_id, userID });\n\n      const projectIsAuthorized = new Map<number, boolean>();\n      const uniqueProjectIDs = [...new Set(subProjects.map((subProject) => Math.trunc(subProject.cost_project_id)))];\n      for (const projectID of uniqueProjectIDs) {\n        projectIsAuthorized.set(projectID, await this.isActionAuthorized(\"read\", projectID));\n      }\n\n      return Promise.all(\n        subProjects\n          .filter((subProject) => projectIsAuthorized.get(Math.trunc(subProject.cost_project_id)))\n          .map(async (subProject) => {\n            if (!subProject.primary_cost_estimate_id) {\n              return subProject;\n            }\n\n            const primaryEstimate = await estimateService.getOne(Number(subProject.primary_cost_estimate_id));\n\n            return {\n              ...subProject,\n              primary_cost_estimate: primaryEstimate,\n            };\n          })\n      );\n    } catch (error) {\n      logger.error({ prismaError: error }, \"Error retrieving subprojects totals for a user\");\n      throw error;\n    }\n  }\n\n  async getAllReadyForSubmission(projectID: number) {\n    if (!isNumber(projectID)) {\n      throw new InvalidArgumentError(\"project ID is missing\");\n    }\n\n    if (!(await this.isActionAuthorized(\"read\", projectID))) {\n      return [];\n    }\n\n    try {\n      const subprojects = await DBClient.instance.$queryRaw<CostSubprojectForFundingRequest[]>`\n        SELECT\n          cs.cost_sub_project_id AS subproject_id,\n          cs.name AS subproject_name,\n          cs.code AS subproject_code,\n          ce.cost_estimate_id AS primary_estimate_id,\n          ce.description AS primary_estimate_name,\n          ce.update_ts,\n          ce.creation_ts,\n          nu.id AS updated_by_user_id,\n          nu.name AS updated_by_user_name,\n          nu.supplier_user_sso_id AS supplier_user_sso_id,\n          nu.tesla_user_id AS tesla_user_id,\n          nu.email AS updated_by_user_email,\n          nu.searchable_user_name_email AS searchable_user_name_email,\n          SUBPROJECTTOTALCOST(cs.cost_sub_project_id, cs.primary_cost_estimate_id) AS total_cost\n        FROM cost_sub_project cs\n        JOIN cost_estimate ce ON cs.primary_cost_estimate_id = ce.cost_estimate_id\n        LEFT JOIN new_user nu ON nu.id = cs.updated_by\n        LEFT JOIN cost_estimate_funding_request cefr ON cefr.cost_estimate_id = ce.cost_estimate_id\n        WHERE\n          cs.cost_project_id = ${projectID}\n          AND cefr.cost_estimate_funding_request_id IS NULL\n        HAVING\n          total_cost > 0;\n      `;\n\n      return subprojects.map((subproject) => ({\n        ...subproject,\n        updated_by_user_id: undefined,\n        updated_by_user_name: undefined,\n        supplier_user_sso_id: undefined,\n        tesla_user_id: undefined,\n        updated_by_user_email: undefined,\n        searchable_user_name_email: undefined,\n        updated_by_user: {\n          id: subproject.updated_by_user_id,\n          name: subproject.updated_by_user_name,\n          supplier_user_sso_id: subproject.supplier_user_sso_id,\n          tesla_user_id: subproject.tesla_user_id,\n          email: subproject.updated_by_user_email,\n          searchable_user_name_email: subproject.searchable_user_name_email,\n        },\n      }));\n    } catch (error) {\n      logger.error({ prismaError: error }, \"Error retrieving subprojects ready for submission\");\n      throw error;\n    }\n  }\n\n  async isEstimateInSubProject({\n    subprojectID,\n    estimateID,\n    estimateService,\n  }: {\n    subprojectID: number;\n    estimateID: number;\n    estimateService: EstimateService;\n  }): Promise<boolean> {\n    const estimate = await estimateService.getOne(estimateID);\n    return !!estimate && estimate.cost_sub_project_id === subprojectID;\n  }\n\n  private async isActionAuthorized(action: AppActions, projectID: number) {\n    const project = await CostProject.findUnique({\n      where: {\n        cost_project_id: projectID,\n      },\n    });\n\n    if (!project) {\n      throw new EntityNotFoundError(\"Project\");\n    }\n\n    const isAllowed = this.ability.can(\n      action,\n      subject(\"cost_sub_project\", { cost_project: { location_id: project.location_id } })\n    );\n\n    return isAllowed;\n  }\n\n  public async getLocationID(subprojectID: number) {\n    const subProject = await CostSubProject.findUniqueOrThrow({\n      where: {\n        cost_sub_project_id: subprojectID,\n      },\n      include: {\n        cost_project: true,\n      },\n    });\n\n    return subProject.cost_project.location_id;\n  }\n\n  public async delete({ projectID, subprojectID }: { projectID: number; subprojectID: number }) {\n    return transaction(async () => {\n      const subproject = await CostSubProject.findFirst({\n        where: {\n          AND: [\n            accessibleBy(this.ability, \"delete\").cost_sub_project,\n            { cost_sub_project_id: subprojectID, cost_project_id: projectID },\n          ],\n        },\n        include: {\n          primary_cost_estimate: {\n            include: {\n              cost_estimate_funding_request: true,\n            },\n          },\n        },\n      });\n\n      if (!subproject || subproject?.primary_cost_estimate?.cost_estimate_funding_request) {\n        throw new ForbiddenError(\"It is not possible to delete a subproject submitted for funding request.\");\n      }\n\n      return await CostSubProject.deleteMany({\n        where: {\n          AND: [\n            accessibleBy(this.ability, \"delete\").cost_sub_project,\n            { cost_sub_project_id: subprojectID, cost_project_id: projectID },\n          ],\n        },\n      });\n    });\n  }\n\n  private async getSubProjectsWithTotals(\n    props: { location_id: number } & XOR<{ userID: User.ID }, { cost_project_id: number }>\n  ): Promise<CostSubProjectTotals[]> {\n    const findConditions: Prisma.cost_sub_projectWhereInput = props.userID\n      ? { OR: [{ created_by: props.userID }, { updated_by: props.userID }] }\n      : { cost_project_id: props.cost_project_id };\n\n    const subProjectsWithTotal = await DBClient.instance.cost_sub_project_total.findMany({\n      where: { cost_sub_project: { ...findConditions, cost_project: { location_id: props.location_id } } },\n      select: {\n        cost_sub_project: {\n          select: {\n            area: {\n              select: { area_id: true, area_name: true },\n            },\n            code: true,\n            cost_project: {\n              select: {\n                currency: { select: { name: true } },\n                cost_project_id: true,\n              },\n            },\n            cost_sub_project_id: true,\n            creation_ts: true,\n            created_by: true,\n            created_by_user: { select: { name: true } },\n            description: true,\n            name: true,\n            primary_cost_estimate_id: true,\n            update_ts: true,\n            updated_by: true,\n            updated_by_user: { select: { name: true } },\n          },\n        },\n        subproject_total_cost: true,\n      },\n      orderBy: {\n        cost_sub_project: {\n          update_ts: \"desc\",\n        },\n      },\n    });\n\n    return subProjectsWithTotal.map((subProjectWithTotal) => {\n      const {\n        cost_sub_project: {\n          area,\n          cost_project: { cost_project_id, currency },\n          created_by_user,\n          updated_by_user,\n          ...subProject\n        },\n        subproject_total_cost,\n      } = subProjectWithTotal;\n\n      return {\n        area_id: area?.area_id ?? null,\n        area_name: area?.area_name ?? null,\n        cost_project_id,\n        currency: currency.name,\n        created_by_name: created_by_user.name,\n        subproject_total_cost: subproject_total_cost?.toNumber() ?? 0,\n        updated_by_name: updated_by_user?.name ?? null,\n        ...subProject,\n      };\n    });\n  }\n}\n```\n\nfor this file, i am getting the following error for gersubprojectwithtotals function\n\n  243 const findConditions = props.userID\n  244     ? { OR: [{ created_by: props.userID }, { updated_by: props.userID }] }\n  245     : { cost_project_id: props.cost_project_id };\n→ 246 const subProjectsWithTotal = await client_1.default.instance.cost_sub_project_total.findMany(\nError occurred during query execution:\nConnectorError(ConnectorError { user_facing_error: None, kind: QueryError(Server(MysqlError { code: 1449, message: \"The user specified as a definer ('engadmusr'@'%') does not exist\", state: \"HY000\" })), transient: false })\n     name: PrismaClientUnknownRequestError\n     stack: PrismaClientUnknownRequestError: \nInvalid `client_1.default.instance.cost_sub_project_total.findMany()` invocation in\n/app/dist/server/cost/project/sub-project/sub-project.service.js:246:93\n\n  243 const findConditions = props.userID\n  244     ? { OR: [{ created_by: props.userID }, { updated_by: props.userID }] }\n  245     : { cost_project_id: props.cost_project_id };\n→ 246 const subProjectsWithTotal = await client_1.default.instance.cost_sub_project_total.findMany(\nError occurred during query execution:\nConnectorError(ConnectorError { user_facing_error: None, kind: QueryError(Server(MysqlError { code: 1449, message: \"The user specified as a definer ('engadmusr'@'%') does not exist\", state: \"HY000\" })), transient: false })\n    at $n.handleRequestError (/app/node_modules/@prisma/client/runtime/library.js:121:7505)\n    at $n.handleAndLogRequestError (/app/node_modules/@prisma/client/runtime/library.js:121:6623)\n    at $n.request (/app/node_modules/@prisma/client/runtime/library.js:121:6307)\n    at async l (/app/node_modules/@prisma/client/runtime/library.js:130:9633)\n    at async SubProjectService.getSubProjectsWithTotals (/app/dist/server/cost/project/sub-project/sub-project.service.js:246:38)\n    at async SubProjectService.getAllOwnedByUser (/app/dist/server/cost/project/sub-project/sub-project.service.js:103:33)\n    at async /app/dist/server/cost/project/project.controller.js:68:29\n   }\nThis error occurs because the MySQL user 'engadmusr' specified as the definer for a view or stored procedure doesn't exist in the database. This is typically a permissions/user management issue. Here are a few ways to resolve this:\n\n1. First, check if you're using a view named `cost_sub_project_total`. If so, you'll need to either:\n\n   a. Create the missing user:\n   ```sql\n   CREATE USER 'engadmusr'@'%' IDENTIFIED BY 'password';\n   GRANT SELECT ON database_name.* TO 'engadmusr'@'%';\n   FLUSH PRIVILEGES;\n   ```\n\n   b. Or recreate the view with a different/existing user as the definer:\n   ```sql\n   CREATE OR REPLACE DEFINER=current_user VIEW cost_sub_project_total AS ...\n   ```\n\n2. Alternatively, you could modify the code to not use the view and instead use a direct query. Here's how you could rewrite the query:\n\n```typescript\nprivate async getSubProjectsWithTotals(\n  props: { location_id: number } & XOR<{ userID: User.ID }, { cost_project_id: number }>\n): Promise<CostSubProjectTotals[]> {\n  const findConditions: Prisma.cost_sub_projectWhereInput = props.userID\n    ? { OR: [{ created_by: props.userID }, { updated_by: props.userID }] }\n    : { cost_project_id: props.cost_project_id };\n\n  const subProjects = await prisma.cost_sub_project.findMany({\n    where: {\n      ...findConditions,\n      cost_project: {\n        location_id: props.location_id\n      }\n    },\n    select: {\n      area: {\n        select: { area_id: true, area_name: true }\n      },\n      code: true,\n      cost_project: {\n        select: {\n          currency: { select: { name: true } },\n          cost_project_id: true\n        }\n      },\n      cost_sub_project_id: true,\n      creation_ts: true,\n      created_by: true,\n      created_by_user: { select: { name: true } },\n      description: true,\n      name: true,\n      primary_cost_estimate_id: true,\n      update_ts: true,\n      updated_by: true,\n      updated_by_user: { select: { name: true } },\n      cost_estimates: {\n        select: {\n          total_cost: true\n        }\n      }\n    },\n    orderBy: {\n      update_ts: 'desc'\n    }\n  });\n\n  return subProjects.map((subProject) => {\n    const totalCost = subProject.cost_estimates.reduce(\n      (sum, estimate) => sum + (estimate.total_cost?.toNumber() ?? 0),\n      0\n    );\n\n    return {\n      area_id: subProject.area?.area_id ?? null,\n      area_name: subProject.area?.area_name ?? null,\n      cost_project_id: subProject.cost_project.cost_project_id,\n      currency: subProject.cost_project.currency.name,\n      created_by_name: subProject.created_by_user.name,\n      subproject_total_cost: totalCost,\n      updated_by_name: subProject.updated_by_user?.name ?? null,\n      code: subProject.code,\n      cost_sub_project_id: subProject.cost_sub_project_id,\n      creation_ts: subProject.creation_ts,\n      created_by: subProject.created_by,\n      description: subProject.description,\n      name: subProject.name,\n      primary_cost_estimate_id: subProject.primary_cost_estimate_id,\n      update_ts: subProject.update_ts,\n      updated_by: subProject.updated_by,\n    };\n  });\n}\n```\n\nThis approach:\n1. Directly queries the tables instead of using the view\n2. Calculates the total cost in the application layer\n3. Maintains the same return type and functionality\n\nChoose the solution that best fits your needs:\n- If you need to maintain the view for other purposes, fix the user permissions\n- If the view is only used here, the direct query approach might be simpler to maintain\n\nRemember to adjust the query based on how your total costs are actually calculated in your database schema.\n```sql atom-web/db/migrations/R__Procedures.sql\n/*\nCALCULATE ESTIMATE LINE ITEM TOTALS\nBROKEN DOWN BY DIRECT COSTS AND INDIRECT COSTS\n*/\nCREATE OR REPLACE VIEW cost_line_item_total AS (\nSELECT\n    `cli`.`cost_line_item_id` AS `cost_line_item_id`,\n    `ce`.`cost_estimate_id` AS `cost_estimate_id`,\n    CAST((COALESCE(`cli`.`quantity`,0) * (1 + COALESCE(`cli`.`wastage_percentage`,0)) *\n        ((((((COALESCE(`cli`.`labor_rate`,0) * COALESCE(`cli`.`productivity_factor`,0)) * COALESCE(`cli`.`unit_man_hour`,0)) +\n        (((COALESCE(`cli`.`indirect_labor_cost_percentage`,0) * COALESCE(`cli`.`labor_rate`,0)) * COALESCE(`cli`.`productivity_factor`,0)) * COALESCE(`cli`.`unit_man_hour`,0))) + COALESCE(`cli`.`material_cost`,0)) + COALESCE(`cli`.`equipment_cost`,0)) +\n        (((((COALESCE(`cli`.`labor_rate`,0) * COALESCE(`cli`.`productivity_factor`,0)) * COALESCE(`cli`.`unit_man_hour`,0)) + (((COALESCE(`cli`.`indirect_labor_cost_percentage`,0) * COALESCE(`cli`.`labor_rate`,0)) * COALESCE(`cli`.`productivity_factor`,0)) * COALESCE(`cli`.`unit_man_hour`,0))) + COALESCE(`cli`.`material_cost`,0)) * COALESCE(`cli`.`overhead_profit_cost_percentage`,0)))) AS DECIMAL(28,2)) AS `total_direct_costs`,\n    `cli`.`design_contingency_percentage` AS `design_contingency_percentage`,\n    `cli`.`construction_contingency_percentage` AS `construction_contingency_percentage`,\n    `cli`.`discipline_id` AS `discipline_id`\nFROM\n    ((`cost_estimate` `ce`\nINNER JOIN `cost_scope` `cs` ON ((`ce`.`cost_estimate_id` = `cs`.`cost_estimate_id`)))\nINNER JOIN `cost_line_item` `cli` ON ((`cs`.`cost_scope_id` = `cli`.`cost_scope_id`))));\n\n/*\nCALCULATE ESTIMATE SUBTOTALS, INCLUDING INDIRECT COSTS\n*/\nCREATE OR REPLACE VIEW cost_estimate_subtotal AS (\nSELECT\n    `cost_line_item_total`.`cost_estimate_id` AS `cost_estimate_id`,\n    CAST(SUM(`cost_line_item_total`.`total_direct_costs`) as DECIMAL(28,2)) AS `total_direct_costs`,\n    CAST(SUM((`cost_line_item_total`.`total_direct_costs` * (`cost_line_item_total`.`design_contingency_percentage` + `cost_line_item_total`.`construction_contingency_percentage`))) as DECIMAL(28,2)) AS `total_contigency_costs`,\n    CAST(SUM((`cost_line_item_total`.`total_direct_costs` + (`cost_line_item_total`.`total_direct_costs` * (`cost_line_item_total`.`design_contingency_percentage` + `cost_line_item_total`.`construction_contingency_percentage`)))) as DECIMAL(28,2)) AS `total_estimate_cost`\nFROM\n    `cost_line_item_total`\nGROUP BY\n    `cost_line_item_total`.`cost_estimate_id`\n);\n\nCREATE OR REPLACE VIEW approved_estimates_summary AS (\nSELECT\n    `d`.`discipline_name` as `subscope`,\n    `l`.`location_id`,\n    `l`.`description` as `location_description`,\n    `cp`.`cost_project_id`,\n    `cp`.`name` as `project_name`,\n    `csp`.`cost_sub_project_id`,\n    `csp`.`name` as `sub_project_name`,\n    `ce`.`cost_estimate_id` as `cost_estimate_id`,\n    `ce`.`description` as `cost_estimate_description`,\n    `cefr_approved`.`notes` as `approver_notes`,\n    `cefr_approved`.`creation_ts` as `approval_ts`,\n    `au`.`id` as `approver_id`,\n    `au`.`name` as `approver_name`,\n    `cefr_submitted`.`notes` as `submitter_notes`,\n    `cefr_submitted`.`creation_ts` as `submission_ts`,\n    `su`.`id` as `submitter_id`,\n    `su`.`name` as `submitter_name`,\n    CAST(SUM(`cost_line_item_total`.`total_direct_costs`) as DECIMAL(28,2)) AS `total_cost`,\n    `lc`.`name` as `currency`\nFROM\n    `cost_line_item_total`\nJOIN `cost_estimate` `ce` ON `ce`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\nJOIN `cost_sub_project` `csp` ON `csp`.`cost_sub_project_id` = `ce`.`cost_sub_project_id`\nJOIN `cost_project` `cp` ON `cp`.`cost_project_id` = `csp`.`cost_project_id`\nJOIN `l360_currency` `lc` ON `lc`.`currency_id` = `cp`.`currency_id`\nJOIN `location` `l` ON `l`.`location_id` = `cp`.`location_id`\nJOIN `cost_estimate_funding_request` `cefr_approved` ON `cefr_approved`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\nJOIN `cost_estimate_funding_request` `cefr_submitted` ON `cefr_submitted`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\nJOIN `new_user` `au` ON `au`.`id` = `cefr_approved`.`created_by`\nJOIN `new_user` `su` ON `su`.`id` = `cefr_submitted`.`created_by`\nJOIN `discipline` `d` ON `d`.`discipline_id` = `cost_line_item_total`.`discipline_id`\nWHERE `cefr_approved`.`status_id` = 3 AND `cefr_submitted`.`status_id` = 2\nGROUP BY `cost_line_item_total`.`discipline_id`, `cost_estimate_id`, `cefr_approved`.`cost_estimate_funding_request_id`, `cefr_submitted`.`cost_estimate_funding_request_id`\nUNION\nSELECT\n    'Contingency' as `subscope`,\n    `l`.`location_id`,\n    `l`.`description` as `location_description`,\n    `cp`.`cost_project_id`,\n    `cp`.`name` as `project_name`,\n    `csp`.`cost_sub_project_id`,\n    `csp`.`name` as `sub_project_name`,\n    `ce`.`cost_estimate_id` AS `cost_estimate_id`,\n    `ce`.`description` as `cost_estimate_description`,\n    `cefr_approved`.`notes` as `approver_notes`,\n    `cefr_approved`.`creation_ts` as `approval_ts`,\n    `au`.`id` as `approver_id`,\n    `au`.`name` as `approver_name`,\n    `cefr_submitted`.`notes` as `submitter_notes`,\n    `cefr_submitted`.`creation_ts` as `submission_ts`,\n    `su`.`id` as `submitter_id`,\n    `su`.`name` as `submitter_name`,\n    `contingency`.`total_cost` AS `total_cost`,\n    `lc`.`name` as `currency`\nFROM\n    `cost_line_item_total`\nJOIN `cost_estimate_funding_request` `cefr` ON `cefr`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\nJOIN `cost_estimate` `ce` ON `ce`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\nJOIN `cost_sub_project` `csp` ON `csp`.`cost_sub_project_id` = `ce`.`cost_sub_project_id`\nJOIN `cost_project` `cp` ON `cp`.`cost_project_id` = `csp`.`cost_project_id`\nJOIN `l360_currency` `lc` ON `lc`.`currency_id` = `cp`.`currency_id`\nJOIN `location` `l` ON `l`.`location_id` = `cp`.`location_id`\nJOIN `cost_estimate_funding_request` `cefr_approved` ON `cefr_approved`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\nJOIN `cost_estimate_funding_request` `cefr_submitted` ON `cefr_submitted`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\nJOIN `new_user` `au` ON `au`.`id` = `cefr_approved`.`created_by`\nJOIN `new_user` `su` ON `su`.`id` = `cefr_submitted`.`created_by`\nJOIN `discipline` `d` ON `d`.`discipline_id` = `cost_line_item_total`.`discipline_id`\nJOIN (\n\t\tSELECT\n\t\t    `cefr`.`cost_estimate_id`,\n\t\t    CAST(SUM(`cost_line_item_total`.`total_direct_costs` * (`cost_line_item_total`.`design_contingency_percentage` + `cost_line_item_total`.`construction_contingency_percentage`)) as DECIMAL(28,2)) AS `total_cost`\n\t\tFROM\n\t\t    `cost_line_item_total`\n\t\tJOIN `cost_estimate_funding_request` `cefr` ON `cefr`.`cost_estimate_id` = `cost_line_item_total`.`cost_estimate_id`\n\t\tWHERE `cefr`.`status_id` = 3\n\t\tGROUP BY `cefr`.`cost_estimate_id`\n\t) AS `contingency` ON `contingency`.`cost_estimate_id` = `cefr`.`cost_estimate_id`\nWHERE `cefr_approved`.`status_id` = 3 AND `cefr_submitted`.`status_id` = 2\nGROUP BY `cost_estimate_id`, `cefr_approved`.`cost_estimate_funding_request_id`, `cefr_submitted`.`cost_estimate_funding_request_id`\n);\n\n/*\nCALCULATE TOTAL COST FOR ESTIMATE ID\n*/\nDELIMITER $$\nDROP FUNCTION IF EXISTS EstimateTotalCost $$\nCREATE FUNCTION EstimateTotalCost(estimate_id INT)\n    RETURNS DECIMAL(28,2)\n    DETERMINISTIC\n    BEGIN\n        DECLARE result DECIMAL(28,2);\n\t\tSELECT ROUND(COALESCE(total_estimate_cost, 0) + SUM(\n\t\tCASE\n\t\t\tWHEN indirect_cost_calculation_type_id = 1 THEN total_direct_costs * indirect_cost_percentage\n\t\t\tWHEN indirect_cost_calculation_type_id = 2 THEN COALESCE(direct_labor_cost, 0) + COALESCE(material_cost, 0) + COALESCE(equipment_cost,0) + COALESCE(overhead_profit_cost,0)\n\t\t\tELSE 0\n\t\tEND),2) INTO result\n\t\tFROM cost_estimate_subtotal et LEFT JOIN indirect_cost ic ON et.cost_estimate_id = ic.cost_estimate_id\n\t\tWHERE et.cost_estimate_id = estimate_id\n        GROUP BY et.cost_estimate_id;\n        RETURN result;\n    END$$\nDELIMITER ;\n\n/*\nCALCULATE TOTAL COST FOR SUBPROJECT ID\n*/\nDELIMITER $$\nDROP FUNCTION IF EXISTS SubProjectTotalCost $$\nCREATE FUNCTION SubProjectTotalCost(sub_project_id INT, primary_cost_estimate_id INT)\n    RETURNS DECIMAL(28,2)\n    DETERMINISTIC\n    BEGIN\n        DECLARE result DECIMAL(28,2);\n        SELECT SUM(EstimateTotalCost(cost_estimate_id)) INTO result\n\t\tFROM cost_estimate\n\t\tWHERE cost_sub_project_id = sub_project_id AND cost_estimate_id = primary_cost_estimate_id;\n\n        RETURN result;\n    END$$\nDELIMITER ;\n\n/*\nLIST SUBPROJECT TOTALS\n*/\nCREATE OR REPLACE VIEW cost_sub_project_total AS (\nSELECT\n    `csp`.`cost_sub_project_id` AS `cost_sub_project_id`,\n    SUBPROJECTTOTALCOST(`csp`.`cost_sub_project_id`, `csp`.`primary_cost_estimate_id`) AS `subproject_total_cost`\nFROM\n    `cost_sub_project` `csp`\n);\n\n/*\nLIST ESTIMATE TOTALS\n*/\nCREATE OR REPLACE VIEW cost_estimate_total AS (\nSELECT\n    `ce`.`cost_estimate_id` AS `cost_estimate_id`,\n    ESTIMATETOTALCOST(`ce`.`cost_estimate_id`) AS `estimate_total_cost`\nFROM\n    `cost_estimate` `ce`\n);\n\n\n/*\nRecursively resolve all linked requests to start_request_id including not directly linked requests\n*/\nDROP PROCEDURE IF EXISTS `GetLinkedRequests`;\nDELIMITER $$\nCREATE PROCEDURE `GetLinkedRequests`(IN `start_request_id` INT)\nBEGIN\n    WITH RECURSIVE `RequestsTraversal` AS (\n        SELECT `from_request_id`, `to_request_id`\n        FROM `request_relationship`\n        WHERE `from_request_id` = `start_request_id` OR `to_request_id` = `start_request_id`\n        UNION\n        SELECT `r`.`from_request_id`, `r`.`to_request_id`\n        FROM `request_relationship` `r`\n        INNER JOIN `RequestsTraversal` `t` ON\n            (`r`.`from_request_id` = `t`.`from_request_id` OR `r`.`from_request_id` = `t`.`to_request_id`)\n            OR (`r`.`to_request_id` = `t`.`from_request_id` OR `r`.`to_request_id` = `t`.`to_request_id`)\n    )\n    SELECT `RequestsTraversal`.from_request_id,\n           `RequestsTraversal`.to_request_id,\n           `req_from`.creation_ts AS req_from_creation_ts,\n           `req_to`.creation_ts AS req_to_creation_ts\n    FROM `RequestsTraversal`\n    JOIN `request` req_from ON `RequestsTraversal`.from_request_id = `req_from`.request_id\n    JOIN `request` req_to ON `RequestsTraversal`.to_request_id = `req_to`.request_id\n    ORDER BY req_from_creation_ts, req_to_creation_ts;\nEND$$\nDELIMITER ;\n```\n\nthis is the migration filw which crated the view,and i dont see any created by user\nLooking at the migration file, I see that the `cost_sub_project_total` view is created without specifying a DEFINER. However, the error suggests that somewhere in your database there might be a view or stored procedure that was created with `DEFINER='engadmusr'@'%'`.\n\nHere are a few steps to resolve this:\n\n1. First, let's modify the view definition to explicitly set the DEFINER to the current user:\n\n```sql\nCREATE OR REPLACE DEFINER=CURRENT_USER VIEW cost_sub_project_total AS (\nSELECT\n    `csp`.`cost_sub_project_id` AS `cost_sub_project_id`,\n    SUBPROJECTTOTALCOST(`csp`.`cost_sub_project_id`, `csp`.`primary_cost_estimate_id`) AS `subproject_total_cost`\nFROM\n    `cost_sub_project` `csp`\n);\n```\n\n2. You can also check for any objects that might be using the missing definer:\n\n```sql\nSELECT * FROM information_schema.VIEWS \nWHERE DEFINER LIKE '%engadmusr%';\n\nSELECT * FROM information_schema.ROUTINES \nWHERE DEFINER LIKE '%engadmusr%';\n```\n\n3. If you find any, you can update their definers:\n\n```sql\n-- For views\nALTER DEFINER=CURRENT_USER VIEW view_name AS ...\n\n-- For procedures\nALTER DEFINER=CURRENT_USER PROCEDURE procedure_name ...\n```\n\n4. If the issue persists, you might need to recreate all the related functions and views in the correct order:\n\n```sql\n-- First drop the view\nDROP VIEW IF EXISTS cost_sub_project_total;\n\n-- Then recreate the function it depends on\nDELIMITER $$\nDROP FUNCTION IF EXISTS SubProjectTotalCost $$\nCREATE DEFINER=CURRENT_USER FUNCTION SubProjectTotalCost(sub_project_id INT, primary_cost_estimate_id INT)\n    RETURNS DECIMAL(28,2)\n    DETERMINISTIC\n    BEGIN\n        DECLARE result DECIMAL(28,2);\n        SELECT SUM(EstimateTotalCost(cost_estimate_id)) INTO result\n        FROM cost_estimate\n        WHERE cost_sub_project_id = sub_project_id AND cost_estimate_id = primary_cost_estimate_id;\n\n        RETURN result;\n    END$$\nDELIMITER ;\n\n-- Finally recreate the view\nCREATE OR REPLACE DEFINER=CURRENT_USER VIEW cost_sub_project_total AS (\nSELECT\n    `csp`.`cost_sub_project_id` AS `cost_sub_project_id`,\n    SUBPROJECTTOTALCOST(`csp`.`cost_sub_project_id`, `csp`.`primary_cost_estimate_id`) AS `subproject_total_cost`\nFROM\n    `cost_sub_project` `csp`\n);\n```\n\n5. Alternatively, you could modify your code to not use the view and instead calculate the total directly:\n\n```typescript\nprivate async getSubProjectsWithTotals(\n  props: { location_id: number } & XOR<{ userID: User.ID }, { cost_project_id: number }>\n): Promise<CostSubProjectTotals[]> {\n  // Use raw SQL to calculate the total\n  const query = Prisma.sql`\n    SELECT \n      csp.*,\n      SUBPROJECTTOTALCOST(csp.cost_sub_project_id, csp.primary_cost_estimate_id) as subproject_total_cost,\n      a.area_name,\n      cp.currency_id,\n      cu.name as currency_name,\n      cu.name as created_by_name,\n      uu.name as updated_by_name\n    FROM cost_sub_project csp\n    LEFT JOIN area a ON a.area_id = csp.area_id\n    JOIN cost_project cp ON cp.cost_project_id = csp.cost_project_id\n    JOIN l360_currency cu ON cu.currency_id = cp.currency_id\n    JOIN new_user cu ON cu.id = csp.created_by\n    LEFT JOIN new_user uu ON uu.id = csp.updated_by\n    WHERE ${props.userID \n      ? Prisma.sql`(csp.created_by = ${props.userID} OR csp.updated_by = ${props.userID})`\n      : Prisma.sql`csp.cost_project_id = ${props.cost_project_id}`}\n    AND cp.location_id = ${props.location_id}\n    ORDER BY csp.update_ts DESC\n  `;\n\n  const results = await prisma.$queryRaw<CostSubProjectTotals[]>(query);\n  return results;\n}\n```\n\nTry these solutions in order - start with explicitly setting the DEFINER in your migration file, and if that doesn't work, move on to the other solutions. The last option (direct query) should work regardless of the view's state, but it might be better to fix the underlying issue with the view if other parts of your application depend on it.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":359}}},{"id":{"replica_id":0,"value":55},"start":14981,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":360}}},{"id":{"replica_id":0,"value":56},"start":18560,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":361}}},{"id":{"replica_id":0,"value":206},"start":29011,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":362}}},{"id":{"replica_id":0,"value":207},"start":32859,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":363}}}],"summary":"New Text Thread","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":2,"end":12884},"icon":"File","label":"atom-web/src/server/cost/project/sub-project/sub-project.service.ts","metadata":{"path":"atom-web/src/server/cost/project/sub-project/sub-project.service.ts"}},{"range":{"start":18560,"end":28926},"icon":"File","label":"atom-web/db/migrations/R__Procedures.sql","metadata":{"path":"atom-web/db/migrations/R__Procedures.sql"}}],"thought_process_output_sections":[]}