{"id":"27b1c7d5-c963-49f2-8b4e-3aea0299728d","zed":"context","version":"0.4.0","text":"\n\n\n```ts atom-web/src/server/new-structure/domain/team/entities/team.entity.ts\nimport { User } from \"@atom/types\";\n\nimport { Collection } from \"../../../framework/domain/collection\";\nimport { Entity, PersistedEntity } from \"../../../framework/domain/entity\";\nimport { Location } from \"../../location/entities/location.entity\";\nimport { TeamMember } from \"./team-member.entity\";\n\ninterface TeamProps {\n  name: string;\n  locationID: number;\n  members: Collection<TeamMember | PersistedEntity<TeamMember>>;\n  createdBy: User.ID;\n  updatedBy: User.ID;\n  creationTs: Date;\n  updateTs: Date;\n  isDeleted: boolean;\n}\n\nexport type MembersValidator = (\n  locationID: number,\n  members: Collection<TeamMember | PersistedEntity<TeamMember>>\n) => Promise<void>;\n\nexport class Team extends Entity<TeamProps> {\n  private _context: {\n    withManagerFallback: boolean;\n    onlyProjectStakeholders?: boolean; // If true, this team will contain only team members that are project stakeholders in the context\n    areaIDs?: number[];\n    disciplineIDs?: number[];\n    location?: Location;\n  } = {\n    onlyProjectStakeholders: false,\n    withManagerFallback: false,\n  };\n\n  set context(context: {\n    areaIDs?: number[];\n    disciplineIDs?: number[];\n    location?: Location;\n    onlyProjectStakeholders?: boolean;\n    withManagerFallback: boolean;\n  }) {\n    this._context = context;\n  }\n\n  get name() {\n    return this.props.name;\n  }\n\n  get locationID() {\n    return this.props.locationID;\n  }\n\n  get members() {\n    return this.props.members;\n  }\n\n  get contextMembers() {\n    if (this._context.onlyProjectStakeholders) return this.members;\n\n    if (this._context.areaIDs && this._context.disciplineIDs) {\n      const location = this._context.location;\n\n      const membersInAreaDiscipline = Collection.create<TeamMember | PersistedEntity<TeamMember>>(\n        this.members.filter((member) => {\n          const memberAreaDisciplineIDs = member.areaDisciplines.map(({ areaID, disciplineID }) => [\n            areaID,\n            disciplineID,\n          ]);\n\n          if (location)\n            memberAreaDisciplineIDs.push(\n              ...member.areaDisciplines.flatMap(({ areaID, disciplineID }) => {\n                const areas = location.getChildrenOfArea(areaID);\n                return areas.map((area) => [area.id!, disciplineID]);\n              })\n            );\n\n          return memberAreaDisciplineIDs.some(\n            ([areaID, disciplineID]) =>\n              this._context.areaIDs?.includes(areaID) && this._context.disciplineIDs?.includes(disciplineID)\n          );\n        })\n      );\n\n      if (membersInAreaDiscipline.length > 0) return membersInAreaDiscipline;\n    }\n\n    return this._context.withManagerFallback ? this.managers : new Collection([]);\n  }\n\n  get managers() {\n    return Collection.create<TeamMember | PersistedEntity<TeamMember>>(\n      this.props.members.filter((member) => member.isManager)\n    );\n  }\n\n  get createdBy() {\n    return this.props.createdBy;\n  }\n\n  get updatedBy() {\n    return this.props.updatedBy;\n  }\n\n  get creationTs() {\n    return this.props.creationTs;\n  }\n\n  get updateTs() {\n    return this.props.updateTs;\n  }\n\n  get isDeleted() {\n    return this.props.isDeleted;\n  }\n\n  async update(updateProps: { name?: string }, updatedBy: User.ID, validateMembers: MembersValidator) {\n    await validateMembers(this.props.locationID, this.members);\n\n    if (updateProps.name) {\n      this.props.name = updateProps.name;\n    }\n\n    this.props.updateTs = new Date();\n    this.props.updatedBy = updatedBy;\n  }\n\n  softDelete(updatedBy: User.ID) {\n    this.props.isDeleted = true;\n    this.props.updateTs = new Date();\n    this.props.updatedBy = updatedBy;\n  }\n\n  static async create(props: TeamProps & { validateMembers: MembersValidator }): Promise<Team>;\n  static async create(props: TeamProps, id: number): Promise<PersistedEntity<Team>>;\n  static async create(props: TeamProps & { validateMembers?: MembersValidator }, id?: number) {\n    if (props.validateMembers) await props.validateMembers(props.locationID, props.members);\n\n    return new Team(props, id);\n  }\n}\n```\n\n```ts atom-web/src/server/new-structure/domain/team/team.map.ts\nimport { User } from \"@atom/types\";\nimport { Prisma } from \"@prisma/client\";\nimport { DBClient } from \"../../../config/database/client\";\nimport { teamQueryInclude } from \"../../application/repositories/team.repo\";\nimport { Collection } from \"../../framework/domain/collection\";\nimport { PersistedEntity } from \"../../framework/domain/entity\";\nimport { ExcludeNull } from \"../../framework/utils\";\nimport { TeamMember } from \"./entities/team-member.entity\";\n\nimport { Team } from \"./entities/team.entity\";\n\nexport type DbTeam = ExcludeNull<\n  Prisma.Result<typeof DBClient.team, { include: typeof teamQueryInclude }, \"findFirst\">\n>;\n\nexport class TeamMap {\n  static toDomain(dbTeam: DbTeam): Promise<PersistedEntity<Team>> {\n    const members = new Collection<TeamMember | PersistedEntity<TeamMember>>(\n      dbTeam.team_member.map(TeamMemberMap.toDomain)\n    );\n\n    return Team.create(\n      {\n        name: dbTeam.name,\n        createdBy: User.createUserID(dbTeam.created_by),\n        creationTs: dbTeam.creation_ts,\n        updatedBy: User.createUserID(dbTeam.updated_by),\n        updateTs: dbTeam.update_ts,\n        locationID: dbTeam.location_id,\n        members,\n        isDeleted: dbTeam.is_deleted,\n      },\n      dbTeam.id\n    );\n  }\n\n  static toPersistence(team: Team): Prisma.teamCreateInput {\n    return {\n      name: team.name,\n      is_deleted: team.isDeleted,\n      location: {\n        connect: {\n          location_id: team.locationID,\n        },\n      },\n      creation_ts: team.creationTs,\n      update_ts: team.updateTs,\n      createdByUser: { connect: { id: team.createdBy } },\n      updatedByUser: { connect: { id: team.updatedBy } },\n    };\n  }\n}\n\nexport class TeamMemberMap {\n  static toDomain(dbMember: DbTeam[\"team_member\"][number]): PersistedEntity<TeamMember> {\n    return TeamMember.create(\n      {\n        createdBy: User.createUserID(dbMember.created_by),\n        creationTs: dbMember.creation_ts,\n        userID: User.createUserID(dbMember.user_id),\n        isManager: dbMember.is_manager,\n        areaDisciplines: Collection.create(\n          dbMember.team_member_area_discipline.map(({ area_id, location_discipline }) => ({\n            areaID: area_id,\n            disciplineID: location_discipline.discipline_id,\n          }))\n        ),\n      },\n      dbMember.id\n    );\n  }\n\n  static toPersistence(teamID: number, member: TeamMember): Prisma.team_memberUncheckedCreateInput {\n    return {\n      team_id: teamID,\n      user_id: member.userID,\n      creation_ts: member.creationTs,\n      created_by: member.createdBy,\n      is_manager: member.isManager,\n      // team_member_area_discipline: {\n      //   createMany: {\n      //     data: member.areaDisciplines.map(({ areaID, disciplineID }) => ({\n      //       area_id: areaID,\n      //       location_discipline_id: disciplineID,\n      //     })),\n      //   },\n      // },\n    };\n  }\n}\n```\n\n```ts atom-web/src/server/new-structure/application/use-cases/scope/get/use-case.ts\nimport { inject, injectable } from \"inversify\";\nimport { Scope as ScopeType, User } from \"@atom/types\";\nimport { keyBy } from \"lodash\";\n\nimport { BaseUseCase } from \"../../../../framework/application/use-case\";\nimport { SessionUser } from \"../../../../framework/application/session-user\";\nimport container from \"../../../../framework/inversify/inversify.config\";\nimport { AuthzService } from \"../../../../framework/application/authz.service\";\nimport { ScopeService } from \"../../../../domain/scope/services/scope.service\";\nimport { OperationLogRepo } from \"../../../../framework/application/operation-log/operation-log.repo\";\nimport { IUserRepo } from \"../../../../application/repositories/user.repo\";\nimport TYPES from \"../../../../framework/inversify/types\";\nimport { EntityNotFoundError } from \"../../../../../utils/errors\";\nimport { PersistedUser } from \"../../../../domain/user/user.entity\";\n\n@injectable()\nexport class UseCase implements BaseUseCase<ScopeType.GetReq, Promise<any>> {\n  constructor(\n    @inject(AuthzService) private readonly authzService: AuthzService,\n    @inject(ScopeService) private readonly scopeService: ScopeService,\n    @inject(SessionUser) private readonly sessionUser: SessionUser,\n    @inject(TYPES.IUserRepo) private readonly userRepo: IUserRepo,\n    @inject(TYPES.IOperationLogRepo) private readonly operationLogRepo: OperationLogRepo\n  ) {}\n\n  public async execute(request: ScopeType.GetReq) {\n    const { locationID, scopeID } = request;\n\n    this.authzService.authorizeActionOrThrow({\n      action: \"read\",\n      subject: \"scope\",\n      conditions: { locationID, scopeID },\n      errorMessage: \"User can't read scope in this location.\",\n    });\n\n    const scopeAggregate = await this.scopeService.getScopeAggregate(scopeID);\n    const { scope, attachments, teams } = scopeAggregate;\n\n    if (scope.location.id !== locationID) {\n      throw new EntityNotFoundError(\"Scope\");\n    }\n\n    const attachmentUserIDs = (attachments ?? []).map((a) => a.createdBy);\n    const reviewerUserIDs = (scope.reviewers ?? []).map((r) => r.userID);\n    const stakeHolderUserIDs = scope.stakeholders.map((s) => s.userID);\n    const teamMemberUserIDs = teams.flatMap((t) => t.members.map((m) => m.userID));\n    const relevantUserIDs = [\n      scope.createdBy,\n      scope.updatedBy,\n      ...attachmentUserIDs,\n      ...reviewerUserIDs,\n      ...stakeHolderUserIDs,\n      ...teamMemberUserIDs,\n    ].filter(Boolean) as User.ID[];\n\n    const users: Record<string, PersistedUser> = keyBy(await this.userRepo.getManyByIDs(relevantUserIDs), \"id\");\n\n    const lastOperation =\n      \"operationLogID\" in scope ? await this.operationLogRepo.getLastOperation(scope?.operationLogID) : undefined;\n\n    return {\n      ...scopeAggregate,\n      lastOperation,\n      users,\n      isExternalUser: this.sessionUser.isExternal,\n    };\n  }\n}\n\ncontainer.bind<UseCase>(UseCase).toSelf();\n```\n\n```ts atom-web/src/server/new-structure/application/use-cases/scope/get/presenter.ts\nimport { BasePresenter, PresenterOutput } from \"../../../../framework/infrastructure/presenter\";\nimport { UseCase } from \"./use-case\";\nimport { Scope } from \"@atom/types\";\nimport { ScopeAggregate } from \"../../../../domain/scope/entities/scope-aggregate.entity\";\nimport { PersistedUser } from \"../../../../domain/user/user.entity\";\n\ntype UseCaseOutput = Awaited<ReturnType<typeof UseCase.prototype.execute>>;\n\nexport class Presenter extends BasePresenter<typeof UseCase> {\n  protected responseDTO = Scope.getRes;\n\n  transform({\n    scope,\n    project,\n    request,\n    attachments,\n    disciplines,\n    reviewFlow,\n    actions,\n    lastOperation,\n    teams,\n    users,\n    isExternalUser,\n  }: UseCaseOutput): PresenterOutput<Scope.GetRes> {\n    const createdBy = users[scope.createdBy];\n    const updatedBy = scope.updatedBy && users[scope.updatedBy];\n\n    const enrichedReviewers = scope.reviewers?.map((reviewer) => ({\n      ...reviewer,\n      user: users[reviewer.userID],\n    }));\n\n    if (isExternalUser) {\n      return {\n        ...this.getRestrictedScope(scope, users),\n        reviewers: enrichedReviewers,\n        createdBy,\n        updatedBy,\n        lastOperation,\n      };\n    }\n\n    const enrichedAttachments = attachments?.map((attachment) => ({\n      ...attachment.toObject(),\n      createdBy: users[attachment.createdBy],\n    }));\n\n    const enrichedStakeholders = scope.stakeholders?.map((stakeholder) => ({\n      ...stakeholder.toObject(),\n      user: users[stakeholder.userID],\n    }));\n\n    const enrichedTeam = teams?.map((team) => ({\n      ...team.toObject(),\n      members: team.members.map((member) => ({\n        ...member.toObject(),\n        user: users[member.userID],\n      })),\n    }));\n\n    return {\n      ...scope.toObject(),\n      project: project?.toObject(),\n      request: request && {\n        ...request.toObject(),\n        title: request.getTitle(),\n        typePrefix: request.requestType.prefix,\n      },\n      disciplines: disciplines?.map((discipline) => discipline.toObject()),\n      createdBy,\n      updatedBy,\n      reviewers: enrichedReviewers,\n      attachments: enrichedAttachments,\n      stakeholders: enrichedStakeholders,\n      teams: enrichedTeam,\n      reviewFlow: reviewFlow?.toObject(),\n      actions,\n      lastOperation,\n    };\n  }\n\n  private getRestrictedScope(scope: ScopeAggregate, users: Record<string, PersistedUser>) {\n    const enrichedStakeholders = scope.stakeholders?.map((stakeholder) => ({\n      ...stakeholder.toObject(),\n      user: users[stakeholder.userID],\n    }));\n\n    return {\n      title: scope.title,\n      creationTs: scope.creationTs,\n      location: scope.location,\n      stakeholders: enrichedStakeholders,\n      suppliers: scope.suppliers,\n      status: scope.status,\n    };\n  }\n}\n```\n\n```ts atom-web/src/server/new-structure/application/use-cases/scope/get/system.test.ts\nimport {\n  ScopePoTestContext,\n  setupScopePoTestContext,\n  teardownScopePoTestContext,\n} from \"../../../../../scope/scope-po.test.context\";\nimport { Scope as ScopeType, Project, User } from \"@atom/types\";\nimport { Scope } from \"../../../../../scope/scope.test.utils\";\nimport { AttachmentMock } from \"../../../../../test/mocks/types/attachment\";\nimport { ReqCreateRequestInstanceMock } from \"../../request/instance/test/test.utils\";\nimport {\n  RequestInstanceTestContext,\n  setupRequestInstanceTestContext,\n  teardownRequestInstanceTestContext,\n} from \"../../request/instance/test/test.context\";\n\ndescribe(\"Get Scope\", () => {\n  let ctx: ScopePoTestContext;\n  let requestInstanceCtx: RequestInstanceTestContext;\n  let scopeID: number;\n  let requestID: number;\n  let teamManagerID: User.ID;\n  let projectID: number;\n  let attachmentID: string;\n\n  beforeAll(async () => {\n    ctx = await setupScopePoTestContext();\n    requestInstanceCtx = await setupRequestInstanceTestContext();\n\n    const { l360_trt_id, location_id } = ctx;\n\n    teamManagerID = (await db.user.create({ l360_trt_id }, { roles: [\"Project Manager\"], location_id })).user_id;\n    const teamWithStakeholdersInProjectID = (\n      await ctx.admin.team.create(ctx.location_id, {\n        name: \"Team selected in project\",\n        members: [\n          { userID: teamManagerID, isManager: true, areaDisciplines: [] },\n          { userID: ctx.user_id, isManager: false, areaDisciplines: [] },\n        ],\n      })\n    ).id;\n    const teamWithStakeholderInProject = await ctx.admin.team.get(ctx.location_id, teamWithStakeholdersInProjectID);\n\n    attachmentID = (\n      await db.attachment.create(\n        AttachmentMock({ created_by: ctx.user_id, attachment_id: \"4dcd43a8-0050-46c1-959c-9e43eb74e1c3\" })\n      )\n    ).attachment_id;\n\n    requestID = (\n      await ctx.admin.requestInstance.createRequestInstance(ReqCreateRequestInstanceMock(requestInstanceCtx))\n    ).requestID;\n\n    projectID = (\n      await ctx.admin.project.create({\n        title: \"Test Project Title\",\n        location_id: ctx.location_id,\n        budget_code_ids: [],\n        stakeholders: [\n          {\n            stakeholder_type_id: Project.StakeholderType.TeslaResponsiblePerson,\n            user_id: ctx.user_id,\n          },\n          {\n            team_member_id: teamWithStakeholderInProject.members[0].id,\n          },\n          {\n            team_member_id: teamWithStakeholderInProject.members[1].id,\n          },\n        ],\n      })\n    ).project_id;\n\n    scopeID = (\n      await ctx.admin.scope.create(\n        Scope(\n          {\n            ...ctx,\n            selected_reviewer_ids: ctx.selected_reviewer_ids,\n          },\n          {\n            title: \"Test Scope Title\",\n            description: \"Test Scope\",\n            design_change_notice: \"Test DCN\",\n            request_id: requestID,\n\n            access_date: new Date().toISOString(),\n            award_need_date: new Date().toISOString(),\n            completion_date: new Date().toISOString(),\n\n            // Finance fields\n            spend_amount: 1000,\n            spend_review_date: new Date().toISOString(),\n            compensation_id: 1,\n            spend_type_ids: [1],\n            spend_category_id: 1,\n            competitiveness_id: 1,\n            purchase_order: {\n              purchase_order_id: ctx.po1_id,\n              purchase_order_line_ids: [ctx.po1Line1_id],\n            },\n\n            attachments: [\n              {\n                id: attachmentID,\n              },\n            ],\n            project_id: projectID,\n          }\n        )\n      )\n    ).scope_id;\n  });\n\n  afterAll(async () => {\n    await db.scope.delete(scopeID);\n    await db.project.delete(projectID);\n    await db.requestInstance.delete(requestID);\n    await db.attachment.delete(attachmentID);\n    await db.user.delete(teamManagerID);\n\n    await teardownRequestInstanceTestContext(requestInstanceCtx);\n    await teardownScopePoTestContext(ctx);\n  });\n\n  describe(\"get scope\", () => {\n    let scope: ScopeType.GetRes;\n\n    beforeEach(async () => {\n      scope = await ctx.admin.scope.get(scopeID, ctx.location_id);\n    });\n\n    it(\"should have the correct ID\", () => {\n      expect(scope.id).toBe(scopeID);\n    });\n\n    it(\"should have basic scope properties\", () => {\n      expect(scope).toMatchObject({\n        title: \"Test Scope Title\",\n        description: \"Test Scope\",\n        priority: \"undetermined\",\n        decisionChangeNotice: \"Test DCN\",\n        supplierUserCount: 0,\n      });\n    });\n\n    it(\"should have creation and update data\", () => {\n      expect(scope.createdBy).toMatchObject({\n        id: expect.anything(),\n        email: expect.any(String),\n        name: expect.any(String),\n      });\n\n      expect(scope.updatedBy).toMatchObject({\n        id: expect.anything(),\n        email: expect.any(String),\n        name: expect.any(String),\n      });\n\n      expect(scope.creationTs).toBeDefined();\n      expect(new Date(scope.creationTs).toString()).not.toBe(\"Invalid Date\");\n    });\n\n    it(\"should have correct project information\", () => {\n      expect(scope.project).toMatchObject({\n        id: projectID,\n        title: \"Test Project Title\",\n      });\n    });\n\n    it(\"should have stakeholders information\", () => {\n      expect(scope.stakeholders).toBeArray();\n\n      const hasRequiredStakeholders =\n        scope.stakeholders?.some((s) => s?.type.key === \"tesla_responsible_person\") &&\n        scope.stakeholders?.some((s) => s?.type.key === \"buyer\");\n\n      expect(hasRequiredStakeholders).toBeTrue();\n    });\n\n    it(\"should have location information\", () => {\n      expect(scope.location).toMatchObject({\n        id: ctx.location_id,\n        name: expect.any(String),\n        description: expect.any(String),\n        currency: \"USD\",\n      });\n\n      expect(scope.location.warpEntities).toBeArray();\n      expect(scope.location.warpEntities.length).toBePositive();\n      scope.location.warpEntities.forEach((entity) => {\n        expect(entity).toMatchObject({\n          id: expect.any(Number),\n          name: expect.any(String),\n          code: expect.any(String),\n        });\n      });\n    });\n\n    it(\"should have area information\", () => {\n      expect(scope.area).toMatchObject({\n        id: expect.any(Number),\n        name: expect.any(String),\n        abbreviation: expect.any(String),\n      });\n    });\n\n    it(\"should have finance information\", () => {\n      expect(scope.finance).toBeDefined();\n\n      expect(scope.finance).toMatchObject({\n        spendAmount: expect.any(Number),\n        spendReviewDate: expect.any(String),\n        compensation: {\n          id: expect.any(Number),\n          name: expect.any(String),\n        },\n        spendCategory: {\n          id: expect.any(Number),\n          category: expect.any(String),\n        },\n        competitiveness: {\n          id: expect.any(Number),\n          name: expect.any(String),\n          class: expect.any(String),\n        },\n      });\n\n      expect(new Date(scope.finance!.spendReviewDate!).toString()).not.toBe(\"Invalid Date\");\n\n      expect(scope.finance!.spendTypes).toSatisfyAll((spendType) => {\n        return spendType.id && typeof spendType.type === \"string\";\n      });\n\n      const po = scope.finance!.warpPurchaseOrders![0];\n      expect(po).toMatchObject({\n        id: expect.any(Number),\n        totalAmountOrdered: expect.any(Number),\n        connectedPOLinesAmountOrdered: expect.any(Number),\n        connectedPOLines: expect.arrayContaining([expect.any(Object)]),\n      });\n\n      const poLine = scope.finance!.warpPurchaseOrders![0].connectedPOLines![0];\n      expect(poLine).toMatchObject({\n        purchaseOrderLineID: expect.any(Number),\n        lineNumber: expect.any(Number),\n        orderQuantity: expect.any(Number),\n        unitPrice: expect.any(Number),\n        totalAmountOrdered: expect.any(Number),\n        shortText: expect.any(String),\n      });\n    });\n\n    it(\"should have correct attachment information\", () => {\n      expect(scope.attachments?.at(0)).toBeDefined();\n      expect(scope.attachments![0]).toMatchObject({\n        id: expect.any(String),\n        filename: expect.any(String),\n        extension: expect.any(String),\n        description: expect.any(String),\n      });\n    });\n\n    it(\"should have correct discipline information\", () => {\n      expect(scope.disciplines?.[0]).toBeDefined();\n      expect(scope.disciplines![0]).toMatchObject({\n        id: expect.anything(),\n        name: expect.any(String),\n        type: expect.any(String),\n        abbreviation: expect.any(String),\n      });\n    });\n\n    it(\"should have correct request information\", () => {\n      expect(scope.request).toMatchObject({\n        id: expect.any(Number),\n        title: expect.any(String),\n        typePrefix: expect.any(String),\n      });\n    });\n\n    it(\"should have correct milestone information\", () => {\n      expect(scope.milestones?.completionDate).toBeDefined();\n      expect(new Date(scope.milestones!.completionDate!).toString()).not.toBe(\"Invalid Date\");\n\n      expect(scope.milestones?.awardNeedDate).toBeDefined();\n      expect(new Date(scope.milestones!.awardNeedDate!).toString()).not.toBe(\"Invalid Date\");\n\n      expect(scope.milestones?.accessDate).toBeDefined();\n      expect(new Date(scope.milestones!.accessDate!).toString()).not.toBe(\"Invalid Date\");\n    });\n\n    it(\"should have correct rationale information\", () => {\n      expect(scope.rationale).toMatchObject({\n        id: expect.any(Number),\n        name: expect.any(String),\n        type: expect.any(String),\n      });\n    });\n\n    it(\"should have correct review template information\", () => {\n      expect(scope.reviewTemplate).toMatchObject({\n        id: expect.any(Number),\n        name: expect.any(String),\n      });\n    });\n\n    it(\"should have correct reviewer information\", () => {\n      expect(scope.reviewers).toBeArray();\n\n      scope.reviewers?.forEach((reviewer) => {\n        expect(reviewer).toMatchObject({\n          user: {\n            id: expect.any(Number),\n            email: expect.any(String),\n            name: expect.any(String),\n          },\n          reviewFlowStepDecisionID: expect.any(Number),\n          reviewerType: {\n            id: expect.any(Number),\n            type: expect.any(String),\n            name: expect.any(String),\n          },\n        });\n      });\n    });\n\n    it(\"should have correct action information\", () => {\n      expect(scope.actions).toBeDefined();\n      expect(scope.actions).toMatchObject({\n        canRequestReview: expect.any(Boolean),\n        canCancelReview: expect.any(Boolean),\n        canReview: expect.any(Boolean),\n        canComplete: expect.any(Boolean),\n        canRelease: expect.any(Boolean),\n        canRevoke: expect.any(Boolean),\n        canCancel: expect.any(Boolean),\n        canArchive: expect.any(Boolean),\n        canUpdate: expect.any(Boolean),\n        canUpdatePurchaseOrder: expect.any(Boolean),\n        canUpdateReviewTemplate: expect.any(Boolean),\n        canUpdateReviewers: expect.any(Boolean),\n      });\n    });\n\n    it(\"should have correct status information\", () => {\n      expect(scope.status).toMatchObject({\n        currentStatus: {\n          id: expect.any(Number),\n          type: expect.any(String),\n          typeDisplayName: expect.any(String),\n        },\n      });\n\n      expect(scope.status.history).toBeArray();\n      expect(scope.status.history.length).toBeGreaterThanOrEqual(0);\n\n      expect(scope.status.history[0]).toMatchObject({\n        id: expect.any(Number),\n        type: expect.any(String),\n        typeDisplayName: expect.any(String),\n        createdBy: expect.any(Number),\n        creationTs: expect.any(String),\n      });\n\n      expect(new Date(scope.status.history[0].creationTs).toString()).not.toBe(\"Invalid Date\");\n    });\n\n    it(\"should have correct operation log information\", () => {\n      expect(scope.lastOperation).toMatchObject({\n        id: expect.any(Number),\n        details: expect.any(Object),\n      });\n\n      if (scope.lastOperation?.creationTS) {\n        expect(new Date(scope.lastOperation.creationTS).toString()).not.toBe(\"Invalid Date\");\n      }\n    });\n\n    describe(\"supplier scope\", () => {\n      let supplierScope: ScopeType.GetRes;\n      let supplierScopeID: number;\n\n      beforeAll(async () => {\n        supplierScopeID = (\n          await ctx.admin.scope.create(\n            Scope(ctx, {\n              purchase_order: {\n                supplier_id: ctx.supplier_id,\n              },\n            })\n          )\n        ).scope_id;\n      });\n\n      beforeEach(async () => {\n        supplierScope = await ctx.admin.scope.get(supplierScopeID, ctx.location_id);\n      });\n\n      afterAll(async () => {\n        await db.scope.delete(supplierScopeID);\n      });\n\n      it(\"should have correct supplier information\", () => {\n        expect(supplierScope.suppliers?.[0]).toBeDefined();\n\n        expect(supplierScope.suppliers![0]).toMatchObject({\n          id: expect.anything(),\n          name: expect.any(String),\n          companies: expect.arrayContaining([\n            {\n              id: expect.any(Number),\n              name: expect.any(String),\n              code: expect.any(String),\n              isActive: expect.any(Boolean),\n            },\n          ]),\n        });\n      });\n    });\n  });\n});\n```\n\ngive me tests for checking stakeholder users and teams in the scope\n\n userID: ctx.user_id, isManager: true, areaDisciplines: [] },\n          { userID: teamManagerID, isManager: false, areaDisciplines: [] },\n        ],\n      })\n    ).id;\n\n    // Update the scope to include the team\n    await ctx.admin.scope.update(scopeID, ctx.location_id, {\n      team_ids: [teamID],\n    });\n  });\n\n  beforeEach(async () => {\n    scope = await ctx.admin.scope.get(scopeID, ctx.location_id);\n  });\n\n  afterAll(async () => {\n    // Clean up the team if needed\n    await db.team.delete(teamID);\n  });\n\n  it(\"should return stakeholders with correct user data\", () => {\n    expect(scope.stakeholders).toBeArray();\n    expect(scope.stakeholders.length).toBeGreaterThan(0);\n    \n    scope.stakeholders.forEach(stakeholder => {\n      expect(stakeholder).toMatchObject({\n        id: expect.any(Number),\n        userID: expect.any(Number),\n        type: expect.objectContaining({\n          id: expect.any(Number),\n          key: expect.any(String),\n          name: expect.any(String)\n        }),\n        user: expect.objectContaining({\n          id: expect.any(Number),\n          name: expect.any(String),\n          email: expect.any(String)\n        })\n      });\n\n      // Verify that user ID matches between stakeholder and user object\n      expect(stakeholder.userID).toBe(stakeholder.user.id);\n    });\n  });\n\n  it(\"should return teams associated with the scope\", () => {\n    expect(scope.teams).toBeArray();\n    expect(scope.teams.length).toBeGreaterThan(0);\n    \n    // Find our specific team\n    const scopeTeam = scope.teams.find(team => team.name === \"Scope Team\");\n    expect(scopeTeam).toBeDefined();\n    expect(scopeTeam?.id).toBe(teamID);\n  });\n\n  it(\"should include team members with their user data\", () => {\n    const scopeTeam = scope.teams.find(team => team.name === \"Scope Team\");\n    expect(scopeTeam?.members).toBeArray();\n    expect(scopeTeam?.members.length).toBe(2);\n\n    scopeTeam?.members.forEach(member => {\n      expect(member).toMatchObject({\n        id: expect.any(Number),\n        userID: expect.any(Number),\n        isManager: expect.any(Boolean),\n        areaDisciplines: expect.any(Array),\n        user: expect.objectContaining({\n          id: expect.any(Number),\n          name: expect.any(String),\n          email: expect.any(String)\n        })\n      });\n\n      // Verify that user ID matches between member and user object\n      expect(member.userID).toBe(member.user.id);\n    });\n\n    // Verify that we have the expected users in the team\n    const memberUserIds = scopeTeam?.members.map(m => m.userID);\n    expect(memberUserIds).toContain(ctx.user_id);\n    expect(memberUserIds).toContain(teamManagerID);\n  });\n\n  it(\"should have a team with the correct manager flag\", () => {\n    const scopeTeam = scope.teams.find(team => team.name === \"Scope Team\");\n    const manager = scopeTeam?.members.find(member => member.isManager);\n    const nonManager = scopeTeam?.members.find(member => !member.isManager);\n\n    expect(manager).toBeDefined();\n    expect(nonManager).toBeDefined();\n    \n    expect(manager?.userID).toBe(ctx.user_id);\n    expect(nonManager?.userID).toBe(teamManagerID);\n  });\n\n  it(\"should include team context members based on area and discipline\", async () => {\n    // This test would be more complex and would depend on how your \n    // team context filtering works. Here's a simplified example:\n\n    const areaID = scope.area.id;\n    const disciplineID = scope.disciplines[0].id;\n\n    // Create a team with area-discipline specific members\n    const contextTeamID = (\n      await ctx.admin.team.create(ctx.location_id, {\n        name: \"Context Team\",\n        members: [\n          { \n            userID: ctx.user_id, \n            isManager: false, \n            areaDisciplines: [{ areaID, disciplineID }] \n          }\n        ],\n      })\n    ).id;\n\n    // Update the scope to include this team\n    await ctx.admin.scope.update(scopeID, ctx.location_id, {\n      team_ids: [teamID, contextTeamID],\n    });\n\n    // Get the updated scope\n    const updatedScope = await ctx.admin.scope.get(scopeID, ctx.location_id);\n    \n    // Find our context team\n    const contextTeam = updatedScope.teams.find(team => team.name === \"Context Team\");\n    expect(contextTeam).toBeDefined();\n    expect(contextTeam?.members[0].areaDisciplines).toContainEqual(\n      expect.objectContaining({ areaID, disciplineID })\n    );\n\n    // Clean up\n    await db.team.delete(contextTeamID);\n  });\n});\n```\n\nThis set of tests checks:\n\n1. That stakeholders in the scope have properly associated user data\n2. That teams are correctly included in the scope response\n3. That team members have their correct user information\n4. That the manager flag on team members is properly set\n5. That teams with area-discipline specific members are correctly represented\n\nThese tests cover the essentials of stakeholder users and teams in the scope, ensuring that the presenter correctly transforms the domain entities into the response DTOs with all the necessary relationships and user data.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":799}}},{"id":{"replica_id":0,"value":55},"start":26278,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":800}}},{"id":{"replica_id":0,"value":56},"start":31281,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":801}}}],"summary":"I'll create test cases specifically for checking stakeholders and teams in a scope. Here's what I suggest:","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":4102},"icon":"File","label":"atom-web/src/server/new-structure/domain/team/entities/team.entity.ts","metadata":{"path":"atom-web/src/server/new-structure/domain/team/entities/team.entity.ts"}},{"range":{"start":4103,"end":7044},"icon":"File","label":"atom-web/src/server/new-structure/domain/team/team.map.ts","metadata":{"path":"atom-web/src/server/new-structure/domain/team/team.map.ts"}},{"range":{"start":7045,"end":10018},"icon":"File","label":"atom-web/src/server/new-structure/application/use-cases/scope/get/use-case.ts","metadata":{"path":"atom-web/src/server/new-structure/application/use-cases/scope/get/use-case.ts"}},{"range":{"start":10019,"end":12872},"icon":"File","label":"atom-web/src/server/new-structure/application/use-cases/scope/get/presenter.ts","metadata":{"path":"atom-web/src/server/new-structure/application/use-cases/scope/get/presenter.ts"}},{"range":{"start":12873,"end":26208},"icon":"File","label":"atom-web/src/server/new-structure/application/use-cases/scope/get/system.test.ts","metadata":{"path":"atom-web/src/server/new-structure/application/use-cases/scope/get/system.test.ts"}}]}