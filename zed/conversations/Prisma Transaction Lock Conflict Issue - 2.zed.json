{"id":"c50ad91c-903b-4f2c-a745-ea266ca4a1d6","zed":"context","version":"0.4.0","text":"\n\n\n```ts atom-web/src/server/new-structure/application/repositories/document.repo.ts\nimport { accessibleBy } from \"@casl/prisma\";\nimport { Prisma } from \"@prisma/client\";\nimport { inject, injectable } from \"inversify\";\nimport _, { isEmpty } from \"lodash\";\nimport { DBClient } from \"../../../config/database/client\";\nimport { DocumentNumberAlreadyExistsError, EntityNotFoundError } from \"../../../utils/errors\";\nimport { CompanyMap } from \"../../domain/company/company.map\";\nimport { CSIDivisionMap } from \"../../domain/csi-division/csi-division.map\";\nimport { DisciplineMap } from \"../../domain/discipline/discipline.map\";\nimport { DocumentRevisionLinkType } from \"../../domain/document/entities/doc-revision-link.entity\";\nimport { DocRevision } from \"../../domain/document/entities/doc-revision.entity\";\nimport { Document, DocumentProps } from \"../../domain/document/entities/document.entity\";\nimport { File } from \"../../domain/document/entities/file.entity\";\nimport { RevisionStatusType, TRevisionStatusType } from \"../../domain/document/entities/revision-status-type.entity\";\nimport { DocRevisionMap } from \"../../domain/document/mappers/doc-revision.map\";\nimport { DocumentMap } from \"../../domain/document/mappers/document.map\";\nimport { FileMap } from \"../../domain/document/mappers/file.map\";\nimport { IDocumentRepo } from \"../../domain/document/repos/document.repo\";\nimport { ReferencedDocData } from \"../../domain/document/services/document.service\";\nimport { AreaMap } from \"../../domain/location/mappers/area.map\";\nimport { LevelMap } from \"../../domain/location/mappers/level.map\";\nimport { ILocationRepo } from \"../../domain/location/repos/location.repo\";\nimport { PersistedProject, Project } from \"../../domain/project/entities/project.entity\";\nimport {\n  PersistedRequestInstance,\n  RequestInstance,\n} from \"../../domain/request/instance/entities/request-instance.entity\";\nimport { PersistedScope, Scope } from \"../../domain/scope/entities/scope.entity\";\nimport { DocumentPurposeMap } from \"../../domain/settings/document-purpose/map\";\nimport { DocumentTypeMap } from \"../../domain/settings/document-type/map\";\nimport { LocationDocumentPurpose } from \"../../domain/settings/locations/document-purpose/entity\";\nimport { LocationDocumentPurposeMap } from \"../../domain/settings/locations/document-purpose/map\";\nimport { LocationProgramMap } from \"../../domain/settings/locations/program/map\";\nimport { ProgramMap } from \"../../domain/settings/program/map\";\nimport { User } from \"../../domain/user/user.entity\";\nimport { UserMap } from \"../../domain/user/user.map\";\nimport { AuthzService } from \"../../framework/application/authz.service\";\nimport { FilterDTOPrisma } from \"../../framework/application/get-many\";\nimport { PaginatedFilteredDTO, PaginatedFilteredDTOResult } from \"../../framework/application/paginated-filtered-dto\";\nimport { Collection } from \"../../framework/domain/collection\";\nimport { assertPersistency, PersistedEntity } from \"../../framework/domain/entity\";\nimport { BaseRepo } from \"../../framework/infrastructure/base-repo\";\nimport TYPES from \"../../framework/inversify/types\";\nimport { companyQueryInclude } from \"./company.repo\";\nimport { userQueryInclude } from \"./user.repo\";\nimport {\n  DocumentSubmittalCategoryMap,\n  DocumentSubmittalDetailMap,\n  DocumentSubmittalTypeMap,\n} from \"../../domain/settings/locations/document-submittal-metadata/submittal.map\";\nimport { DocumentFieldType, DocumentNumberingScheme } from \"@atom/types\";\n\nexport const getDocumentQueryInclude = (authzService: AuthzService) => {\n  return {\n    document_package_document: true,\n    document_program: true,\n    document_revision: {\n      where: accessibleBy(authzService.getUserAbility(), \"read\").document_revision,\n      include: {\n        project_document_revision: {\n          include: {\n            project: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        scope_document_revision: {\n          include: {\n            scope: {\n              select: {\n                title: true,\n              },\n            },\n          },\n        },\n        request_document_revision: {\n          include: {\n            request: {\n              select: {\n                request_form_value: {\n                  select: {\n                    title: true,\n                  },\n                },\n              },\n            },\n          },\n        },\n        document_revision_status: {\n          include: {\n            document_revision_status_type: true,\n          },\n        },\n        file: {\n          select: {\n            extension: true,\n          },\n        },\n        location_document_purpose: {\n          include: {\n            document_purpose: true,\n          },\n        },\n      },\n    },\n    document_additional_area: {\n      select: {\n        area_id: true,\n      },\n    },\n    document_csi_division: true,\n    document_submittal_category: true,\n    document_submittal_type: true,\n    document_submittal_detail: true,\n  } satisfies Prisma.Args<typeof DBClient.document, \"findMany\">[\"include\"];\n};\nconst typeToProperty = {\n  [DocumentFieldType.Type.SITE]: \"siteID\",\n  [DocumentFieldType.Type.BUILDING]: \"buildingID\",\n  [DocumentFieldType.Type.AREA]: \"areaID\",\n  [DocumentFieldType.Type.AREA_DETAIL]: \"areaDetailID\",\n  [DocumentFieldType.Type.LEVEL]: \"levelID\",\n  [DocumentFieldType.Type.PROGRAM]: \"locationProgramIDs\",\n  [DocumentFieldType.Type.TYPE]: \"typeID\",\n  [DocumentFieldType.Type.DISCIPLINE]: \"disciplineID\",\n} as const satisfies Partial<{\n  [key in (typeof DocumentFieldType.Type)[keyof typeof DocumentFieldType.Type]]: string;\n}>;\nconst propertyToColumn = {\n  siteID: \"site_id\",\n  buildingID: \"building_id\",\n  areaID: \"area_id\",\n  areaDetailID: \"area_detail_id\",\n  levelID: \"level_id\",\n  locationProgramIDs: \"document_program\",\n  typeID: \"document_type_id\",\n  disciplineID: \"discipline_id\",\n} as const;\n\nexport type DocumentMetadata = {\n  number: string;\n  buildingID: number;\n  siteID: number | null;\n  areaID: number;\n  areaDetailID: number | null;\n  levelID: number;\n  locationProgramIDs: number[];\n  typeID: number;\n  disciplineID: number;\n  locationDocumentPurposeID: number;\n};\n\n@injectable()\nexport class DocumentRepo extends BaseRepo implements IDocumentRepo {\n  constructor(\n    @inject(TYPES.DBClient) protected readonly db: typeof DBClient,\n    @inject(TYPES.ILocationRepo) protected readonly locationRepo: ILocationRepo,\n    @inject(AuthzService) private readonly authzService: AuthzService,\n    @inject(\"DocumentFilterDTOPrisma\")\n    private readonly filterDTOPrisma: FilterDTOPrisma<DocumentProps>\n  ) {\n    super(db);\n  }\n\n  private readonly baseQuery = { is_deleted: 0 } satisfies Prisma.documentWhereInput;\n\n  async getByID(id: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: id,\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getManyByIDs(ids: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_id: {\n              in: ids,\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByDocumentNumbers(documentNumbers: string[], locationID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          { location_id: locationID },\n          {\n            document_number: { in: documentNumbers },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByPackageID(packageID: number): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_package_document: {\n              some: {\n                package_id: packageID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getByRevisionID(revisionID: number): Promise<PersistedEntity<Document>> {\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: revisionID,\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    if (!dbDocument) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getByRevisionIDs(revisionIDs: number[]): Promise<PersistedEntity<Document>[]> {\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          {\n            document_revision: {\n              some: {\n                document_revision_id: { in: revisionIDs },\n              },\n            },\n          },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n    });\n\n    return dbDocuments.map(DocumentMap.toDomain);\n  }\n\n  async getMany(paginatedFilteredDTO: PaginatedFilteredDTO<Document>): Promise<PaginatedFilteredDTOResult<Document>> {\n    const { filters, parentEntity, locationID, excludeParentEntity } = paginatedFilteredDTO;\n    const filterQuery = this.filterDTOPrisma.createPrismaQuery(filters.filterDTO);\n    const parentSelect = parentEntity && this.getParentSelect(parentEntity);\n    const excludeParent = excludeParentEntity && this.getParentSelect(excludeParentEntity);\n\n    const query: Prisma.documentWhereInput = {\n      AND: [\n        accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n        this.baseQuery,\n        filterQuery,\n        locationID ? { location_id: locationID } : {},\n        excludeParent\n          ? {\n              document_revision: {\n                some: {\n                  [excludeParent.table_name]: {\n                    none: {\n                      [excludeParent.ref_name]: excludeParent.id,\n                    },\n                  },\n                },\n              },\n            }\n          : {},\n        {\n          OR: [\n            parentSelect\n              ? {\n                  document_revision: {\n                    some: {\n                      [parentSelect.table_name]: {\n                        some: {\n                          [parentSelect.ref_name]: parentSelect.id,\n                        },\n                      },\n                    },\n                  },\n                }\n              : {},\n            filters.scopeIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.scopeIDs,\n                  refName: \"scope_id\",\n                  tableName: \"scope_document_revision\",\n                })\n              : {},\n            filters.requestIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.requestIDs,\n                  refName: \"request_id\",\n                  tableName: \"request_document_revision\",\n                })\n              : {},\n            filters.projectIDs\n              ? this.getParentSelectFromIDs({\n                  ids: filters.projectIDs,\n                  refName: \"project_id\",\n                  tableName: \"project_document_revision\",\n                })\n              : {},\n          ],\n        },\n      ],\n    };\n\n    let pagination = {};\n\n    if (paginatedFilteredDTO.page && paginatedFilteredDTO.pageSize) {\n      pagination = {\n        take: paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize,\n        skip: (paginatedFilteredDTO.page - 1) * paginatedFilteredDTO.pageSize,\n      };\n    }\n\n    const orderBy = { document_id: \"desc\" } as const;\n    const dbDocumentList = await this.db.document.findMany({\n      where: query,\n      select: { document_id: true },\n      orderBy,\n      take: paginatedFilteredDTO.limit || 1000,\n      skip: \"skip\" in pagination ? (pagination.skip as number) : 0,\n    });\n\n    const count = dbDocumentList.length + (\"skip\" in pagination ? (pagination.skip as number) : 0);\n\n    const dbDocuments = await this.db.document.findMany({\n      where: {\n        document_id: {\n          in: dbDocumentList\n            .slice(0, paginatedFilteredDTO.limit || paginatedFilteredDTO.pageSize || 10)\n            .map(({ document_id }) => document_id),\n        },\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy,\n    });\n\n    return { result: dbDocuments.map(DocumentMap.toDomain), count };\n  }\n\n  async save(document: Document) {\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation)\n      throw new DocumentNumberAlreadyExistsError(\n        `A document with number ${document.number} already exists in this location.`\n      );\n\n    console.log(\"Saving document\", document.id);\n\n    if (document.id) {\n      await this.db.document.update({\n        where: {\n          document_id: document.id,\n        },\n        data: DocumentMap.toPersistenceUpdate(document),\n      });\n\n      await this.updateDocumentCSIDivisions(document.id, document.csiDivisionIDs);\n    } else {\n      const createdDocument = await this.db.document.create({\n        data: DocumentMap.toPersistence(document),\n      });\n\n      document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    await this.saveAdditionalAreas(document);\n    await this.saveRevisions(document);\n    await this.saveLinks(document);\n    await this.savePrograms(document);\n  }\n\n  async saveAdditionalAreas(document: Document) {\n    if (document.id) {\n      await this.db.document_additional_area.deleteMany({\n        where: {\n          document_id: document.id,\n        },\n      });\n    }\n\n    if (document.additionalAreaIDs && document.additionalAreaIDs.length > 0) {\n      await this.db.document_additional_area.createMany({\n        data: document.additionalAreaIDs.map((areaID) => ({\n          area_id: areaID,\n          document_id: document.id!,\n        })),\n      });\n    }\n  }\n\n  async saveRevisions(document: Document) {\n    let dbStatuses: { creation_ts: Date; revision_status_id: number }[];\n\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        if (revision.id) {\n          const updateDetails = await this.db.document_revision.update({\n            where: {\n              document_revision_id: revision.id,\n            },\n            data: DocRevisionMap.toPersistence(revision),\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = updateDetails.document_revision_status;\n        } else {\n          const createdRevision = await this.db.document_revision.create({\n            data: {\n              document_id: document.id!,\n              ...DocRevisionMap.toPersistence(revision),\n            },\n            include: {\n              document_revision_status: true,\n            },\n          });\n\n          dbStatuses = createdRevision.document_revision_status;\n\n          revision.setId(createdRevision.document_revision_id);\n        }\n\n        revision.statuses.forEach((status) => {\n          const updateStatusDetails = dbStatuses.find(\n            (updateStatusDetails) => updateStatusDetails.creation_ts.getTime() === status.creationTs.getTime()\n          );\n\n          updateStatusDetails && status.setId(updateStatusDetails.revision_status_id);\n        });\n      })\n    );\n\n    await Promise.all([this.saveLastStatus(document.lastRevision), this.saveLastRevision(document)]);\n  }\n\n  async saveLastRevision(document: Document) {\n    return this.db.document.update({\n      where: {\n        document_id: document.id,\n      },\n      data: {\n        latest_revision_id: document.lastRevision.id,\n      },\n    });\n  }\n\n  async saveLastStatus(revision: DocRevision) {\n    const statuses = await this.db.document_revision_status.findMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      orderBy: {\n        creation_ts: \"asc\",\n      },\n    });\n\n    if (statuses.at(-1)!.is_last && statuses.slice(0, statuses.length - 1).every((status) => !status.is_last)) {\n      return;\n    }\n\n    await this.db.document_revision_status.updateMany({\n      where: {\n        revision_id: revision.id!,\n      },\n      data: {\n        is_last: false,\n      },\n    });\n\n    await this.db.document_revision_status.update({\n      where: {\n        revision_status_id: statuses.at(-1)!.revision_status_id,\n      },\n      data: {\n        is_last: true,\n      },\n    });\n  }\n\n  private async addDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const addedPrograms = document.locationProgramIDs.added;\n\n    if (_.isEmpty(addedPrograms)) return;\n\n    await this.db.document_program.createMany({\n      data: addedPrograms.map((removedLocationProgramID) => ({\n        document_id: document.id,\n        location_program_id: removedLocationProgramID,\n      })),\n    });\n  }\n\n  private async removeDocumentPrograms(document: PersistedEntity<Document>): Promise<void> {\n    const removedPrograms = document.locationProgramIDs.removed;\n\n    if (_.isEmpty(removedPrograms)) return;\n\n    await this.db.document_program.deleteMany({\n      where: {\n        OR: removedPrograms.map((removedProgramID) => ({\n          document_id: document.id,\n          location_program_id: removedProgramID,\n        })),\n      },\n    });\n  }\n\n  private async savePrograms(document: PersistedEntity<Document>) {\n    await this.removeDocumentPrograms(document);\n    await this.addDocumentPrograms(document);\n  }\n\n  // TODO: Only run this function when entity has csi divisions updated (keep track of entity changes locally)\n  private async updateDocumentCSIDivisions(document_id: number, csi_division_ids: Collection<number>): Promise<void> {\n    if (!isEmpty(csi_division_ids.removed)) {\n      await this.db.document_csi_division.deleteMany({\n        where: {\n          document_id,\n          csi_division_id: {\n            in: csi_division_ids.removed,\n          },\n        },\n      });\n    }\n  }\n\n  private async saveLinks(document: Document) {\n    await Promise.all(\n      document.revisions.map(async (revision) => {\n        await this.updateLinks(revision);\n        await this.removeLinks(revision);\n        await this.addLinks(revision);\n      })\n    );\n  }\n\n  private async updateLinks(revision: DocRevision): Promise<void> {\n    const links = revision.links.filter((link) => link.didChange);\n\n    if (_.isEmpty(links)) return;\n\n    const scopeLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const requestLinks = links.filter((link) => link.type === DocumentRevisionLinkType.Request);\n\n    await Promise.all([\n      ...scopeLinks.map((scopeLink) =>\n        this.db.scope_document_revision.update({\n          where: {\n            id: scopeLink.id,\n          },\n          data: {\n            is_released: scopeLink.isReleased,\n          },\n        })\n      ),\n      ...requestLinks.map((requestLink) =>\n        this.db.request_document_revision.update({\n          where: {\n            id: requestLink.id,\n          },\n          data: {\n            is_released: requestLink.isReleased,\n          },\n        })\n      ),\n    ]);\n  }\n\n  private async addLinks(revision: DocRevision): Promise<void> {\n    const addedLinks = revision.links.added;\n\n    if (_.isEmpty(addedLinks)) return;\n\n    const addedScopes = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Scope);\n    const addedRequests = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Request);\n    const addedProjects = addedLinks.filter((link) => link.type === DocumentRevisionLinkType.Project);\n\n    await this.db.document_revision.update({\n      where: { document_revision_id: revision.id },\n      data: {\n        scope_document_revision: {\n          createMany: {\n            data: addedScopes.map((addedScope) => ({\n              scope_id: addedScope.parentID,\n              is_released: addedScope.isReleased,\n              created_by: addedScope.createdBy,\n            })),\n          },\n        },\n        request_document_revision: {\n          createMany: {\n            data: addedRequests.map((addedRequest) => ({\n              request_id: addedRequest.parentID,\n              is_released: addedRequest.isReleased,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n        project_document_revision: {\n          createMany: {\n            data: addedProjects.map((addedRequest) => ({\n              project_id: addedRequest.parentID,\n              created_by: addedRequest.createdBy,\n            })),\n          },\n        },\n      },\n    });\n  }\n\n  private async removeLinks(revision: DocRevision): Promise<void> {\n    const removedLinks = revision.links.removed;\n\n    if (_.isEmpty(removedLinks)) return;\n\n    const removedScopes = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Scope);\n    const removedRequests = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Request);\n    const removedProjects = removedLinks.filter((parent) => parent.type === DocumentRevisionLinkType.Project);\n\n    if (!_.isEmpty(removedScopes))\n      await this.db.scope_document_revision.deleteMany({\n        where: {\n          OR: removedScopes.map((removedScope) => ({\n            scope_id: removedScope.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedRequests))\n      await this.db.request_document_revision.deleteMany({\n        where: {\n          OR: removedRequests.map((removedRequest) => ({\n            request_id: removedRequest.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n\n    if (!_.isEmpty(removedProjects))\n      await this.db.project_document_revision.deleteMany({\n        where: {\n          OR: removedProjects.map((removedProject) => ({\n            project_id: removedProject.parentID,\n            revision_id: revision.id!,\n          })),\n        },\n      });\n  }\n\n  async isDocumentNumberUniqueInLocation(document: Document) {\n    const count = await this.db.document.count({\n      where: {\n        document_number: document.number,\n        location_id: document.locationID,\n        ...(document.id ? { document_id: { notIn: [document.id] } } : {}), // Exclude itself\n      },\n    });\n\n    return count === 0;\n  }\n\n  async delete(document: Document): Promise<void> {\n    if (!document.id) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n    assertPersistency(document);\n\n    const { count } = await this.db.document.updateMany({\n      where: {\n        AND: [this.baseQuery, { document_id: document.id }],\n      },\n      data: {\n        is_deleted: 1,\n      },\n    });\n\n    document.locationProgramIDs.removeAll();\n    await this.savePrograms(document);\n\n    if (!count) {\n      throw new EntityNotFoundError(\"Document\");\n    }\n  }\n\n  async getRevisionStatusTypes(): Promise<RevisionStatusType[]> {\n    const dbStatusTypes = await this.db.document_revision_status_type.findMany();\n    return dbStatusTypes.map((dbStatusType) => RevisionStatusType.create(dbStatusType.type as TRevisionStatusType));\n  }\n\n  public getParentSelect(parentEntity: PersistedScope | PersistedRequestInstance | PersistedProject) {\n    if (parentEntity instanceof Scope) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"scope_id\",\n        table_name: \"scope_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof RequestInstance) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"request_id\",\n        table_name: \"request_document_revision\",\n      };\n    }\n\n    if (parentEntity instanceof Project) {\n      return {\n        id: parentEntity.id,\n        ref_name: \"project_id\",\n        table_name: \"project_document_revision\",\n      };\n    }\n\n    throw new Error(\"Invalid parent entity\");\n  }\n\n  public async getDocumentsRefData(documentIDs: number[]) {\n    const dbRefDataDocuments = await this.db.document.findMany({\n      where: {\n        document_id: { in: documentIDs },\n      },\n      include: {\n        site: true,\n        building: true,\n        area: true,\n        area_detail: true,\n        document_additional_area: {\n          include: {\n            area: true,\n          },\n        },\n        location_level: true,\n        document_type: true,\n        discipline: true,\n        document_program: { include: { location_program: { include: { program: true } } } },\n        created_by_user: { include: userQueryInclude },\n        updated_by_user: { include: userQueryInclude },\n        created_by_company_full: { include: companyQueryInclude },\n        updated_by_company_full: { include: companyQueryInclude },\n        document_csi_division: { include: { csi_division: { select: { title: true } } } },\n        document_submittal_category: true,\n        document_submittal_type: true,\n        document_submittal_detail: { include: { document_submittal_type: true } },\n      },\n    });\n\n    const refData: ReferencedDocData = {};\n\n    if (dbRefDataDocuments.length === 0) return refData;\n\n    const programs: Record<number, (typeof programsList)[0]> = {};\n\n    const programsList = await this.locationRepo.getProgramsInLocation(dbRefDataDocuments[0].location_id);\n\n    programsList.forEach((locationProgram) => {\n      programs[locationProgram.program.id] = locationProgram;\n    });\n\n    dbRefDataDocuments.forEach((dbRefDataDocument) => {\n      refData[dbRefDataDocument.document_id] = {\n        type: DocumentTypeMap.toDomain(dbRefDataDocument.document_type),\n        discipline: DisciplineMap.toDomain(dbRefDataDocument.discipline),\n        createdBy: UserMap.toDomain(dbRefDataDocument.created_by_user),\n        updatedBy: dbRefDataDocument.updated_by_user ? UserMap.toDomain(dbRefDataDocument.updated_by_user) : null,\n        site: dbRefDataDocument.site ? AreaMap.toDomain(dbRefDataDocument.site) : null, // TODO: ATOM-3197 - Remove NULL when site is mandatory\n        building: AreaMap.toDomain(dbRefDataDocument.building),\n        area: AreaMap.toDomain(dbRefDataDocument.area),\n        areaDetail: dbRefDataDocument.area_detail ? AreaMap.toDomain(dbRefDataDocument.area_detail) : null,\n        additionalAreas: dbRefDataDocument.document_additional_area.map((additional_area) =>\n          AreaMap.toDomain(additional_area.area)\n        ),\n        level: LevelMap.toDomain(dbRefDataDocument.location_level),\n        programs: dbRefDataDocument.document_program.map(({ location_program }) =>\n          LocationProgramMap.toDomain(location_program, ProgramMap.toDomain(location_program.program), {\n            enabled: true,\n          })\n        ),\n        createdByCompany: CompanyMap.toDomain(dbRefDataDocument.created_by_company_full),\n        updatedByCompany: dbRefDataDocument.updated_by_company_full\n          ? CompanyMap.toDomain(dbRefDataDocument.updated_by_company_full)\n          : null,\n        csiDivisions: dbRefDataDocument.document_csi_division.map((csiDivision) =>\n          CSIDivisionMap.toDomain({ division_id: csiDivision.csi_division_id, title: csiDivision.csi_division.title })\n        ),\n        submittal: {\n          category: dbRefDataDocument.document_submittal_category\n            ? DocumentSubmittalCategoryMap.toDomain(dbRefDataDocument.document_submittal_category)\n            : null,\n          type: dbRefDataDocument.document_submittal_type\n            ? DocumentSubmittalTypeMap.toDomain(dbRefDataDocument.document_submittal_type)\n            : null,\n          detail: dbRefDataDocument.document_submittal_detail\n            ? DocumentSubmittalDetailMap.toDomain(dbRefDataDocument.document_submittal_detail)\n            : null,\n        },\n      };\n    });\n\n    return refData;\n  }\n\n  public async getRevisionsRefData(revisionIDs: number[]) {\n    const dbRefDataRevisions = await this.db.document_revision.findMany({\n      where: {\n        document_revision_id: { in: revisionIDs },\n      },\n      include: {\n        file: true,\n        user: { include: userQueryInclude },\n        location_document_purpose: { include: { document_purpose: true } },\n      },\n    });\n\n    const refData: Record<\n      number,\n      {\n        file: File;\n        createdByUser: PersistedEntity<User>;\n        purposeType: LocationDocumentPurpose;\n      }\n    > = {};\n\n    dbRefDataRevisions.forEach((dbRefDataRevision) => {\n      refData[dbRefDataRevision.document_revision_id] = {\n        file: FileMap.toDomain(dbRefDataRevision.file),\n        createdByUser: UserMap.toDomain(dbRefDataRevision.user),\n        purposeType: LocationDocumentPurposeMap.toDomain(\n          dbRefDataRevision.location_document_purpose,\n          DocumentPurposeMap.toDomain(dbRefDataRevision.location_document_purpose.document_purpose),\n          { enabled: true }\n        ),\n      };\n    });\n\n    return refData;\n  }\n\n  private getParentSelectFromIDs({\n    ids,\n    refName,\n    tableName,\n  }: {\n    ids: number[];\n    refName: string;\n    tableName: string;\n  }): Prisma.documentWhereInput {\n    return {\n      document_revision: {\n        some: {\n          [tableName]: {\n            some: {\n              [refName]: { in: ids },\n            },\n          },\n        },\n      },\n    };\n  }\n\n  private async getMaximumSequenceNumberDocument(\n    document: DocumentMetadata,\n    locationID: number,\n    numberingFormat: DocumentNumberingScheme.DocumentNumberingSegment[]\n  ): Promise<Document | undefined> {\n    const filter: any = {};\n\n    for (const segment of numberingFormat) {\n      if (\n        segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER ||\n        segment.fieldKey === DocumentFieldType.Type.FREE_TEXT ||\n        segment.fieldKey === DocumentFieldType.Type.ORIGINATING_ORGANIZATION\n      ) {\n        continue;\n      }\n      if (segment.fieldKey === DocumentFieldType.Type.PURPOSE) {\n        filter[\"document_revision\"] = {\n          some: {\n            location_document_purpose_id: document.locationDocumentPurposeID,\n          },\n        };\n        continue;\n      }\n      const property = typeToProperty[segment.fieldKey as keyof typeof typeToProperty];\n      if (!property) {\n        throw new Error(`Unsupported numbering scheme segment: ${segment}`);\n      }\n      const column = propertyToColumn[property as keyof typeof propertyToColumn] as string;\n      if (!column) {\n        throw new Error(`Unsupported property: ${property}`);\n      }\n      filter[column] = document[property];\n    }\n\n    const sequenceNumberIndex = numberingFormat.findIndex(\n      (segment) => segment.fieldKey === DocumentFieldType.Type.SEQUENCE_NUMBER\n    );\n    const documentNumber = document.number.split(\"-\");\n\n    if (documentNumber[sequenceNumberIndex] === DocumentFieldType.Type.SEQUENCE_NUMBER) {\n      documentNumber[sequenceNumberIndex] = \"%\";\n    }\n\n    const numberingSchemeMatchCondition = {\n      document_number: {\n        contains: documentNumber.join(\"-\"),\n      },\n    };\n\n    const dbDocument = await this.db.document.findFirst({\n      where: {\n        AND: [\n          accessibleBy(this.authzService.getUserAbility(), \"read\").document,\n          this.baseQuery,\n          filter,\n          numberingSchemeMatchCondition,\n          { location_id: locationID },\n        ],\n      },\n      include: getDocumentQueryInclude(this.authzService),\n      orderBy: {\n        sequence_number: \"desc\",\n      },\n    });\n\n    if (!dbDocument) {\n      return undefined;\n    }\n\n    return DocumentMap.toDomain(dbDocument);\n  }\n\n  async getNextSequenceNumber(\n    document: DocumentMetadata,\n    locationID: number,\n    format: DocumentNumberingScheme.DocumentNumberingSegment[],\n    sequenceNumberStart: number\n  ): Promise<number> {\n    const matchingDocument = await this.getMaximumSequenceNumberDocument(document, locationID, format);\n    if (!matchingDocument) {\n      return sequenceNumberStart;\n    }\n    const maxSequenceNumber = matchingDocument.sequenceNumber ?? 0;\n    return Math.max(maxSequenceNumber + 1, sequenceNumberStart);\n  }\n}\n```\n\nwhen i call the save method back to back i get the following error, why is that, i have a transaction outside\n\nInvalid `prisma.document.update()` invocation:\n\n\nUnique constraint failed on the constraint: `PRIMARY`\n    at $n.handleRequestError (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:121:7315)\n    at $n.handleAndLogRequestError (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:121:6623)\n    at $n.request (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:121:6307)\n    at l (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:130:9633)\n    at DocumentRepo.save (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/repositories/document.repo.ts:345:13)\n    at UseCase.execute (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-document/use-case.ts:35:13)\n    at /Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/use-case.ts:31:36\n    at /Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/transaction-service.ts:62:28\n    at Proxy._transactionWithCallback (/Users/adathan/Tesla/atom-web/node_modules/@prisma/client/runtime/library.js:130:8000)\n    at Function.retry (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/transaction-service.ts:20:32)\n    at TransactionService.getNewContainer (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/transaction-service.ts:56:16)\n    at UseCase.createDocument (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/use-case.ts:29:20)\n    at UseCase.execute (/Users/adathan/Tesla/atom-web/src/server/new-structure/application/use-cases/document-directory/create-documents/use-case.ts:20:34)\n    at BaseController.executeImpl (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/base-controller.ts:43:28)\n    at BaseController.execute (/Users/adathan/Tesla/atom-web/src/server/new-structure/framework/infrastructure/base-controller.ts:24:9) {\n  code: 'P2002',\n  clientVersion: '5.22.0',\n  meta: { modelName: 'document', target: 'PRIMARY' }\n}\nThe error occurs because there's a race condition when trying to save multiple documents concurrently with auto-generated IDs. Even though you have a transaction outside, the individual save operations can still conflict when trying to insert records with the same primary key.\n\nTo fix this, you should:\n\n1. Either ensure the document IDs are pre-assigned before saving\n2. Or modify the save method to handle the transaction and concurrent saves properly\n\nHere's how you could modify the save method to handle this better:\n\n```typescript\nasync save(document: Document) {\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation) {\n        throw new DocumentNumberAlreadyExistsError(\n            `A document with number ${document.number} already exists in this location.`\n        );\n    }\n\n    if (document.id) {\n        // Update existing document\n        await this.db.document.update({\n            where: {\n                document_id: document.id,\n            },\n            data: DocumentMap.toPersistenceUpdate(document),\n        });\n    } else {\n        // Create new document with a single create operation\n        const createdDocument = await this.db.document.create({\n            data: {\n                ...DocumentMap.toPersistence(document),\n                document_csi_division: document.csiDivisionIDs.length > 0 ? {\n                    createMany: {\n                        data: document.csiDivisionIDs.map(id => ({\n                            csi_division_id: id\n                        }))\n                    }\n                } : undefined,\n            },\n        });\n\n        document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    \n    // Execute these operations in parallel after the main document is created\n    await Promise.all([\n        this.saveAdditionalAreas(document),\n        this.saveRevisions(document),\n        this.saveLinks(document),\n        this.savePrograms(document)\n    ]);\n\n    return document;\n}\n```\n\nAlso, ensure that your transaction service is properly configured to handle concurrent operations. Here's an example of how the transaction could be structured:\n\n```typescript\n// In your use case\nasync execute(documents: Document[]) {\n    return this.transactionService.execute(async () => {\n        const savedDocuments = [];\n        // Save documents sequentially within the transaction\n        for (const document of documents) {\n            const saved = await this.documentRepo.save(document);\n            savedDocuments.push(saved);\n        }\n        return savedDocuments;\n    });\n}\n```\n\nThe key points in the fix are:\n\n1. Combining related operations into a single create/update call where possible\n2. Using Promise.all for parallel operations only after the main document record is created\n3. Ensuring sequential processing of multiple documents within a transaction\n4. Proper error handling and rollback in case of failures\n\nThis should help prevent the unique constraint violations while maintaining data consistency.\nbut my log prints this\nSaving document undefined\nSaving document 1\nAh, I see the issue now. The log shows that you're trying to save a document with undefined ID first and then saving a document with ID 1. This suggests there might be an issue with how the documents are being processed or how the IDs are being set.\n\nLet's modify the save method to include better logging and handling of document states:\n\n```typescript\nasync save(document: Document) {\n    console.log(\"Starting save for document:\", {\n        id: document.id,\n        number: document.number,\n        isNew: !document.id\n    });\n\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation) {\n        throw new DocumentNumberAlreadyExistsError(\n            `A document with number ${document.number} already exists in this location.`\n        );\n    }\n\n    if (document.id) {\n        console.log(`Updating existing document ${document.id}`);\n        await this.db.document.update({\n            where: {\n                document_id: document.id,\n            },\n            data: DocumentMap.toPersistenceUpdate(document),\n        });\n    } else {\n        console.log(\"Creating new document\");\n        const createdDocument = await this.db.document.create({\n            data: DocumentMap.toPersistence(document),\n        });\n\n        console.log(\"Created document with ID:\", createdDocument.document_id);\n        document.setId(createdDocument.document_id);\n    }\n\n    assertPersistency(document);\n    \n    // Execute these in sequence to avoid race conditions\n    await this.saveAdditionalAreas(document);\n    await this.saveRevisions(document);\n    await this.saveLinks(document);\n    await this.savePrograms(document);\n}\n```\n\nAlso, can you share the code where you're calling this save method? It seems like you might be trying to save the same document twice, or there might be an issue with how the document objects are being managed. \n\nFor example, if you're doing something like:\n\n```typescript\n// This could cause problems\nconst doc = new Document(...);\nawait documentRepo.save(doc);  // First save\nawait documentRepo.save(doc);  // Second save with same document\n```\n\nInstead, you should ensure that you're either:\n1. Only saving each document once, or\n2. Creating new document instances for each save operation\n\nCould you share the code that's calling the save method so we can identify where the duplicate save is happening?\nam trying to save the same document twice, its not a usecase, its a test, first time it id is undefined because its a new document, but in the second call, its an update, since there is an id, I am trying to understand why this is failing\nAh, I understand now. The issue is likely occurring because there's a race condition between the first save operation completing and the second save operation starting, even within a transaction. The second operation might be starting before the first one has fully committed its changes.\n\nLet's modify the test to ensure proper sequencing:\n\n```typescript\n// Test example\nit('should be able to save the same document twice', async () => {\n  const document = new Document(...); // First creation\n  \n  // First save\n  await documentRepo.save(document);\n  \n  // Ensure we wait for any potential async operations to complete\n  await new Promise(resolve => setTimeout(resolve, 100));\n  \n  // Second save (now as an update)\n  await documentRepo.save(document);\n});\n```\n\nOr better yet, you could modify the save method to explicitly wait for all operations to complete before returning:\n\n```typescript\nasync save(document: Document) {\n    console.log(\"Starting save for document:\", {\n        id: document.id,\n        number: document.number,\n        isNew: !document.id\n    });\n\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation) {\n        throw new DocumentNumberAlreadyExistsError(\n            `A document with number ${document.number} already exists in this location.`\n        );\n    }\n\n    try {\n        if (document.id) {\n            console.log(`Updating existing document ${document.id}`);\n            await this.db.document.update({\n                where: {\n                    document_id: document.id,\n                },\n                data: DocumentMap.toPersistenceUpdate(document),\n            });\n        } else {\n            console.log(\"Creating new document\");\n            const createdDocument = await this.db.document.create({\n                data: DocumentMap.toPersistence(document),\n            });\n\n            console.log(\"Created document with ID:\", createdDocument.document_id);\n            document.setId(createdDocument.document_id);\n        }\n\n        assertPersistency(document);\n        \n        // Wait for all operations to complete\n        await Promise.all([\n            this.saveAdditionalAreas(document),\n            this.saveRevisions(document),\n            this.saveLinks(document),\n            this.savePrograms(document)\n        ]);\n\n        // Optional: Verify the save completed successfully\n        await this.db.document.findUniqueOrThrow({\n            where: { document_id: document.id! }\n        });\n\n        return document;\n    } catch (error) {\n        console.error('Error saving document:', error);\n        throw error;\n    }\n}\n```\n\nCould you share the test code you're using? That would help us identify if there's any specific timing or transaction issue we need to address.\n\nAlso, make sure that your transaction service is properly configured to handle this case. The transaction should ensure that the first operation is fully committed before the second one starts.\n fetched the d\n  \n```ts atom-web/src/server/new-structure/application/use-cases/document-directory/create-document/use-case.ts\nimport { Document } from \"@atom/types\";\nimport { inject, injectable } from \"inversify\";\nimport { ForbiddenError } from \"../../../../../utils/errors/index\";\nimport { CompanyService } from \"../../../../domain/company/company.service\";\nimport { IDocumentRepo } from \"../../../../domain/document/repos/document.repo\";\nimport { IDocumentService } from \"../../../../domain/document/services/document.service\";\nimport { AuthzService } from \"../../../../framework/application/authz.service\";\nimport { SessionUser } from \"../../../../framework/application/session-user\";\nimport { BaseUseCase } from \"../../../../framework/application/use-case\";\nimport container from \"../../../../framework/inversify/inversify.config\";\nimport TYPES from \"../../../../framework/inversify/types\";\nimport { IDocumentRevisionReviewFlowService } from \"../../../services/document-revision-review-flow.service\";\n\n@injectable()\nclass UseCase implements BaseUseCase<Document.ReqCreateLocationDocument, Promise<any>> {\n  constructor(\n    @inject(AuthzService) private readonly authzService: AuthzService,\n    @inject(TYPES.IDocumentRepo) private readonly documentRepo: IDocumentRepo,\n    @inject(TYPES.IDocumentService) private readonly documentService: IDocumentService,\n    @inject(SessionUser) private readonly sessionUser: SessionUser,\n    @inject(CompanyService) private readonly companyService: CompanyService,\n    @inject(TYPES.IDocumentRevisionReviewFlowService)\n    private readonly documentRevisionReviewFlowService: IDocumentRevisionReviewFlowService\n  ) {}\n\n  public async execute(request: Document.ReqCreateLocationDocument) {\n    if (this.sessionUser.isExternal && request.reviewFlowTemplateID) {\n      throw new ForbiddenError(\"External users cannot set review flow\");\n    }\n\n    try {\n      const locationID = request.locationID;\n\n      this.validateUserPermission(locationID);\n\n      const company = await this.companyService.getSessionUserCompany();\n      const document = await this.documentService.createDocument(request, this.sessionUser.userID, locationID, company);\n\n      await this.documentRepo.save(document);\n\n      const documentNew = await this.documentRepo.getByID(document.id!);\n      console.log(documentNew);\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      await this.documentRepo.save(document);\n\n      console.log(\"after double save\");\n\n      if (request.reviewFlowTemplateID) {\n        await this.documentRevisionReviewFlowService.createReviewFlow({\n          revision: document.lastRevision,\n          locationID,\n          reviewFlowTemplateID: request.reviewFlowTemplateID,\n          document,\n        });\n      }\n\n      return document.id!;\n    } catch (e) {\n      console.log(\"Error in create document use case\", e);\n      throw e;\n    }\n  }\n\n  private validateUserPermission(locationID: number) {\n    this.authzService.authorize({\n      action: \"create\",\n      subject: \"document\",\n      locationID,\n      errorMessage: \"User can't create documents in this location.\",\n    });\n  }\n}\n\nexport { UseCase as CreateLocationDocumentUseCase };\n\ncontainer.bind<UseCase>(UseCase).toSelf();\n```\n\n this is the usage, i fetched the dcument, and it fetches and logs it but when i try to update it ,, it throws a primary constraint error on the document update invocation. help me debug\nI see the issue now. After the first save, you're fetching the document with `getByID`, but then trying to save the original `document` object again, not the newly fetched one. This can cause consistency issues because the original document might not have all the updated state from the database.\n\nHere's how to fix it:\n\n```typescript\npublic async execute(request: Document.ReqCreateLocationDocument) {\n    if (this.sessionUser.isExternal && request.reviewFlowTemplateID) {\n      throw new ForbiddenError(\"External users cannot set review flow\");\n    }\n\n    try {\n      const locationID = request.locationID;\n\n      this.validateUserPermission(locationID);\n\n      const company = await this.companyService.getSessionUserCompany();\n      const document = await this.documentService.createDocument(request, this.sessionUser.userID, locationID, company);\n\n      // First save\n      await this.documentRepo.save(document);\n\n      // Fetch the updated document\n      const documentNew = await this.documentRepo.getByID(document.id!);\n      \n      // Use the fetched document for the second save\n      await this.documentRepo.save(documentNew);\n\n      console.log(\"after double save\");\n\n      if (request.reviewFlowTemplateID) {\n        await this.documentRevisionReviewFlowService.createReviewFlow({\n          revision: documentNew.lastRevision, // Use documentNew here too\n          locationID,\n          reviewFlowTemplateID: request.reviewFlowTemplateID,\n          document: documentNew, // Use documentNew here too\n        });\n      }\n\n      return documentNew.id!;\n    } catch (e) {\n      console.log(\"Error in create document use case\", e);\n      throw e;\n    }\n  }\n```\n\nThe key changes are:\n1. After fetching the document with `getByID`, use that fetched instance (`documentNew`) for subsequent operations\n2. Use `documentNew` consistently throughout the rest of the method, including in the review flow creation\n\nThis ensures you're working with the most up-to-date state of the document from the database. The primary key constraint error was likely happening because the original document object might have been out of sync with what was actually in the database.\n\nAlso, you might not need the `setTimeout` anymore since we're properly fetching the updated document state from the database.\ni just fetched the document again to make sure that its saved. its not a requirement. \nAh, I understand now. You're right - the fetch was just to verify the save worked. The issue is still occurring with the original document when trying to save it twice.\n\nLet's add more debugging to understand what's happening in the save method:\n\n```typescript\nasync save(document: Document) {\n    console.log(\"Starting save for document:\", {\n        id: document.id,\n        number: document.number,\n        isNew: !document.id,\n        // Add more relevant document state\n        revisions: document.revisions.length,\n        // Add any other relevant properties\n    });\n\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation) {\n        throw new DocumentNumberAlreadyExistsError(\n            `A document with number ${document.number} already exists in this location.`\n        );\n    }\n\n    try {\n        if (document.id) {\n           console.log(`Updating existing document ${document.id}, persistence data:`, DocumentMap.toPersistenceUpdate(document));\n            await this.db.document.update({\n                where: {\n                    document_id: document.id,\n                },\n                data: DocumentMap.toPersistenceUpdate(document),\n            });\n        } else {\n            console.log(\"Creating new document, persistence data:\", DocumentMap.toPersistence(document));\n            const createdDocument = await this.db.document.create({\n                data: DocumentMap.toPersistence(document),\n            });\n\n            console.log(\"Created document with ID:\", createdDocument.document_id);\n            document.setId(createdDocument.document_id);\n        }\n\n        assertPersistency(document);\n        \n        // Log before each related save\n        console.log(\"Saving additional areas...\");\n        await this.saveAdditionalAreas(document);\n        console.log(\"Saving revisions...\");\n        await this.saveRevisions(document);\n        console.log(\"Saving links...\");\n        await this.saveLinks(document);\n        console.log(\"Saving programs...\");\n        await this.savePrograms(document);\n        console.log(\"All saves completed\");\n\n    } catch (error) {\n        console.error('Error saving document:', {\n            error,\n            documentState: {\n                id: document.id,\n                number: document.number,\n                // Add other relevant state\n            }\n        });\n        throw error;\n    }\n}\n```\n\nCan you run it with this additional logging? This will help us see:\n1. The exact state of the document at each save\n2. What data is being sent to Prisma\n3. At which point the error occurs\n4. Whether there might be any state changes between saves that could cause the conflict\n\nAlso, could you share the `DocumentMap.toPersistenceUpdate` method? The issue might be in how the update data is being prepared.\nStarting save for document: { id: undefined, number: 'AAAA', isNew: true, revisions: 1 }\nSaving document undefined\nCreating new document, persistence data: {\n  title: 'Document 1',\n  document_number: 'AAAA',\n  subcontractor: undefined,\n  sequence_number: undefined,\n  document_type: { connect: { document_type_id: 1 } },\n  creation_ts: 2025-04-11T14:39:59.264Z,\n  site: { connect: { area_id: 1 } },\n  building: { connect: { area_id: 2 } },\n  area: { connect: { area_id: 3 } },\n  area_detail: undefined,\n  location_level: { connect: { level_id: 1 } },\n  discipline: { connect: { discipline_id: 41 } },\n  created_by_company_full: { connect: { id: 1 } },\n  operation_log: { create: {} },\n  created_by_user: { connect: { id: 1 } },\n  location: { connect: { location_id: 1 } },\n  permit_number: undefined,\n  is_permit_required: false,\n  permit_frequency: null,\n  document_csi_division: { createMany: { data: [Array] } },\n  document_submittal_category: undefined,\n  document_submittal_type: undefined,\n  document_submittal_detail: undefined\n}\nCreated document with ID: 1\nSaving additional areas...\nSaving revisions...\nSaving links...\nSaving programs...\nAll saves completed\nStarting save for document: { id: 1, number: 'AAAA', isNew: false, revisions: 1 }\nSaving document 1\nUpdating existing document 1, persistence data: {\n  title: 'Document 1',\n  document_number: 'AAAA',\n  subcontractor: undefined,\n  sequence_number: undefined,\n  document_type: { connect: { document_type_id: 1 } },\n  creation_ts: undefined,\n  site: { connect: { area_id: 1 } },\n  building: { connect: { area_id: 2 } },\n  area: { connect: { area_id: 3 } },\n  area_detail: { disconnect: true },\n  location_level: { connect: { level_id: 1 } },\n  discipline: { connect: { discipline_id: 41 } },\n  created_by_company_full: { connect: { id: 1 } },\n  operation_log: {},\n  created_by_user: {},\n  location: { connect: { location_id: 1 } },\n  permit_number: undefined,\n  is_permit_required: false,\n  permit_frequency: null,\n  document_csi_division: { createMany: { data: [Array] } },\n  document_submittal_category: undefined,\n  document_submittal_type: undefined,\n  document_submittal_detail: undefined\n}\nError in create document use case PrismaClientKnownRequestError:\nInvalid `prisma.document.update()` invocation:\n\n\nUnique constraint failed on the constraint: `PRIMARY`\nLooking at the logs, I can see the issue. In the update operation, you're trying to create new CSI divisions again with `document_csi_division: { createMany: { data: [Array] } }`. This is causing a primary key conflict because these records already exist from the first save.\n\nYou need to modify the `DocumentMap.toPersistenceUpdate` method to handle existing relationships differently than creation. For updates, you should either:\n\n1. Skip the CSI divisions in the update if they haven't changed\n2. Or update existing ones instead of trying to create new ones\n\nHere's how you could modify the `DocumentMap.toPersistenceUpdate`:\n\n```typescript\nstatic toPersistenceUpdate(document: Document) {\n    return {\n        title: document.title,\n        document_number: document.number,\n        subcontractor: document.subcontractor,\n        sequence_number: document.sequenceNumber,\n        document_type: { connect: { document_type_id: document.typeID } },\n        // Don't include creation_ts in update\n        site: document.siteID ? { connect: { area_id: document.siteID } } : undefined,\n        building: { connect: { area_id: document.buildingID } },\n        area: { connect: { area_id: document.areaID } },\n        area_detail: document.areaDetailID \n            ? { connect: { area_id: document.areaDetailID } }\n            : { disconnect: true },\n        location_level: { connect: { level_id: document.levelID } },\n        discipline: { connect: { discipline_id: document.disciplineID } },\n        created_by_company_full: { connect: { id: document.createdByCompanyID } },\n        location: { connect: { location_id: document.locationID } },\n        permit_number: document.permitNumber,\n        is_permit_required: document.isPermitRequired,\n        permit_frequency: document.permitFrequency,\n        // Remove or handle CSI divisions differently for updates\n        // document_csi_division: { createMany: { data: [...] } },\n        document_submittal_category: document.submittalCategoryID \n            ? { connect: { id: document.submittalCategoryID } }\n            : undefined,\n        document_submittal_type: document.submittalTypeID\n            ? { connect: { id: document.submittalTypeID } }\n            : undefined,\n        document_submittal_detail: document.submittalDetailID\n            ? { connect: { id: document.submittalDetailID } }\n            : undefined,\n    };\n}\n```\n\nAnd in your save method, handle CSI divisions separately:\n\n```typescript\nasync save(document: Document) {\n    // ... existing code ...\n\n    if (document.id) {\n        await this.db.document.update({\n            where: {\n                document_id: document.id,\n            },\n            data: DocumentMap.toPersistenceUpdate(document),\n        });\n        \n        // Handle CSI divisions update separately if needed\n        if (document.csiDivisionIDs.didChange) {\n            await this.updateDocumentCSIDivisions(document.id, document.csiDivisionIDs);\n        }\n    } else {\n        // ... create code ...\n    }\n\n    // ... rest of the code ...\n}\n```\n\nThis should resolve the primary key constraint error by properly handling the update case for related records.\nthats not it, i commented the update csi code and it stilll shrows this error\n\nLet's try to isolate the issue. Since the error persists even without the CSI divisions, let's break it down further. Can you try this modified version of the save method to help us pinpoint exactly where the error is occurring:\n\n```typescript\nasync save(document: Document) {\n    console.log(\"Starting save for document:\", {\n        id: document.id,\n        number: document.number,\n        isNew: !document.id,\n        revisions: document.revisions.length,\n    });\n\n    const isDocumentNumberUniqueInLocation = await this.isDocumentNumberUniqueInLocation(document);\n\n    if (!isDocumentNumberUniqueInLocation) {\n        throw new DocumentNumberAlreadyExistsError(\n            `A document with number ${document.number} already exists in this location.`\n        );\n    }\n\n    try {\n        if (document.id) {\n            // First try just updating the basic document fields\n            const basicUpdateData = {\n                title: document.title,\n                document_number: document.number,\n                is_permit_required: document.isPermitRequired,\n                permit_frequency: document.permitFrequency,\n            };\n\n            console.log(\"Attempting basic update with:\", basicUpdateData);\n            \n            await this.db.document.update({\n                where: {\n                    document_id: document.id,\n                },\n                data: basicUpdateData,\n            });\n\n            // If basic update succeeds, then update relationships one by one\n            console.log(\"Basic update succeeded, updating relationships...\");\n\n            const relationshipUpdates = {\n                document_type: { connect: { document_type_id: document.typeID } },\n                site: document.siteID ? { connect: { area_id: document.siteID } } : undefined,\n                building: { connect: { area_id: document.buildingID } },\n                area: { connect: { area_id: document.areaID } },\n                location_level: { connect: { level_id: document.levelID } },\n                discipline: { connect: { discipline_id: document.disciplineID } },\n                created_by_company_full: { connect: { id: document.createdByCompanyID } },\n                location: { connect: { location_id: document.locationID } },\n            };\n\n            console.log(\"Updating relationships:\", relationshipUpdates);\n\n            await this.db.document.update({\n                where: {\n                    document_id: document.id,\n                },\n                data: relationshipUpdates,\n            });\n\n        } else {\n            console.log(\"Creating new document...\");\n            const createdDocument = await this.db.document.create({\n                data: DocumentMap.toPersistence(document),\n            });\n\n            console.log(\"Created document with ID:\", createdDocument.document_id);\n            document.setId(createdDocument.document_id);\n        }\n\n        assertPersistency(document);\n        \n        // Skip all the additional saves for now to isolate the issue\n        /*\n        await this.saveAdditionalAreas(document);\n        await this.saveRevisions(document);\n        await this.saveLinks(document);\n        await this.savePrograms(document);\n        */\n\n    } catch (error) {\n        console.error('Error saving document:', {\n            error,\n            documentState: {\n                id: document.id,\n                number: document.number,\n            }\n        });\n        throw error;\n    }\n}\n```\n\nThis version:\n1. Splits the update into two parts - basic fields and relationships\n2. Adds more detailed logging\n3. Temporarily skips the additional saves\n\nCan you try running with this version and share the logs? This will help us determine if:\n1. The basic update works but relationships are causing issues\n2. The error occurs immediately on any update attempt\n3. There might be a transaction/locking issue\n\nAlso, could you verify that when you fetch the document after the first save, the ID matches what you expect? Maybe add a log right after the fetch:\n\n```typescript\nconst documentNew = await this.documentRepo.getByID(document.id!);\nconsole.log(\"Fetched document details:\", {\n    id: documentNew.id,\n    number: documentNew.number,\n    // any other relevant fields\n});\n```\nStarting save for document: { id: undefined, number: 'AAAA', isNew: true, revisions: 1 }\nSaving document undefined\nCreating new document, persistence data: {\n  title: 'Document 1',\n  document_number: 'AAAA',\n  subcontractor: undefined,\n  sequence_number: undefined,\n  document_type: { connect: { document_type_id: 1 } },\n  creation_ts: 2025-04-11T15:15:37.872Z,\n  site: { connect: { area_id: 1 } },\n  building: { connect: { area_id: 2 } },\n  area: { connect: { area_id: 3 } },\n  area_detail: undefined,\n  location_level: { connect: { level_id: 1 } },\n  discipline: { connect: { discipline_id: 41 } },\n  created_by_company_full: { connect: { id: 1 } },\n  operation_log: { create: {} },\n  created_by_user: { connect: { id: 1 } },\n  location: { connect: { location_id: 1 } },\n  permit_number: undefined,\n  is_permit_required: false,\n  permit_frequency: null,\n  document_csi_division: { createMany: { data: [Array] } },\n  document_submittal_category: undefined,\n  document_submittal_type: undefined,\n  document_submittal_detail: undefined\n}\nCreated document with ID: 1\nSaving additional areas...\nSaving revisions...\nSaving links...\nSaving programs...\nAll saves completed\nStarting save for document: { id: 1, number: 'AAAA', isNew: false, revisions: 1 }\nSaving document 1\nUpdating existing document 1, persistence data: {\n  title: 'Document 1',\n  document_number: 'AAAA',\n  subcontractor: undefined,\n  sequence_number: undefined,\n  document_type: { connect: { document_type_id: 1 } },\n  creation_ts: undefined,\n  site: { connect: { area_id: 1 } },\n  building: { connect: { area_id: 2 } },\n  area: { connect: { area_id: 3 } },\n  area_detail: { disconnect: true },\n  location_level: { connect: { level_id: 1 } },\n  discipline: { connect: { discipline_id: 41 } },\n  created_by_company_full: { connect: { id: 1 } },\n  operation_log: {},\n  created_by_user: {},\n  location: { connect: { location_id: 1 } },\n  permit_number: undefined,\n  is_permit_required: false,\n  permit_frequency: null,\n  document_csi_division: { createMany: { data: [Array] } },\n  document_submittal_category: undefined,\n  document_submittal_type: undefined,\n  document_submittal_detail: undefined\n}\nAttempting basic update with: {\n  title: 'Document 1',\n  document_number: 'AAAA',\n  is_permit_required: undefined,\n  permit_frequency: undefined\n}\nBasic update succeeded, updating relationships...\nUpdating relationships: {\n  document_type: { connect: { document_type_id: 1 } },\n  site: { connect: { area_id: 1 } },\n  building: { connect: { area_id: 2 } },\n  area: { connect: { area_id: 3 } },\n  location_level: { connect: { level_id: 1 } },\n  discipline: { connect: { discipline_id: 41 } },\n  created_by_company_full: { connect: { id: undefined } },\n  location: { connect: { location_id: 1 } }\n}\nError in create document use case PrismaClientValidationError:\nInvalid `prisma.document.update()` invocation:\n\n{\n  where: {\n    document_id: 1\n  },\n  data: {\n    document_type: {\n      connect: {\n        document_type_id: 1\n      }\n    },\n    site: {\n      connect: {\n        area_id: 1\n      }\n    },\n    building: {\n      connect: {\n        area_id: 2\n      }\n    },\n    area: {\n      connect: {\n        area_id: 3\n      }\n    },\n    location_level: {\n      connect: {\n        level_id: 1\n      }\n    },\n    discipline: {\n      connect: {\n        discipline_id: 41\n      }\n    },\n    created_by_company_full: {\n      connect: {\n        id: undefined,\n?       code?: String,\n?       AND?: companyWhereInput | companyWhereInput[],\n?       OR?: companyWhereInput[],\n?       NOT?: companyWhereInput | companyWhereInput[],\n?       name?: StringFilter | String,\n?       searchable_company_code_name?: StringNullableFilter | String | Null,\n?       document_document_created_by_companyTocompany?: DocumentListRelationFilter,\n?       document_document_updated_by_companyTocompany?: DocumentListRelationFilter,\n?       location_warp_supplier?: Location_warp_supplierListRelationFilter,\n?       request_request_created_by_companyTocompany?: RequestListRelationFilter,\n?       request_request_updated_by_companyTocompany?: RequestListRelationFilter,\n?       task?: TaskListRelationFilter,\n?       team?: TeamListRelationFilter\n      }\n    },\n    location: {\n      connect: {\n        location_id: 1\n      }\n    }\n  }\n}\nAh, now I see the issue! The error is happening because `created_by_company_full` is trying to connect with an undefined id. In your relationshipUpdates, you have:\n\n```typescript\ncreated_by_company_full: { connect: { id: document.createdByCompanyID } }\n```\n\nBut `document.createdByCompanyID` is undefined in the second save. We should:\n\n1. Either skip the company update in the second save since it's already set\n2. Or ensure the company ID is properly carried over\n\nLet's modify the relationship updates to skip the company if we're doing an update:\n\n```typescript\nasync save(document: Document) {\n    // ... rest of the code ...\n\n    if (document.id) {\n        // First try just updating the basic document fields\n        const basicUpdateData = {\n            title: document.title,\n            document_number: document.number,\n            is_permit_required: document.isPermitRequired,\n            permit_frequency: document.permitFrequency,\n        };\n\n        await this.db.document.update({\n            where: {\n                document_id: document.id,\n            },\n            data: basicUpdateData,\n        });\n\n        // Skip company updates on subsequent saves\n        const relationshipUpdates = {\n            document_type: { connect: { document_type_id: document.typeID } },\n            site: document.siteID ? { connect: { area_id: document.siteID } } : undefined,\n            building: { connect: { area_id: document.buildingID } },\n            area: { connect: { area_id: document.areaID } },\n            location_level: { connect: { level_id: document.levelID } },\n            discipline: { connect: { discipline_id: document.disciplineID } },\n            location: { connect: { location_id: document.locationID } },\n            // Remove created_by_company_full from updates\n        };\n\n        await this.db.document.update({\n            where: {\n                document_id: document.id,\n            },\n            data: relationshipUpdates,\n        });\n\n    } else {\n        // ... create code ...\n    }\n\n    // ... rest of the code ...\n}\n```\n\nOr in your `DocumentMap.toPersistenceUpdate`, you could check if it's an update and skip certain fields:\n\n```typescript\nstatic toPersistenceUpdate(document: Document) {\n    // Skip certain fields during update\n    return {\n        title: document.title,\n        document_number: document.number,\n        document_type: { connect: { document_type_id: document.typeID } },\n        site: document.siteID ? { connect: { area_id: document.siteID } } : undefined,\n        building: { connect: { area_id: document.buildingID } },\n        area: { connect: { area_id: document.areaID } },\n        location_level: { connect: { level_id: document.levelID } },\n        discipline: { connect: { discipline_id: document.disciplineID } },\n        location: { connect: { location_id: document.locationID } },\n        permit_number: document.permitNumber,\n        is_permit_required: document.isPermitRequired,\n        permit_frequency: document.permitFrequency,\n        // Skip created_by_company_full and other creation-time fields\n    };\n}\n```\n\nThe error occurs because we're trying to update fields that should only be set during creation. We should modify the update logic to only update fields that can change after creation.\nthis was not in the initial issue, it was introduced now, alaos, why dows the error say Unique constraint failed on the constraint: `PRIMARY`, why not give more data\n\nYou're right - let's go back to the original error. The \"Unique constraint failed on the constraint: PRIMARY\" error typically means we're trying to create a record with a primary key that already exists, but Prisma's error message isn't very helpful here.\n\nTo debug this better, let's:\n\n1. First check what records we're trying to create/update using raw SQL logging:\n\n```typescript\nasync save(document: Document) {\n    console.log(\"Starting save for document:\", {\n        id: document.id,\n        number: document.number,\n        isNew: !document.id,\n        revisions: document.revisions.length,\n    });\n\n    try {\n        // Add debug query logging\n        const debugQuery = await this.db.$queryRaw`\n            SELECT * FROM document WHERE document_id = ${document.id};\n        `;\n        console.log(\"Current document in DB:\", debugQuery);\n\n        if (document.id) {\n            const updateData = DocumentMap.toPersistenceUpdate(document);\n            console.log(\"Update data:\", JSON.stringify(updateData, null, 2));\n            \n            await this.db.document.update({\n                where: {\n                    document_id: document.id,\n                },\n                data: updateData,\n            });\n        } else {\n            // ... create code ...\n        }\n\n        // ... rest of the code ...\n    } catch (error) {\n        if (error.code === 'P2002') {\n            // Add more detailed error logging for constraint violations\n            console.error('Constraint violation details:', {\n                error,\n                target: error.meta?.target,\n                documentState: document,\n            });\n        }\n        throw error;\n    }\n}\n```\n\n2. Let's also check if any of the related saves might be causing the issue. Can you temporarily comment out these lines and try again:\n\n```typescript\n// Comment these out temporarily to isolate the issue\n// await this.saveAdditionalAreas(document);\n// await this.saveRevisions(document);\n// await this.saveLinks(document);\n// await this.savePrograms(document);\n```\n\n3. Also, can you share the table structure for the document table and its related tables? Specifically, I'd like to see the primary key constraints. You can get this with:\n\n```sql\nSHOW CREATE TABLE document;\n```\n\nThe PRIMARY key error suggests we might be trying to:\n1. Create a record with an ID that already exists\n2. Or create a unique constraint violation in a related table\n3. Or there might be a trigger or cascade effect we're not seeing\n\nSince the error occurs on the second save, it would be helpful to see exactly what's in the database right after the first save and what we're trying to update in the second save.\nCREATE TABLE `document` (\n  `document_id` int unsigned NOT NULL AUTO_INCREMENT,\n  `latest_revision_id` int unsigned DEFAULT NULL,\n  `title` varchar(300) COLLATE utf8mb4_general_ci NOT NULL,\n  `document_number` varchar(250) COLLATE utf8mb4_general_ci NOT NULL,\n  `document_type_id` int unsigned NOT NULL,\n  `creation_ts` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `update_ts` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,\n  `site_id` int unsigned DEFAULT NULL,\n  `building_id` int unsigned NOT NULL,\n  `area_id` int unsigned NOT NULL,\n  `area_detail_id` int unsigned DEFAULT NULL,\n  `level_id` int unsigned NOT NULL,\n  `discipline_id` int unsigned NOT NULL,\n  `is_deleted` tinyint NOT NULL DEFAULT '0',\n  `operation_log_id` int unsigned NOT NULL,\n  `created_by` int unsigned NOT NULL,\n  `created_by_company` int unsigned NOT NULL,\n  `updated_by` int unsigned DEFAULT NULL,\n  `updated_by_company` int unsigned DEFAULT NULL,\n  `location_id` int unsigned NOT NULL,\n  `sequence_number` int unsigned DEFAULT NULL,\n  `subcontractor` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL,\n  `searchable_subcontractor` varchar(255) COLLATE utf8mb4_general_ci GENERATED ALWAYS AS (concat(regexp_replace(lower(`subcontractor`),_utf8mb4'\\\\+|-|!|<|>|\\\\||&|@|\\\\.|,|\\\\*|\\\\~',_utf8mb4'_'))) STORED,\n  `permit_number` text COLLATE utf8mb4_general_ci,\n  `is_permit_required` tinyint(1) NOT NULL DEFAULT '0',\n  `permit_frequency` enum('annually') COLLATE utf8mb4_general_ci DEFAULT NULL,\n  `submittal_category_id` int unsigned DEFAULT NULL,\n  `submittal_type_id` int unsigned DEFAULT NULL,\n  `submittal_detail_id` int unsigned DEFAULT NULL,\n  PRIMARY KEY (`document_id`),\n  UNIQUE KEY `operation_log_id` (`operation_log_id`),\n  KEY `fk__document_document_type` (`document_type_id`),\n  KEY `fk__document_created_by` (`created_by`),\n  KEY `fk__document_update_by` (`updated_by`),\n  KEY `fk_document_area` (`area_id`),\n  KEY `fk_document_discipline` (`discipline_id`),\n  KEY `fk_document_location_level` (`level_id`),\n  KEY `fk_document_location` (`location_id`),\n  KEY `fk__document_created_by_company` (`created_by_company`),\n  KEY `fk__document_updated_by_company` (`updated_by_company`),\n  KEY `fk_document_document_revision` (`latest_revision_id`),\n  KEY `fk_document_building` (`building_id`),\n  KEY `fk_document_site` (`site_id`),\n  KEY `fk_document_area_detail` (`area_detail_id`),\n  KEY `fk_document_document_submittal_category` (`submittal_category_id`),\n  KEY `fk_document_document_submittal_type` (`submittal_type_id`),\n  KEY `fk_document_document_submittal_detail` (`submittal_detail_id`),\n  FULLTEXT KEY `ft_document_number` (`document_number`),\n  FULLTEXT KEY `ft_document_title` (`title`),\n  FULLTEXT KEY `ft_document_title_number` (`title`,`document_number`),\n  FULLTEXT KEY `ft_subcontractor` (`searchable_subcontractor`),\n  CONSTRAINT `fk__document_created_by` FOREIGN KEY (`created_by`) REFERENCES `new_user` (`id`) ON DELETE RESTRICT ON UPDATE CASCADE,\n  CONSTRAINT `fk__document_created_by_company` FOREIGN KEY (`created_by_company`) REFERENCES `company` (`id`),\n  CONSTRAINT `fk__document_document_type` FOREIGN KEY (`document_type_id`) REFERENCES `document_type` (`document_type_id`) ON DELETE RESTRICT ON UPDATE CASCADE,\n  CONSTRAINT `fk__document_update_by` FOREIGN KEY (`updated_by`) REFERENCES `new_user` (`id`) ON DELETE RESTRICT ON UPDATE CASCADE,\n  CONSTRAINT `fk__document_updated_by_company` FOREIGN KEY (`updated_by_company`) REFERENCES `company` (`id`),\n  CONSTRAINT `fk_document_area` FOREIGN KEY (`area_id`) REFERENCES `area` (`area_id`),\n  CONSTRAINT `fk_document_area_detail` FOREIGN KEY (`area_detail_id`) REFERENCES `area` (`area_id`),\n  CONSTRAINT `fk_document_building` FOREIGN KEY (`building_id`) REFERENCES `area` (`area_id`),\n  CONSTRAINT `fk_document_discipline` FOREIGN KEY (`discipline_id`) REFERENCES `discipline` (`discipline_id`),\n  CONSTRAINT `fk_document_document_revision` FOREIGN KEY (`latest_revision_id`) REFERENCES `document_revision` (`document_revision_id`) ON DELETE SET NULL,\n  CONSTRAINT `fk_document_document_submittal_category` FOREIGN KEY (`submittal_category_id`) REFERENCES `document_submittal_category` (`id`),\n  CONSTRAINT `fk_document_document_submittal_detail` FOREIGN KEY (`submittal_detail_id`) REFERENCES `document_submittal_detail` (`id`),\n  CONSTRAINT `fk_document_document_submittal_type` FOREIGN KEY (`submittal_type_id`) REFERENCES `document_submittal_type` (`id`),\n  CONSTRAINT `fk_document_location` FOREIGN KEY (`location_id`) REFERENCES `location` (`location_id`) ON DELETE RESTRICT ON UPDATE CASCADE,\n  CONSTRAINT `fk_document_location_level` FOREIGN KEY (`level_id`) REFERENCES `location_level` (`level_id`),\n  CONSTRAINT `fk_document_operation_log` FOREIGN KEY (`operation_log_id`) REFERENCES `operation_log` (`operation_log_id`) ON DELETE RESTRICT ON UPDATE CASCADE,\n  CONSTRAINT `fk_document_site` FOREIGN KEY (`site_id`) REFERENCES `area` (`area_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci\nLooking at the table structure, I notice something important: there's a UNIQUE constraint on `operation_log_id`:\n\n```sql\nUNIQUE KEY `operation_log_id` (`operation_log_id`)\n```\n\nIn your create operation, you have:\n```typescript\noperation_log: { create: {} }\n```\n\nBut in your update operation, you have:\n```typescript\noperation_log: {}\n```\n\nWhen you do the second save, it might be trying to create another operation log or reuse the same operation_log_id, which would violate the unique constraint.\n\nLet's modify the save method to handle the operation log correctly:\n\n```typescript\nasync save(document: Document) {\n    try {\n        if (document.id) {\n            const updateData = DocumentMap.toPersistenceUpdate(document);\n            // Remove operation_log from update data since it's already created\n            delete updateData.operation_log;\n            \n            await this.db.document.update({\n                where: {\n                    document_id: document.id,\n                },\n                data: updateData,\n            });\n        } else {\n            const createdDocument = await this.db.document.create({\n                data: DocumentMap.toPersistence(document),\n            });\n            document.setId(createdDocument.document_id);\n        }\n\n        assertPersistency(document);\n        \n        await this.saveAdditionalAreas(document);\n        await this.saveRevisions(document);\n        await this.saveLinks(document);\n        await this.savePrograms(document);\n    } catch (error) {\n        console.error('Save error:', {\n            error,\n            documentState: {\n                id: document.id,\n                number: document.number,\n            }\n        });\n        throw error;\n    }\n}\n```\n\nAnd in your DocumentMap:\n\n```typescript\nstatic toPersistenceUpdate(document: Document) {\n    const data = {\n        // ... other fields ...\n        // Don't include operation_log in updates\n    };\n    return data;\n}\n```\n\nThe PRIMARY key error was misleading because it was actually a unique constraint violation on the operation_log_id field. Since operation_log has a 1:1 relationship with document and is required (NOT NULL), we need to handle it carefully during updates.\n\nLet me know if this resolves the issue!\nnot it still dosent fix it. also another thing to note, is when i call from api, this works, it only dont work when i call it from test? what could be the reason for that\nAh, this is a crucial detail! The difference between API calls and tests often points to transaction handling or database state management issues. In tests, you're likely running things in a transaction that might behave differently than in the API context.\n\nLet's look at how the test might be set up. Could you share:\n\n1. The test code where you're calling this\n2. Your test setup/configuration\n3. How transactions are being handled in your tests\n\nMy hypothesis is that:\n1. Either the test is running in a transaction that's not being properly managed\n2. Or there might be isolation level differences between test and API environments\n\nTry modifying your test like this:\n\n```typescript\nit('should save document twice', async () => {\n    // If you're using a transaction service in tests\n    await transactionService.execute(async () => {\n        const document = new Document(...); // Your document creation\n        \n        // First save\n        await documentRepo.save(document);\n        \n        // Force transaction to commit here if needed\n        // await transactionService.commit();\n        \n        // Optional: Clear any cached state\n        // await prisma.$disconnect();\n        // await prisma.$connect();\n        \n        // Second save\n        await documentRepo.save(document);\n    });\n});\n```\n\nOr if you're using a test transaction wrapper:\n\n```typescript\ndescribe('Document Repository', () => {\n    let documentRepo: DocumentRepo;\n    \n    beforeEach(async () => {\n        // Make sure we're starting with a clean state\n        await prisma.$transaction(async (tx) => {\n            // Setup your test data\n        });\n    });\n\n    afterEach(async () => {\n        // Cleanup if needed\n        await prisma.$disconnect();\n    });\n\n    it('should save document twice', async () => {\n        await prisma.$transaction(async (tx) => {\n            const document = new Document(...);\n            await documentRepo.save(document);\n            await documentRepo.save(document);\n        });\n    });\n});\n```\n\nAlso, let's add some transaction debugging to your repository:\n\n```typescript\n@injectable()\nexport class DocumentRepo extends BaseRepo implements IDocumentRepo {\n    async save(document: Document) {\n        console.log('Transaction info:', {\n            hasTransaction: !!(this.db as any).$transaction,\n            // Add any other relevant transaction state\n        });\n\n        try {\n            // ... rest of your save method\n        } catch (error) {\n            console.error('Save error with transaction details:', {\n                error,\n                transactionState: (this.db as any).$transaction ? 'active' : 'none',\n                documentId: document.id,\n            });\n            throw error;\n        }\n    }\n}\n```\n\nThis will help us understand if there's a difference in how transactions are being handled between your API and test environments. Can you share:\n\n1. How you're managing transactions in your API\n2. Your test setup code\n3. Any transaction/database configuration specific to your test environment\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3712}}},{"id":{"replica_id":0,"value":38},"start":35353,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3713}}},{"id":{"replica_id":0,"value":39},"start":38449,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3714}}},{"id":{"replica_id":0,"value":106},"start":38516,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3715}}},{"id":{"replica_id":0,"value":107},"start":40933,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3716}}},{"id":{"replica_id":0,"value":319},"start":41172,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3717}}},{"id":{"replica_id":0,"value":320},"start":44184,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3718}}},{"id":{"replica_id":0,"value":690},"start":47612,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3719}}},{"id":{"replica_id":0,"value":691},"start":49908,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3720}}},{"id":{"replica_id":0,"value":900},"start":49995,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3721}}},{"id":{"replica_id":0,"value":901},"start":52865,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3722}}},{"id":{"replica_id":0,"value":1167},"start":55193,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3723}}},{"id":{"replica_id":0,"value":1168},"start":58355,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3724}}},{"id":{"replica_id":0,"value":1534},"start":58434,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3725}}},{"id":{"replica_id":0,"value":1535},"start":62696,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3726}}},{"id":{"replica_id":0,"value":1889},"start":66960,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3727}}},{"id":{"replica_id":0,"value":1890},"start":70245,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3728}}},{"id":{"replica_id":0,"value":2436},"start":70412,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3729}}},{"id":{"replica_id":0,"value":2437},"start":73088,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3730}}},{"id":{"replica_id":0,"value":2743},"start":78108,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3731}}},{"id":{"replica_id":0,"value":2744},"start":80366,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3732}}},{"id":{"replica_id":0,"value":3502},"start":80537,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":3733}}},{"id":{"replica_id":0,"value":3503},"start":83590,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":3734}}}],"summary":"Prisma Transaction Lock Conflict Issue","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":33046},"icon":"File","label":"atom-web/src/server/new-structure/application/repositories/document.repo.ts","metadata":{"path":"atom-web/src/server/new-structure/application/repositories/document.repo.ts"}},{"range":{"start":44202,"end":47424},"icon":"File","label":"atom-web/src/server/new-structure/application/use-cases/document-directory/create-document/use-case.ts","metadata":{"path":"atom-web/src/server/new-structure/application/use-cases/document-directory/create-document/use-case.ts"}}],"thought_process_output_sections":[]}